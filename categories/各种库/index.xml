<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>各种库 on Daniex </title>
      <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>http://www.daniex.tk/categories/E59084E7A78DE5BA93/index.xml/</link>
    <language>zh-cn</language>
    <author>Daniex</author>
    
    <updated>Tue, 15 Nov 2011 02:22:56 &#43;0000</updated>
    
    <item>
      <title>tomcat添加sybase数据库支持配置方法</title>
      <link>http://www.daniex.tk/blog/2011/add-sybase-database-support-tomcat-configuration/</link>
      <pubDate>Tue, 15 Nov 2011 02:22:56 &#43;0000</pubDate>
      <author>Daniex</author>
      <guid>http://www.daniex.tk/blog/2011/add-sybase-database-support-tomcat-configuration/</guid>
      <description>&lt;p&gt;说起来其实很简单。&lt;/p&gt;

&lt;p&gt;1、安装sybase后到安装目录拷贝文件jconn2.jar，比如C:\sybase\jConnect-5_5\classes\jconn2.jar。&lt;/p&gt;

&lt;p&gt;2、将该文件拷贝的tomcat的lib文件夹下&lt;/p&gt;

&lt;p&gt;3、配置tomcat的conf文件夹下server.xml文件
&lt;blockquote&gt;&amp;lt;ResourceParams name=&amp;ldquo;jdbc/AutoTest&amp;rdquo;&amp;gt;
&amp;lt;parameter&amp;gt;
&amp;lt;name&amp;gt;url&amp;lt;/name&amp;gt;
&amp;lt;value&amp;gt;jdbc:sybase:Tds:142.100.2.132:5001/AutoTest&amp;lt;/value&amp;gt;
&amp;lt;/parameter&amp;gt;
&amp;lt;parameter&amp;gt;
&amp;lt;name&amp;gt;maxIdle&amp;lt;/name&amp;gt;
&amp;lt;value&amp;gt;2&amp;lt;/value&amp;gt;
&amp;lt;/parameter&amp;gt;
&amp;lt;parameter&amp;gt;
&amp;lt;name&amp;gt;maxActive&amp;lt;/name&amp;gt;
&amp;lt;value&amp;gt;4&amp;lt;/value&amp;gt;
&amp;lt;/parameter&amp;gt;
&amp;lt;parameter&amp;gt;
&amp;lt;name&amp;gt;driverClassName&amp;lt;/name&amp;gt;
&amp;lt;value&amp;gt;com.sybase.jdbc2.jdbc.SybDriver&amp;lt;/value&amp;gt;
&amp;lt;/parameter&amp;gt;
&amp;lt;parameter&amp;gt;
&amp;lt;name&amp;gt;maxWait&amp;lt;/name&amp;gt;
&amp;lt;value&amp;gt;5000&amp;lt;/value&amp;gt;
&amp;lt;/parameter&amp;gt;
&amp;lt;parameter&amp;gt;
&amp;lt;name&amp;gt;username&amp;lt;/name&amp;gt;
&amp;lt;value&amp;gt;saforfw&amp;lt;/value&amp;gt;
&amp;lt;/parameter&amp;gt;
&amp;lt;parameter&amp;gt;
&amp;lt;name&amp;gt;password&amp;lt;/name&amp;gt;
&amp;lt;value&amp;gt;saforfw&amp;lt;/value&amp;gt;
&amp;lt;/parameter&amp;gt;
&amp;lt;/ResourceParams&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/blockquote&gt;
搞定OK，大功告成。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SYBASE数据库日志详解(转)</title>
      <link>http://www.daniex.tk/blog/2011/sybase-database-log-r/</link>
      <pubDate>Sun, 09 Oct 2011 02:18:46 &#43;0000</pubDate>
      <author>Daniex</author>
      <guid>http://www.daniex.tk/blog/2011/sybase-database-log-r/</guid>
      <description>&lt;p&gt;写了点sybase相关的代码，发现数据库配置的时候少做了点配置，导致日志很快就满，无法进行下一步操作。查了下资料，转载过来。&lt;/p&gt;

&lt;p&gt;弄sybase遇到一个比较诡异的事情，就是ABC三人弄了三个sybase数据库，A连AB没问题连C有问题，B连B没问题连C有问题，C连A没问题，连BC有问题。数据库连接的代码都是一样的，闹腾啊。&lt;/p&gt;

&lt;p&gt;&amp;nbsp;
&lt;h1&gt;SYBASE数据库日志详解&lt;/h1&gt;
&lt;div&gt;&lt;/p&gt;

&lt;p&gt;每个数据库都有自己的事务日志（Transaction　Log），即系统表（Syslogs），日志对于数据库的数据安全性、完整性至关重要，本文详解SYBASE数据库日志。&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;&lt;/div&gt;
我们知道，SYBASE　SQL Server用事务（Transaction）来跟踪所有数据库的变化。事务是SQL　Server的工作单元。一个事务包含一条或多条作为整体执行的 T-SQL语句。每个数据库都有自己的事务日志（Transaction　Log），即系统表（Syslogs）。事务日志自动记录每个用户发出的每个事 务。日志对于数据库的数据安全性、完整性至关重要，我们进行数据库开发和维护必须熟知日志的相关知识。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一、SYBASE　SQL Server 如何记录和读取日志信息&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;SYBASE　SQL Server是先记Log的机制。每当用户执行将修改数据库的语句时，SQL　Server就会自动地把变化写入日志。一条语句所产生的所有变化都被记录 到日志后，它们就被写到数据页在缓冲区的拷贝里。该数据页保存在缓冲区中，直到别的数据页需要该内存时，该数据页才被写到磁盘上。若事务中的某条语句没能 完成，SQL　Server将回滚事务产生的所有变化。这样就保证了整个数据库系统的一致性和完整性。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、日志设备&lt;/strong&gt;
Log和数据库的Data一样，需要存放在数据库设备上，可以将Log和Data存放在同一设备上，也可以分开 存放。一般来说，应该将一个数据库的Data和Log存放在不同的数据库设备上。这样做有如下好处：一是可以单独地备份Backup　事务日志；二是防 止数据库溢满；三是可以看到Log的空间使用情况。
所建Log设备的大小，没有十分精确的方法来确定。一般来说，对于新建的数据库，Log的大小 应为数据库大小的30%左右。Log的大小还取决于数据库修改的频繁程度。如果数据库修改频繁，则Log的增长十分迅速。所以说Log空间大小依赖于用户 是如何使用数据库的。此外，还有其它因素影响Log大小，我们应该根据实际操作情况估计Log大小，并间隔一段时间就对Log进行备份和清除。
&lt;strong&gt;三、日志的清除&lt;/strong&gt;
随着数据库的使用，数据库的Log是不断增长的，必须在它占满空间之前将它们清除掉。清除Log有两种方法：
&lt;strong&gt;1.自动清除法
&lt;/strong&gt;
开放数据库选项 Trunc Log on Chkpt，使数据库系统每隔一段时间自动清除Log。此方法的优点是无须人工干预，由SQL　Server自动执行，并且一般不会出现Log溢满的情况；缺点是只清除Log而不做备份。
&lt;strong&gt;2.手动清除法&lt;/strong&gt;
执行命令“dump transaction”来清除Log。以下两条命令都可以清除日志：
&lt;table width=&#34;400&#34; border=&#34;1&#34; cellspacing=&#34;0&#34; cellpadding=&#34;2&#34; align=&#34;center&#34;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td bgcolor=&#34;#e6e6e6&#34;&gt;
dump transaction with truncate_only
dump transaction with no_log
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
通常删除事务日志中不活跃的部分可使用“dump transaction with trancate_only”命令，这条命令写进事务日志时，还要做必要的并发性检查。SYBASE提供“dump transaction with no_log”来处理某些非常紧迫的情况，使用这条命令有很大的危险性，SQL　Server会弹出一条警告信息。为了尽量确保数据库的一致性，你应将它 作为“最后一招”。
以上两种方法只是清除日志，而不做日志备份，若想备份日志，应执行“dump transaction database_name to dumpdevice”命令。
&lt;strong&gt;四、管理庞大的事务&lt;/strong&gt;
有些操作会大批量地修改数据，如大量数据的修改（Update）、删除一个表的所有数据（Delete）、大量数据的插入（Insert），这样会使Log增长速度很快，有溢满的危险。下面笔者给大家介绍一下如何拆分大事务，以避免日志的溢满。
例 如执行“update tab_a set col_a=0”命令时，若表tab_a很大，则此Update动作在未完成之前就可能使Log溢满，引起1105错误（Log Full），而且执行这种大的事务所产生的独占锁（Exclusive Table Lock），会阻止其他用户在执行Update操作期间修改这个表，这就有可能引起死锁。为避免这些情况发生，我们可以把这个大的事务分成几个小的事务， 并执行“dump transaction”动作。
上例中的情况就可以分成两个或多个小的事务：
&lt;table width=&#34;400&#34; border=&#34;1&#34; cellspacing=&#34;0&#34; cellpadding=&#34;2&#34; align=&#34;center&#34;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td bgcolor=&#34;#e6e6e6&#34;&gt;
update tab_a set col_a=0 where col_b&amp;gt;x
go
dump transaction database_name with truncate_only
go
update tab_a set col_a=0 where col_b &amp;lt;=x
go
dump transaction database_name with truncate_only
go
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
这样，一个大的事务就被分成两个较小的事务。
按照上述方法可以根据需要任意拆分大的事务。若这个事务需要备份到介质上，则不用“with truncate_only”选项。若执行“dump transaction with truncate_only”命令，应该先执行“dump database”。以此类推，我们可以对表删除、表插入等大事务做相应的拆分。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>用jersey和JSF开发应用，部署在weblogic上。</title>
      <link>http://www.daniex.tk/blog/2011/jersey-jsf-weblogic-development/</link>
      <pubDate>Wed, 29 Jun 2011 12:24:54 &#43;0000</pubDate>
      <author>Daniex</author>
      <guid>http://www.daniex.tk/blog/2011/jersey-jsf-weblogic-development/</guid>
      <description>&lt;p&gt;项目中尝试开发小工具，在构建RESTful服务的同时提供web页面。想可以用jersey和JSF在weblogic上部署工程。由于对两者都不是很熟。所以开发过程中磕磕绊绊比较不顺畅。&lt;/p&gt;

&lt;p&gt;单个功能的应用开发都挺顺利的，但当集成两者的时候发现，要么RESTful服务工作不正常要们web页面不正常。查了半天发现是web.xml中定义servlet有冲突。&lt;/p&gt;

&lt;p&gt;&amp;lt;servlet&amp;gt;
&amp;lt;servlet-name&amp;gt;Faces Servlet&amp;lt;/servlet-name&amp;gt;
&amp;lt;servlet-class&amp;gt;javax.faces.webapp.FacesServlet&amp;lt;/servlet-class&amp;gt;
&amp;lt;load-on-startup&amp;gt;1&amp;lt;/load-on-startup&amp;gt;
&amp;lt;/servlet&amp;gt;
&amp;lt;servlet-mapping&amp;gt;
&amp;lt;servlet-name&amp;gt;Faces Servlet&amp;lt;/servlet-name&amp;gt;
&amp;lt;url-pattern&amp;gt;/faces/&lt;em&gt;&amp;lt;/url-pattern&amp;gt;
&amp;lt;/servlet-mapping&amp;gt;
&amp;lt;servlet-mapping&amp;gt;
&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;JSF自己生成的部分
&amp;lt;servlet&amp;gt;
&amp;lt;servlet-name&amp;gt;My Jersey Appliaction&amp;lt;/servlet-name&amp;gt;
&amp;lt;servlet-class&amp;gt;com.sun.jersey.spi.container.servlet.ServletContainer&amp;lt;/servlet-class&amp;gt;
&amp;lt;/servlet&amp;gt;
&amp;lt;servlet-mapping&amp;gt;
&amp;lt;servlet-name&amp;gt;My Jersey Appliaction&amp;lt;/servlet-name&amp;gt;
&amp;lt;url-pattern&amp;gt;/&lt;/em&gt;&amp;lt;/url-pattern&amp;gt;
&amp;lt;/servlet-mapping&amp;gt;
&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-jersey的一种部署方式&lt;/p&gt;

&lt;p&gt;&lt;span style=&#34;color: #3366ff;&#34;&gt;要注意的是,他们的url-pattern是冲突的&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;1 三种写法&lt;/p&gt;

&lt;p&gt;①　完全匹配&lt;/p&gt;

&lt;p&gt;&amp;lt;url-pattern&amp;gt;/test/list.do&amp;lt;/url-pattern&amp;gt;&lt;/p&gt;

&lt;p&gt;② 目录匹配&lt;/p&gt;

&lt;p&gt;&amp;lt;url-pattern&amp;gt;/test/*&amp;lt;/url-pattern&amp;gt;&lt;/p&gt;

&lt;p&gt;③ 扩展名匹配&lt;/p&gt;

&lt;p&gt;&amp;lt;url-pattern&amp;gt;*.do&amp;lt;/url-pattern&amp;gt;
2 注意事项&lt;/p&gt;

&lt;p&gt;☆ 容器会首先查找完全匹配，如果找不到，再查找目录匹配，如果也找不到，就查找扩展名匹配。&lt;/p&gt;

&lt;p&gt;☆ 如果一个请求匹配多个“目录匹配”，容器会选择最长的匹配。&lt;/p&gt;

&lt;p&gt;☆ 定义”/*.action”这样一个看起来很正常的匹配会报错？因为这个匹配即属于路径映射，也属于扩展映射，导致容器无法判断。
☆ “/” 是用来定义default servlet映射的。&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;servlet+jsr311就能实现简单的RESTful服务端。项目需要的时候再用jersey或者RESTlet，EasyREST之类的包吧。
&lt;h3&gt;————————————————————————————————————&lt;/h3&gt;
&lt;h3&gt;RESTful Web 服务简介&lt;/h3&gt;
REST 在 2000 年由 Roy Fielding 在博士论文中提出，他是 HTTP 规范 1.0 和 1.1 版的首席作者之一。&lt;/p&gt;

&lt;p&gt;REST 中最重要的概念是资源（resources），使用全球 ID（通常使用 URI）标识。客户端应用程序使用 HTTP 方法（GET/ POST/ PUT/ DELETE）操作资源或资源集。RESTful Web 服务是使用 HTTP 和 REST 原理实现的 Web 服务。通常，RESTful Web 服务应该定义以下方面：&lt;/p&gt;

&lt;p&gt;Web 服务的基/根 URI，比如 &lt;a href=&#34;http://host//resources。&#34;&gt;http://host//resources。&lt;/a&gt;
支持 MIME 类型的响应数据，包括 JSON/XML/ATOM 等等。
服务支持的操作集合（例如 POST、GET、PUT 或 DELETE）。
&lt;h3&gt;&lt;strong&gt;JSR 311 (JAX-RS) 和 Jersey&lt;/strong&gt;&lt;/h3&gt;
JSR 311 或 JAX-RS（用于 RESTful Web Services 的 Java API）的提议开始于 2007 年，1.0 版本到 2008 年 10 月定稿。目前，JSR 311 版本 1.1 还处于草案阶段。该 JSR 的目的是提供一组 API 以简化 REST 样式的 Web 服务的开发。&lt;/p&gt;

&lt;p&gt;在 JAX-RS 规范之前，已经有 Restlet 和 RestEasy 之类的框架，可以帮助您实现 RESTful Web 服务，但是它们不够直观。Jersey 是 JAX-RS 的参考实现，它包含三个主要部分。&lt;/p&gt;

&lt;p&gt;核心服务器（Core Server）：通过提供 JSR 311 中标准化的注释和 API 标准化，您可以用直观的方式开发 RESTful Web 服务。
核心客户端（Core Client）：Jersey 客户端 API 帮助您与 REST 服务轻松通信。
集成（Integration）：Jersey 还提供可以轻松集成 Spring、Guice、Apache Abdera 的库。&lt;/p&gt;

&lt;p&gt;以上取自：&lt;a title=&#34;使用 Jersey 和 Apache Tomcat 构建 RESTful Web 服务&#34; href=&#34;http://www.ibm.com/developerworks/cn/web/wa-aj-tomcat/&#34; target=&#34;_blank&#34;&gt;IBM&amp;ndash;使用 Jersey 和 Apache Tomcat 构建 RESTful Web 服务&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&amp;nbsp;
&lt;h3&gt;Java Server Faces (JSF)&lt;/h3&gt;
JSF是一种用于构建Java Web 应用程序的标准框架(是Java Community Process  规定的JSR-127标准)。它提供了一种以组件为中心的用户界面(UI)构建方法，从而简化了Java服务器端应用程序的开发。由于由Java  Community Process (JCP) 推动，属于Java EE 5中的技术规范，而受到了厂商的广泛支持。&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SOAPUI测试WebService</title>
      <link>http://www.daniex.tk/blog/2011/soapui-test-webservice/</link>
      <pubDate>Fri, 17 Jun 2011 08:48:17 &#43;0000</pubDate>
      <author>Daniex</author>
      <guid>http://www.daniex.tk/blog/2011/soapui-test-webservice/</guid>
      <description>&lt;p&gt;最近要测试web service找到个不错的软件SOAPUI。推荐一下。&lt;/p&gt;

&lt;p&gt;由于Web服务是被程序调用的，一般不会提供界面让最终用户或测试人员直接使用。SOAPUI是针对这个情况特别开发的一个工具，用户可以在SOAPUI中通过简单的操作完成复杂的测试。当然SOAPUI还不仅仅是这点作用就，需要大家发掘发掘下。&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter&#34; title=&#34;SOAPUI&#34; src=&#34;http://www.soapui.org/images/stories/Getting_Started/Import_sample_soapUI_project.png&#34; alt=&#34;&#34; width=&#34;374&#34; height=&#34;398&#34; /&gt;&lt;/p&gt;

&lt;p&gt;地址：&lt;a href=&#34;http://www.soapui.org/&#34; target=&#34;_blank&#34;&gt;&lt;a href=&#34;http://www.soapui.org/&#34;&gt;http://www.soapui.org/&lt;/a&gt;&lt;/a&gt;
文档：&lt;a href=&#34;http://www.soapui.org/Getting-Started/installing-on-windows.html&#34; target=&#34;_blank&#34;&gt;&lt;a href=&#34;http://www.soapui.org/Getting-Started/installing-on-windows.html&#34;&gt;http://www.soapui.org/Getting-Started/installing-on-windows.html&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>RESTful WebService 搭建</title>
      <link>http://www.daniex.tk/blog/2011/restful-webservice-build/</link>
      <pubDate>Mon, 30 May 2011 02:36:51 &#43;0000</pubDate>
      <author>Daniex</author>
      <guid>http://www.daniex.tk/blog/2011/restful-webservice-build/</guid>
      <description>&lt;p&gt;最近了解了些关于WebService搭建方面的知识，这里稍稍做下整理。看的内容不少，但不够深入，如有不对的请指证。&lt;/p&gt;

&lt;p&gt;WSDL+SOAP搭建web Service的文档不少，就不多做介绍了。尝试在Jdeveloper下用ADF框架搭建着类WebService确实是方便快捷，轻松上手。这里主要罗列下RESTful框架的webservice搭建。&lt;/p&gt;

&lt;p&gt;在C/C++下开发RESTful服务需要第三方的库。核心是建立HTTP服务器和HTTP客户端的问题，其实就是在socket连接时使用TCP，再在上边加一层HTTP协议。如果需要的话中间可以加入SSL协议，使支持HTTPS。推荐使用的库是和mongoose和BOOST下的pion库。使用boost库非常方便，了解原理参照例子程序能很快搭建出来。mongoose是个轻量级的http server。核心代码就一个.c和一个.h文件。代码5000行。使用它的话需要稍稍阅读下源代码。&lt;/p&gt;

&lt;p&gt;在java上构建RESTful服务方法也很多。比如RESTlet库jersey库等等。RESTlet的资料相对jersey容易找一些。使用方法各有不同。RESTlet需要另外的http连接器库，比如GRIZZLY或者SimpleHTTP来建立HTTP服务器和客户端，然后再用RESTlet做更好的支持。JAX-RS: Java API for RESTful Web Services, SSL, JAXB, JSON, WADL等等。jersey可以用web服务器，比如glassfish，weblogic等通过annotation进行较快速的RESTful开发。也可以通过Grizzly等建通服务器。构建http请求除了使用内嵌接口之外，也可以使用java.net中的接口来建立连接发送请求。&lt;/p&gt;

&lt;p&gt;mongoose： &lt;a title=&#34;mongoose&#34; href=&#34;http://code.google.com/p/mongoose/&#34; target=&#34;_blank&#34;&gt;&lt;a href=&#34;http://code.google.com/p/mongoose/&#34;&gt;http://code.google.com/p/mongoose/&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;boost pion: &lt;a title=&#34;pion&#34; href=&#34;http://www.pion.org/projects/pion-network-library&#34; target=&#34;_blank&#34;&gt;&lt;a href=&#34;http://www.pion.org/projects/pion-network-library&#34;&gt;http://www.pion.org/projects/pion-network-library&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;TESTlet： &lt;a title=&#34;restlet&#34; href=&#34;http://www.restlet.org/&#34; target=&#34;_blank&#34;&gt;&lt;a href=&#34;http://www.restlet.org/&#34;&gt;http://www.restlet.org/&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;jersey： &lt;a title=&#34;jersey&#34; href=&#34;http://jersey.java.net/&#34; target=&#34;_blank&#34;&gt;&lt;a href=&#34;http://jersey.java.net/&#34;&gt;http://jersey.java.net/&lt;/a&gt;&lt;/a&gt;
&lt;pre class=&#34;brush:java&#34;&gt;******&lt;strong&gt;&lt;em&gt;jersey web服务器上RESTful服务例程&lt;/em&gt;&lt;/strong&gt;****&lt;/p&gt;

&lt;p&gt;package com.sun.jersey.samples.helloworld.resources;&lt;/p&gt;

&lt;p&gt;import javax.ws.rs.GET;&lt;/p&gt;

&lt;p&gt;import javax.ws.rs.Produces;&lt;/p&gt;

&lt;p&gt;import javax.ws.rs.Path;&lt;/p&gt;

&lt;p&gt;// The Java class will be hosted at the URI path &amp;ldquo;/helloworld&amp;rdquo;&lt;/p&gt;

&lt;p&gt;@Path(&amp;ldquo;/helloworld&amp;rdquo;)&lt;/p&gt;

&lt;p&gt;public class HelloWorldResource {&lt;/p&gt;

&lt;p&gt;// The Java method will process HTTP GET requests&lt;/p&gt;

&lt;p&gt;@GET&lt;/p&gt;

&lt;p&gt;// The Java method will produce content identified by the MIME Media&lt;/p&gt;

&lt;p&gt;// type &amp;ldquo;text/plain&amp;rdquo;&lt;/p&gt;

&lt;p&gt;@Produces(&amp;ldquo;text/plain&amp;rdquo;)&lt;/p&gt;

&lt;p&gt;public String getClichedMessage() {&lt;/p&gt;

&lt;p&gt;// Return some cliched textual content&lt;/p&gt;

&lt;p&gt;return &amp;ldquo;Hello World&amp;rdquo;;&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;}
&lt;/pre&gt;
&lt;pre class=&#34;brush:xml&#34;&gt;
****&lt;strong&gt;&lt;em&gt;web.xml文件&lt;/em&gt;&lt;/strong&gt;*****&lt;/p&gt;

&lt;p&gt;&amp;lt;?xml version=&amp;ldquo;1.0&amp;rdquo; encoding=&amp;ldquo;UTF-8&amp;rdquo;?&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;web-app version=&amp;ldquo;2.4&amp;rdquo; xmlns=&amp;ldquo;&lt;a href=&#34;http://java.sun.com/xml/ns/j2ee&amp;quot;&#34;&gt;http://java.sun.com/xml/ns/j2ee&amp;quot;&lt;/a&gt; xmlns:xsi=&amp;ldquo;&lt;a href=&#34;http://www.w3.org/2001/XMLSchema-instance&amp;quot;&#34;&gt;http://www.w3.org/2001/XMLSchema-instance&amp;quot;&lt;/a&gt; xsi:schemaLocation=&amp;ldquo;&lt;a href=&#34;http://java.sun.com/xml/ns/j2ee&#34;&gt;http://java.sun.com/xml/ns/j2ee&lt;/a&gt; &lt;a href=&#34;http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd&amp;quot;&amp;gt;&#34;&gt;http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd&amp;quot;&amp;gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;servlet&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;servlet-name&amp;gt;Jersey Web Application&amp;lt;/servlet-name&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;servlet-class&amp;gt;com.sun.jersey.spi.container.servlet.ServletContainer&amp;lt;/servlet-class&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;init-param&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;param-name&amp;gt;com.sun.jersey.config.property.packages&amp;lt;/param-name&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;param-value&amp;gt;com.sun.jersey.samples.helloworld.resources&amp;lt;/param-value&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;/init-param&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;load-on-startup&amp;gt;1&amp;lt;/load-on-startup&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;/servlet&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;servlet-mapping&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;servlet-name&amp;gt;Jersey Web Application&amp;lt;/servlet-name&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;/servlet-mapping&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;/web-app&amp;gt;&lt;/p&gt;

&lt;p&gt;&lt;/pre&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>系统日志工具syslog-ng相关介绍</title>
      <link>http://www.daniex.tk/blog/2011/syslog-ng-system-logging/</link>
      <pubDate>Thu, 28 Apr 2011 08:33:33 &#43;0000</pubDate>
      <author>Daniex</author>
      <guid>http://www.daniex.tk/blog/2011/syslog-ng-system-logging/</guid>
      <description>&lt;p&gt;遇到日志相关的问题，由于完全不了解Linux下专业的日志是怎么弄的，遇到Syslog这类词都是一头雾水。于是查了点资料，Syslog是什么？Syslogd是什么？syslog-ng又是什么？可以直接查wiki去了解。&lt;a title=&#34;Syslog wikipedia&#34; href=&#34;http://en.wikipedia.org/wiki/Syslog&#34; target=&#34;_blank&#34;&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Syslog&#34;&gt;http://en.wikipedia.org/wiki/Syslog&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;项目中用到了syslog-ng,简单的理解是就是一个专门来记录系统日志的服务。通过socket口将要记录的信息发送到这个服务中，通过配置，可以将要输出的信息记录下来。于是贴一篇介绍的文章。安装好syslog-ng后，配置文件在/etc/syslog-ng/syslog-ng.conf&lt;/p&gt;

&lt;p&gt;下一代系统日志工具(syslog-ng)&lt;/p&gt;

&lt;p&gt;原著：Balázs Scheidler
来源：&lt;a title=&#34;恒哥天地&#34; href=&#34;http://blogold.chinaunix.net/u2/62871/showart_527577.html&#34; target=&#34;_blank&#34;&gt;恒哥天地&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;1.syslog-ng简介
2.消息路径&lt;/p&gt;

&lt;p&gt;消息源
过滤器
日志消息目的
日志路径
选项
日志消息目的驱动器&lt;/p&gt;

&lt;p&gt;3.参考
消息源驱动器&lt;/p&gt;

&lt;p&gt;4.优化syslog-ng&lt;/p&gt;

&lt;p&gt;设置垃圾收集参数
设置输出队列的大小
设置同步(sync)参数&lt;/p&gt;

&lt;p&gt;1.syslog-ng简介&lt;/p&gt;

&lt;p&gt;在UNIX系统的维护中，经常会忽略系统事件的处理。经常检查系统日志对于保持系统的安全和正常运行是至关重要的。但是，系统日志中有太多的噪音，一些不是很重要的信息会掩盖重要的信息。目前的工具很难甄别出系统管理者感兴趣的信息。&lt;/p&gt;

&lt;p&gt;用户可以通过指定facility/priority，把消息发到不同的地方。系统预先定义了12+8个(mail、news、auth等)facility，八个不同的优先级(alert到debug)。&lt;/p&gt;

&lt;p&gt;这其中存在一个问题，大量的程序使用同样的facility(daemon)，把日志都保存到一个文件中(messages)，即使它们毫无关联。这样就造成用户很难筛选出自己感兴趣的东西。&lt;/p&gt;

&lt;p&gt;第二个问题是，大多数的程序无法改变日志配置，只能修改软件的源代码。&lt;/p&gt;

&lt;p&gt;因此，使用facility作为过滤不是一个好办法。最好能够有一些runtime选项，使用这些选项指定日志facility，建立新的facility。&lt;/p&gt;

&lt;p&gt;syslog- ng的一个设计原则就是建立更好的消息过滤粒度。syslog-ng能够进行基于内容和优先权/facility的过滤。另一个设计原则是更容易进行不同防火墙网段的信息转发，它支持主机链，即使日志消息经过了许多计算机的转发，也可以找出原发主机地址和整个转发链。最后的一个设计原则就是尽量使配置文件强大和简洁。&lt;/p&gt;

&lt;p&gt;2.消息路径&lt;/p&gt;

&lt;p&gt;一个消息路径是由一个或者多个日志消息源、一个或者多个过滤规则以及一个或者多个日志消息目的组成的。来自某个日志消息源的消息进入syslog-ng，如果消息命中某条规则，syslog-ng就把它发送到对应的日志消息目的。&lt;/p&gt;

&lt;p&gt;消息源&lt;/p&gt;

&lt;p&gt;一些日志消息源驱动器(source driver)组成一个消息源，这些驱动器使用给定的方法收集日志消息。譬如，有的syslog()系统调用使用的AF_UNIX、SOCK_STREAM风格的套接字源驱动器。&lt;/p&gt;

&lt;p&gt;在配置文件中，你可以使用下面的语法声明一个日志消息源：&lt;/p&gt;

&lt;p&gt;source  { source-driver(params); source-driver(params); &amp;hellip; };&lt;/p&gt;

&lt;p&gt;identifier是给定消息源的唯一标志，但是这个标志符不能和保留字有冲突。&lt;/p&gt;

&lt;p&gt;你可以控制使用哪个驱动器来收集日志消息，因而你需要知道你的系统和他的内部syslogd是如何通讯的。下面介绍一下某些平台中，syslogd是如何工作的。&lt;/p&gt;

&lt;p&gt;Linux 一个叫作/dev/log的SOCK_STREAM unix套接字
BSD 一个叫作/var/run/log的SOCK_STREAM unix套接字
Solaris(2.5或以下) 一个叫做/dev/log的SVR4风格的STREAMS设备
solaris(2.6或以上) 除了2.6之前版本使用的STREAMS设备之外，使用了一种新的多线程IPC方法调用门。默认情况下，这个调用门是/etc/syslog_door，由syslogd使用。&lt;/p&gt;

&lt;p&gt;在syslog-ng中，每个可能的通讯机制都有对应的日志消息源驱动器。例如：如果要打开一个SOCK_DGRAM风格的UNIX套接字进行通讯，你就会用到unix-dgram驱动器，同样SOCK_STREAM式的通讯需要unix-stream驱动器。&lt;/p&gt;

&lt;p&gt;例2-1.Linux中的一个源指令&lt;/p&gt;

&lt;p&gt;source src { unix-stream(&amp;ldquo;/dev/log&amp;rdquo;); internal(); udp(ip(0.0.0.0) port(514)); };&lt;/p&gt;

&lt;p&gt;驱动器可以使用参数，参数有些是必需的，有些是可选的。必需的参数一般在前面。上面的指令中，/dev/log就是必需参数。&lt;/p&gt;

&lt;p&gt;下面是可用的源驱动器：&lt;/p&gt;

&lt;p&gt;internal syslog-ng内部产生的消息
unix-stream 打开指定的SOCK_STREAM模式的unix套接字，接收日志消息
unix-dgram 打开指定的SOCK_DGRAM模式的unix套接字，接收日志消息
file 打开指定的文件读取日志信息
pipe,fifo 打开指定的管道或者FIFO设备，读取日志信息
tcp 在指定的TCP端口接收日志消息
udp 在指定的UDP端口接收日志消息
sun-stream(s) 在solaris系统中，打开一个(多个)指定的STREAM设备，从其中读取日志消息&lt;/p&gt;

&lt;p&gt;在下一章中，我们将详细介绍每个日志消息源驱动器。&lt;/p&gt;

&lt;p&gt;过滤器&lt;/p&gt;

&lt;p&gt;在syslog-ng中，过滤器执行日志路由。你可以使用syslog-ng的内部函数编写布尔表达式，来决定日志信息是否通过。&lt;/p&gt;

&lt;p&gt;过滤器也都有唯一的标志符，语法如下：&lt;/p&gt;

&lt;p&gt;fileter  { expression;};&lt;/p&gt;

&lt;p&gt;表达式中可以包含逻辑操作符(and、or、not)和函数。&lt;/p&gt;

&lt;p&gt;例2-2.一个搜索来自blurp主机，包含deny的日志消息的过滤指令&lt;/p&gt;

&lt;p&gt;filter f_blurp_deny { host(&amp;ldquo;blurp&amp;rdquo;) and match(&amp;ldquo;deny&amp;rdquo;); };&lt;/p&gt;

&lt;p&gt;下面是syslog-ng的过滤函数：&lt;/p&gt;

&lt;p&gt;facility() 根据设备选择日志消息
level()或者priority() 根据优先级选择日志消息
program() 日志消息的程序名是否匹配一个正则表达式
host() 日志消息的主机名是否和一个正则表达式匹配
match() 对日志消息的内容进行正则匹配
filter() 调用另一条过滤规则并判断它的值&lt;/p&gt;

&lt;p&gt;关于这些函数，后面的章节中将有更为详细的介绍。&lt;/p&gt;

&lt;p&gt;有一个特殊的过滤器标志符DEFAULT，用于捕获所有没有处理的日志消息。例如：&lt;/p&gt;

&lt;p&gt;options { keep_hostname(yes); };&lt;/p&gt;

&lt;p&gt;source src { unix-stream(&amp;ldquo;proba2&amp;rdquo;); internal(); };&lt;/p&gt;

&lt;p&gt;destination ftpd { file(&amp;ldquo;ftplog&amp;rdquo;); };
destination named { file(&amp;ldquo;namedlog&amp;rdquo;); };
destination daemon { file(&amp;ldquo;daemonlog&amp;rdquo;); };&lt;/p&gt;

&lt;p&gt;filter f_ftpd { match(&amp;ldquo;ftp&amp;rdquo;); };
filter f_named { match(&amp;ldquo;named&amp;rdquo;); };
filter f_daemon { facility(daemon); };&lt;/p&gt;

&lt;p&gt;log { source(src); filter(f_ftpd); destination(ftpd); };
log { source(src); filter(f_named); destination(named); };
log { source(src); filter(f_daemon); filter(DEFAULT); destination(daemon); };&lt;/p&gt;

&lt;p&gt;在这个例子中，default过滤器捕获所有没有被f_ftpd和f_named过滤器捕获的facility是daemon的日志消息。&lt;/p&gt;

&lt;p&gt;日志消息目的&lt;/p&gt;

&lt;p&gt;destination指定匹配过滤规则的日志消息的去处。和日志消息源类似，日志消息目的可以包括一些目的驱动器，指定日志的派发方向。你需要使用如下语法来声明日志消息目的：&lt;/p&gt;

&lt;p&gt;destination  { destination-driver(params); destination-driver(params); &amp;hellip; };&lt;/p&gt;

&lt;p&gt;下面是syslog-ng支持的日志消息目的驱动器：&lt;/p&gt;

&lt;p&gt;file 日志消息写到指定的文件
fifo,pipe 把日志消息写到指定的管道
unix-stream 把日志消息发送到给定的SOCK_STREAM类型的UNIX套接字(Linux)
unix-dgram 把日志消息发送到给定的SOCK_DGRAM类型的UNIX套接字(BSD)
udp 把日志消息发送到指定主机的UDP端口
TCP 把日志消息发送到指定主机的TCP端口
usertty 如果用户登录，把日志发送到指定的终端
program fork并启动指定的程序，把日志消息发送到这个进程的标准输出。&lt;/p&gt;

&lt;p&gt;详情请参考下面的章节。&lt;/p&gt;

&lt;p&gt;日志路径&lt;/p&gt;

&lt;p&gt;前面的章节中，我们学习了如何定义消息源、过滤器和消息目的。现在我们要把这些结合起来形成一条完整的指令。凡是来源于指定的消息源，匹配所有指定的过滤器，并送到指定的地址。其语法如下：&lt;/p&gt;

&lt;p&gt;log { source(s1); source(s2); &amp;hellip;
filter(f1); filter(f2); &amp;hellip;
destination(d1); destination(d2); &amp;hellip; };&lt;/p&gt;

&lt;p&gt;日志路径中的成员是顺序执行的。&lt;/p&gt;

&lt;p&gt;选项&lt;/p&gt;

&lt;p&gt;你可以通过设置一些选项来改变syslog-ng的行为。设置选项的语法一般是：
options { option1(params); option2(params); &amp;hellip; };&lt;/p&gt;

&lt;p&gt;每个选项也可以有自己的参数。&lt;/p&gt;

&lt;p&gt;以下是syslog-ng支持的参数：&lt;/p&gt;

&lt;p&gt;名字 参数类型 描述
time_reopen() 数字 一个断开的连接重新连接之前需要等待的时间
time_reap() 数字 一个闲置的目标文件关闭之前需要等待的时间
sync_freq() 数字 在写入文件之前，可以缓冲的日志消息行数
mark_freq() 数字 目前尚未实现
log_fifo_size() 数字 输出队列的行数
chain_hostnames() yes/no 打开/关闭主机名链(用于日志转发)
use_time_recvd() yes/no 使用收到日志消息的时间，不用日志消息中指定的时间
use_dns() yes/no 打开/关闭DNS查询功能。因为DNS查询无法返回会造成syslog-ng处于阻塞状态，从而造成拒绝服务攻击。为了避免这种情况的出现，应该使用防火墙严格保护使用syslog-ng的网络节点，并确认syslog-ng使用的所有主机都是可以解析的。
use_fqdn() yes/no 使用完整的域名
gc_idle_threshold() 数字 当syslog-ng空闲时，设置其进入垃圾信息收集状态的阀值。一旦分配的对象数达到了这个数字，syslog-ng就启动垃圾信息收集状态。默认值是1000。
gc_busy_threshold() 数字 当syslog-ng忙时，设置其进入垃圾信息收集状态的阀值。一旦分配的对象数达到这个数字，syslog-ng就启动垃圾信息收集状态。默认值是3000。&lt;/p&gt;

&lt;p&gt;3.参考&lt;/p&gt;

&lt;p&gt;本章，将详细介绍配置文件中使用的驱动器和选项。&lt;/p&gt;

&lt;p&gt;消息源驱动器&lt;/p&gt;

&lt;p&gt;internal()&lt;/p&gt;

&lt;p&gt;所有syslog-ng内部产生的日志消息都来自这个日志消息源。如果你需要syslog-ng自身山城的警告、错误和提醒信息，就需要在配置文件中加入以下声明：&lt;/p&gt;

&lt;p&gt;Declaration: internal()&lt;/p&gt;

&lt;p&gt;如果这个消息源驱动器没有被引用，syslog-ng会向你输出报警信息。&lt;/p&gt;

&lt;p&gt;例3-1.使用inernal()日志消息源驱动器&lt;/p&gt;

&lt;p&gt;source s_local { internal(); };&lt;/p&gt;

&lt;p&gt;unix-stream()和unix-dgram()&lt;/p&gt;

&lt;p&gt;这两个日志消息源驱动器比较相似，都打开AF_UNIX类型的套接字，在套接字上监听日志消息。unix-stream()主要用在Linux，使用 SOCK_STREAM参数，是面向连接的，不会造成日志消息的丢失；unix-dgram()用在BSD系统上，使用SOCK_DGRAM参数，是无连接的，如果系统过载，会造成日志消息丢失。&lt;/p&gt;

&lt;p&gt;在使用面向连接的协议时，为了避免造成拒绝服务攻击，需要对同时接受的连接数量进行闲置。这由max-connections()参数实现。&lt;/p&gt;

&lt;p&gt;Declaration:
unix-stream(filename [options]);
unix-dgram(filename [options]);&lt;/p&gt;

&lt;p&gt;以下选项可以用于unix-stream和unix-dgram日志消息源驱动器的声明：&lt;/p&gt;

&lt;p&gt;名字 参数数据类型 描述
owner() 字符串 设置套接字的uid，默认是：root
group() 字符串 设置套接字的gid，默认是：root
perm() 数字 设置权限掩码。八进制数字以0开头，例如：0755表示rwxr-xr-x。
keep-alive() yes/no 当syslog-ng重启动，选择是否保持连接，只用于unix-stream()。默认是yes
max-connections()数字 同时打开的连接的数目限制，只用于unix-stream()日志消息源驱动器。默认是10。&lt;/p&gt;

&lt;p&gt;例3-2.使用unix-stream()和unix-dgram()日志消息源驱动器&lt;/p&gt;

&lt;p&gt;source s_stream { unix-stream(&amp;ldquo;/dev/log&amp;rdquo; max-connections(10)); };
source s_dgram { unix-dgram(&amp;ldquo;/var/run/log&amp;rdquo;); };&lt;/p&gt;

&lt;p&gt;tcp()和udp()&lt;/p&gt;

&lt;p&gt;使用这两个日志消息源驱动器，你可以使用TCP或者UDP协议从网络上接受日志消息。&lt;/p&gt;

&lt;p&gt;UDP是一种简单的用户数据报协议，使用这种协议可能会发生日志消息的丢失，而且这种协议没有重传机制；TCP是一种面向连接的传输层协议，不会造成日志消息的丢失。&lt;/p&gt;

&lt;p&gt;这两种消息源驱动器都不需要位置参数。默认情况下，syslog-ng会绑定到0.0.0.0:514，在所有有效的端口上监听。可以使用localip()参数来限制其接受连接的端口。&lt;/p&gt;

&lt;p&gt;注意：514端口是rshell使用的端口，因此如果syslog-log和rshell同时使用，你需要为syslog-ng选择另外的端口。&lt;/p&gt;

&lt;p&gt;Declaration:
tcp([options]);
udp([options]);&lt;/p&gt;

&lt;p&gt;下面是udp()和tcp()可用的选项：&lt;/p&gt;

&lt;p&gt;选项名 数据类型 描述 默认值
ip或者iplocalip 字符串 绑定的IP地址 0.0.0.0&lt;/p&gt;

&lt;p&gt;udp()和tcp()使用示例：&lt;/p&gt;

&lt;p&gt;source s_tcp { tcp(ip(127.0.0.1) port(1999); max-connections(10); };
source s_udp { udp(); };&lt;/p&gt;

&lt;p&gt;file()&lt;/p&gt;

&lt;p&gt;通常，内核会把自己的消息送到一个特殊的文件(BSD系统是/dev/kmsg，Linux系统是/proc/kmsg)，因此你需要使用 file()日志消息源驱动器来指定这个文件。在Linux中，klogd会读取内核信息，并转发到syslogd进程，klogd在转发之前会对内核消息进行处理，使用/boot/System.map文件中的符号名代替原来的地址。如果你不需要这种功能，可以使用-x参数运行klogd。&lt;/p&gt;

&lt;p&gt;Declaration:
file(filename);&lt;/p&gt;

&lt;p&gt;file()日志消息源驱动器示例：&lt;/p&gt;

&lt;p&gt;source s_file { file(&amp;ldquo;/proc/kmsg&amp;rdquo;); };&lt;/p&gt;

&lt;p&gt;pipe()&lt;/p&gt;

&lt;p&gt;pipe日志消息源驱动器打开一个命名管道，在这个命名管道监听日志消息。在HP-UX系统中，它用于内部日志消息的获得。&lt;/p&gt;

&lt;p&gt;Declaration:
pipe(filename);&lt;/p&gt;

&lt;p&gt;注意首先你需要使用mkfifo建立命名管道。&lt;/p&gt;

&lt;p&gt;例3-6.使用pipe()日志消息源驱动器&lt;/p&gt;

&lt;p&gt;source s_pipe { pipe(&amp;ldquo;/dev/log&amp;rdquo;); );&lt;/p&gt;

&lt;p&gt;sun-streams()&lt;/p&gt;

&lt;p&gt;solaris使用STREAMS API把日志消息发送到syslogd进程。你必须在编译syslog-ng时加入这个特征。&lt;/p&gt;

&lt;p&gt;新版solaris(&amp;gt;=2.51)中，STREAMS使用一个新的IPC调用门来投递日志消息。syslog-ng支持这种IPC机制。&lt;/p&gt;

&lt;p&gt;日志消息目的驱动器&lt;/p&gt;

&lt;p&gt;日志目的驱动器把日志消息从syslog-ng输出到其它地方：一个文件或者一个网络套接字。&lt;/p&gt;

&lt;p&gt;file()&lt;/p&gt;

&lt;p&gt;file是syslog-ng最重要的日志消息目的驱动器之一。使用它，你可以把日志消息定向到一些文件中。&lt;/p&gt;

&lt;p&gt;在设置日志目的文件时，可以使用宏，从而使用一个简单的file日志消息目的驱动器就可以设置很多目的文件。和PHP/PERL一样，宏也是以$开头。&lt;/p&gt;

&lt;p&gt;如果文件所在的目录不存在，则由create_dirs()来决定是否创建这个目录。&lt;/p&gt;

&lt;p&gt;警告：由于syslog-ng必须跟踪建立的每个文件，因此会消耗一些内存。如果在60秒钟内(也可以由time_reap选项设置)没有新的消息到达某个文件，syslog-ng就会关闭这个文件，释放占用的资源。如果目的文件数和所需内存超出日志服务器的的能力，就会造成拒绝服务攻击。&lt;/p&gt;

&lt;p&gt;最危险的宏是$PROGRAM，因此在不可信的环境中不要使用这个宏。&lt;/p&gt;

&lt;p&gt;以下是可以用于扩展file的宏：&lt;/p&gt;

&lt;p&gt;HOST 日志消息的源发主机名。如果日志消息穿过几个主机，并且chain_hostname()功能已经打开，就使用第一个主机名。
FACILITY 日志消息来自的日志设备
PRIOPRITY/LEVEL 日志消息的优先级
PROGRAM 发送日志消息的程序
YEAR 发送日志消息的年份，这个宏既可以指定日志消息送出的时间，也可以指定日志消息收到的时间。这由use_time_recvd()选项控制
MONTH 发送日志消息的月份
DAY 发送日志消息的日子
HOUR 顾名思义，
MIN 同上
SEC 当然是秒了&lt;/p&gt;

&lt;p&gt;file()日志消息目的驱动器的选项：&lt;/p&gt;

&lt;p&gt;选项 数据类型 描述 默认值
log_file_size() 数字 输出文件的条目数 使用全局设定
sync_freq() 数字 当日志消息达到一定数目就写入文件 使用全局设定
encrypt() yes/no 给日志文件加密 使用全局设定
compress() yes/no 压缩日志文件 使用全局设定
owner() 字符串 指定日志文件的所有者 root
group() 字符串 指定日志文件所有者的组 root&lt;/p&gt;

&lt;p&gt;perm() 数字 建立时日志文件的权限掩码 0600
dir_per() 数字 建立目录时的权限掩码 0600
create_dirs() yes/no 如果目录不存在就建立 no&lt;/p&gt;

&lt;p&gt;pipe()&lt;/p&gt;

&lt;p&gt;syslog-ng通过pipe()日志消息目的驱动器把日志消息发送到/dev/xconsole之类的命名管道。&lt;/p&gt;

&lt;p&gt;unix-stream()和unix0dgram()&lt;/p&gt;

&lt;p&gt;syslog-ng通过这两个日志消息目的驱动器把日志消息发送到一个SOCK_STREAM或者SOCK_DGRAM模式的UNIX套接字。&lt;/p&gt;

&lt;p&gt;udp()和tcp()&lt;/p&gt;

&lt;p&gt;使用TCP或者UDP协议把日志消息送到本地网络上或者internet上的另外的主机。&lt;/p&gt;

&lt;p&gt;usertty()&lt;/p&gt;

&lt;p&gt;syslog-ng使用这个日志消息目的驱动器把日志消息送到一个登录用户使用的终端。&lt;/p&gt;

&lt;p&gt;program()&lt;/p&gt;

&lt;p&gt;program()驱动器fork出一个进程，使用给定的参数执行一个特定的程序，然后把日志消息送到这个进程的标准输入设备。&lt;/p&gt;

&lt;p&gt;4.优化syslog-ng&lt;/p&gt;

&lt;p&gt;syslog-ng的默认设置是针对单服务器或者工作站的，而对于一个网络的中央日志主机却远远不够。因此，需要对其进行一些调整和优化。&lt;/p&gt;

&lt;p&gt;设置垃圾收集参数&lt;/p&gt;

&lt;p&gt;syslog-ng有自己的垃圾收集器，而且一旦进入垃圾收集状态就不再接受日志消息。从而造成非连接的传输协议的信息丢失。因此，需要对syslog-ng的垃圾收集状态进行控制，你可以通过以下两个选项来控制其垃圾收集状态。&lt;/p&gt;

&lt;p&gt;gc_idle_threshold()&lt;/p&gt;

&lt;p&gt;这个选项能够设置垃圾收集器在syslog-ng处于空闲状态时的阀值。如果分配的的对象达到这个数字，而且系统处于空闲状态(100msec内没有日志消息到达)，syslog-ng就启动垃圾收集器。此时系统处于空闲状态，因此基本不会造成日志信息的丢失。这个值应该比较小，不过要大于已分配对象的最小值。已分配对象的最小值取决于你的配置，也可以通过-v命令行参数指定。&lt;/p&gt;

&lt;p&gt;gc_busy_threshold()&lt;/p&gt;

&lt;p&gt;如果syslog-ng正忙于接受日志消息(日志消息的间隔小于100msec)，为了防止其吃掉所有内存，也应该运行垃圾收集器。这个值应该比较高，以便在正常情况下不打断日志消息的接收。&lt;/p&gt;

&lt;p&gt;设置输出队列的大小&lt;/p&gt;

&lt;p&gt;为了防止发送日志的daemon程序阻塞，syslog-ng一直在读取其向内的日志通道。如果输出队列已满，就可能造成日志消息的丢失。因此，设置输出队列的大小非常重要，你可以设置全局输出队列的大小，也可以为每个日志消息驱动器设置输出队列的大小。&lt;/p&gt;

&lt;p&gt;options { log_fifo_size(1000); };&lt;/p&gt;

&lt;p&gt;或者&lt;/p&gt;

&lt;p&gt;destination d_dmessages { file(&amp;ldquo;/var/log/messages&amp;rdquo; log_fifo_size(1000); };&lt;/p&gt;

&lt;p&gt;输出队列的大小应该合理，这对于大量的日志消息涌来特别重要。如果蜂拥而至的日志信息占据了目标通道的所有带宽，syslog-ng能够把日志消息消息保存到输出队列中，等高峰过去再发出。&lt;/p&gt;

&lt;p&gt;当然，syslog-ng不能测试你的网络带宽，因此如果目的主机在一个噪音很大的网络上，而且日志流量超过网络带宽，syslog-ng也无能为力。&lt;/p&gt;

&lt;p&gt;设置同步(sync)参数&lt;/p&gt;

&lt;p&gt;syslog-ng一般先对日志消息进行缓存。当达到一定的数量，就写入磁盘。注意syslog-ng是对每条日志消息分别使用write()系统调用，而不是成匹写入。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>openssl建立SSL连接例子程序</title>
      <link>http://www.daniex.tk/blog/2011/examples-of-procedures-to-establish-ssl-connection-openssl/</link>
      <pubDate>Tue, 19 Apr 2011 11:15:46 &#43;0000</pubDate>
      <author>Daniex</author>
      <guid>http://www.daniex.tk/blog/2011/examples-of-procedures-to-establish-ssl-connection-openssl/</guid>
      <description>&lt;p&gt;下面是server 和client 的代码。用没跑过，但是用类似的代码跑了。流程是这样的。要注意的是openssl中ssl连接建立前用阻塞的socket，建立后可以设置非阻塞。openssl每个操作后最好检查下是否成功。
&lt;pre class=&#34;brush:php&#34;&gt;
/*********&lt;strong&gt;&lt;em&gt;server&lt;/em&gt;&lt;/strong&gt;*******************&lt;strong&gt;&lt;em&gt;/
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;winsock2.h&amp;gt;
#include &amp;lt;openssl/ssl.h&amp;gt;
#include &amp;lt;openssl/x509.h&amp;gt;
#include &amp;lt;openssl/rand.h&amp;gt;
#include &amp;lt;openssl/err.h&amp;gt;
&amp;nbsp;
#pragma comment (lib,&amp;ldquo;WS2_32.lib&amp;rdquo;)
#pragma comment( lib, &amp;ldquo;libeay32.lib&amp;rdquo; )
#pragma comment( lib, &amp;ldquo;ssleay32.lib&amp;rdquo; )
&amp;nbsp;
char buffer[10001] = {0};
&amp;nbsp;
int main()
{
SSL_library_init(); //初始化SSL库
OpenSSL_add_all_algorithms(); //支持所有算法
SSL_load_error_strings();  //提供将错误号解析为字符串的功能
SSL *ssl = NULL;
SSL_CTX *ssl_ctx = NULL;
SSL_METHOD *ssl_method = NULL;
X509 *client_cert = NULL;
//设置客户端使用的SSL版本
//ssl_method = SSLv3_server_method();
ssl_method = SSLv23_server_method();
//创建SSL上下文环境 每个进程只需维护一个SSL_CTX结构体
ssl_ctx = SSL_CTX_new(ssl_method);
&amp;nbsp;
//验证对方
SSL_CTX_set_verify(ssl_ctx,SSL_VERIFY_PEER,NULL);
&amp;nbsp;
//若验证,则放置CA证书
SSL_CTX_load_verify_locations(ssl_ctx, &amp;ldquo;cacert.pem&amp;rdquo;, NULL);
&amp;nbsp;
//设置pass phrase
SSL_CTX_set_default_passwd_cb_userdata(ssl_ctx, &amp;ldquo;pass phrase&amp;rdquo;);
//读取证书文件
SSL_CTX_use_certificate_file(ssl_ctx,&amp;rdquo;&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;Cert.pem&amp;rdquo;,SSL_FILETYPE_PEM);
&amp;nbsp;
//读取密钥文件
SSL_CTX_use_PrivateKey_file(ssl_ctx,&amp;rdquo;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;Key.pem&amp;rdquo;,SSL_FILETYPE_PEM);
&amp;nbsp;
//验证密钥是否与证书一致
SSL_CTX_check_private_key(ssl_ctx);
&amp;nbsp;
/*构建随机数生成机制,WIN32平台必需&lt;/em&gt;/
srand( (unsigned)time( NULL ) );
for( int i = 0;    i &amp;lt; 100;i++ )
seed_int[i] = rand();
RAND_seed(seed_int, sizeof(seed_int));
//设置加密方式
//SSL_CTX_set_cipher_list(ssl_ctx,&amp;ldquo;RC4-MD5&amp;rdquo;);
//建立TCP服务器端、开始监听并接受客户端连接请求
&amp;nbsp;
// 初始化 Winsock.
WSADATA wsaData;
int iResult = WSAStartup( MAKEWORD(2,2), &amp;amp;wsaData );
if ( iResult != NO_ERROR )
{
//失败
return -1;
}
// 建立socket
server = socket( AF_INET, SOCK_STREAM, IPPROTO_TCP );
if ( server == INVALID_SOCKET )
{
//失败
WSACleanup();
return -2;
}
&amp;nbsp;
// 绑定socket
sockaddr_in service;
service.sin_family = AF_INET;
//service.sin_addr.s_addr = inet_addr(&amp;ldquo;127.0.0.1&amp;rdquo;);
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons( 8899 );
&amp;nbsp;
if ( bind( server, (SOCKADDR*) &amp;amp;service, sizeof(service) ) == SOCKET_ERROR )
{
//失败
closesocket(server);
return -3;
}
&amp;nbsp;
// 监听 socket
if ( listen( server, 10 ) == SOCKET_ERROR )
{
//失败
return -4;
}
&amp;nbsp;
do
{
sClient = accept(server,NULL,NULL);
Sleep(100);
}while(sClient == INVALID_SOCKET);
&amp;nbsp;
//创建当前连接的SSL结构体
ssl = SSL_new(ssl_ctx);
//将SSL绑定到套接字上
SSL_set_fd(ssl, sClient);
&amp;nbsp;
//接受SSL链接
SSL_accept(ssl);
&amp;nbsp;
//获取和释放客户端证书
client_cert = SSL_get_peer_certificate(ssl);
//打印所有加密算法的信息(可选)
std::cout&amp;lt;&amp;lt;&amp;ldquo;SSL connection using&amp;rdquo;&amp;lt;&amp;lt;SSL_get_cipher(ssl)&amp;lt;&amp;lt;std::endl;
&amp;nbsp;
X509_free(client_cert);
&amp;nbsp;
//unsigned long cmd;
//if (SOCKET_ERROR == ioctlsocket(sClient, FIONBIO, &amp;amp;cmd))
//{
//创建套接字时发生错误，非阻塞设置失败
//ErrorProcess();
//closesocket(sClient);
//}
&amp;nbsp;
while(true)
{
SSL_read(ssl, buffer, 10000);
memset(buffer,0,10000);
SSL_write(ssl, &amp;ldquo;hello, world!&amp;rdquo;, sizeof(&amp;ldquo;hello, world!&amp;rdquo;));
Sleep(1000);
&amp;nbsp;
}
&amp;nbsp;
//断开SSL链接
SSL_shutdown(ssl);
//释放当前SSL链接结构体
SSL_free(ssl);
//断开TCP链接
closesocket(sClient);
//释放SSL上下文
SSL_CTX_free(ssl_ctx);
&amp;nbsp;
return 0;
}
&lt;/pre&gt;
&lt;pre class=&#34;brush:php&#34;&gt;
/&lt;/strong&gt;*********&lt;strong&gt;&lt;em&gt;client&lt;/em&gt;&lt;/strong&gt;***************&lt;strong&gt;&lt;em&gt;/
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;winsock2.h&amp;gt;
#include &amp;lt;openssl/ssl.h&amp;gt;
#include &amp;lt;openssl/x509.h&amp;gt;
#include &amp;lt;openssl/rand.h&amp;gt;
#include &amp;lt;openssl/err.h&amp;gt;
#pragma comment (lib,&amp;ldquo;WS2_32.lib&amp;rdquo;)
#pragma comment( lib, &amp;ldquo;libeay32.lib&amp;rdquo; )
#pragma comment( lib, &amp;ldquo;ssleay32.lib&amp;rdquo; )
&amp;nbsp;
int main(int argc, _TCHAR&lt;/em&gt; argv[])
{
&amp;nbsp;
SOCKET client;
char buffer[256] = {0};
int  seed_int[100]; /&lt;em&gt;存放随机序列&lt;/em&gt;/
&amp;nbsp;
SSL &lt;em&gt;ssl = NULL;
SSL_CTX *ssl_ctx = NULL;
SSL_METHOD *ssl_method = NULL;
X509 *server_cert = NULL;
&amp;nbsp;
SSL_library_init();        //init libraries
OpenSSL_add_all_algorithms(); //支持所有算法
SSL_load_error_strings();  //提供将错误号解析为字符串的功能
&amp;nbsp;
&amp;nbsp;
//设置客户端使用的SSL版本
ssl_method = SSLv3_client_method();
//创建SSL上下文环境 每个进程只需维护一个SSL_CTX结构体
ssl_ctx = SSL_CTX_new(ssl_method);
/*构建随机数生成机制,WIN32平台必需&lt;/em&gt;/
srand( (unsigned)time( NULL ) );
for( int i = 0;    i &amp;lt; 100;i++ )
seed_int[i] = rand();
RAND_seed(seed_int, sizeof(seed_int));
&amp;nbsp;
&amp;nbsp;
/* Load the RSA CA certificate into the SSL_CTX structure &lt;em&gt;/
/&lt;/em&gt; This will allow this client to verify the server&amp;rsquo;s   &lt;em&gt;/
/&lt;/em&gt; certificate.                             &lt;em&gt;/
SSL_CTX_load_verify_locations(ssl_ctx, &amp;ldquo;cacert.pem&amp;rdquo;, NULL);
&amp;nbsp;
/&lt;/em&gt; Set flag in context to require peer (server) certificate verification */
SSL_CTX_set_verify(ssl_ctx,SSL_VERIFY_PEER,NULL);
SSL_CTX_set_verify_depth(ssl_ctx,1);
SSL_CTX_set_default_passwd_cb_userdata(ssl_ctx, &amp;ldquo;pass phrase&amp;rdquo;);
//读取证书文件
SSL_CTX_use_certificate_file(ssl_ctx,&amp;rdquo;&lt;/strong&gt;*&lt;strong&gt;&lt;em&gt;Cert.pem&amp;rdquo;,SSL_FILETYPE_PEM);
//读取密钥文件
SSL_CTX_use_PrivateKey_file(ssl_ctx,&amp;rdquo;&lt;/em&gt;&lt;/strong&gt;**&lt;em&gt;Key.pem&amp;rdquo;,SSL_FILETYPE_PEM);
//验证密钥是否与证书一致
SSL_CTX_check_private_key(ssl_ctx);
&amp;nbsp;
&amp;nbsp;
//建立TCP链接
// 初始化 Winsock.
WSADATA wsaData;
int iResult = WSAStartup( MAKEWORD(2,2), &amp;amp;wsaData );
if ( iResult != NO_ERROR )
{
//AfxMessageBox(&amp;ldquo;Error at WSAStartup()!&amp;rdquo;);
return;
}
&amp;nbsp;
// 建立socket socket.
client = socket( AF_INET, SOCK_STREAM, IPPROTO_TCP );
if ( client == INVALID_SOCKET )
{
//AfxMessageBox(&amp;ldquo;Error at socket!&amp;rdquo;);
WSACleanup();
return;
}
&amp;nbsp;
// 连接到服务器.
sockaddr_in clientService;
clientService.sin_family = AF_INET;
clientService.sin_addr.s_addr = inet_addr( &amp;ldquo;127.0.0.1&amp;rdquo; );
clientService.sin_port = htons( 8899 );
if ( connect( client, (SOCKADDR&lt;/em&gt;) &amp;amp;clientService, sizeof(clientService) ) == SOCKET_ERROR)
{
//AfxMessageBox( &amp;ldquo;Failed to connect!&amp;rdquo; );
WSACleanup();
return;
}
&amp;nbsp;
//unsigned long cmd;
//if (SOCKET_ERROR == ioctlsocket(client, FIONBIO, &amp;amp;cmd))
//{
//  //AfxMessageBox( &amp;ldquo;创建套接字时发生错误，非阻塞设置失败：&amp;rdquo;);
//  closesocket(client);
//}
//创建维护当前连接信息的SSL结构体
ssl = SSL_new(ssl_ctx);
//将SSL绑定到套接字上
SSL_set_fd(ssl, client);
//建立SSL链接
SSL_connect(ssl);
&amp;nbsp;
//获取服务器端证书
server_cert = SSL_get_peer_certificate(ssl);
&amp;nbsp;
//释放服务器端证书
X509_free(server_cert);
&amp;nbsp;
unsigned long cmd;
if (SOCKET_ERROR == ioctlsocket(client, FIONBIO, &amp;amp;cmd))
{
//AfxMessageBox( &amp;ldquo;创建套接字时发生错误，非阻塞设置失败：&amp;rdquo;);
closesocket(client);
}
while(true)
{
SSL_write(ssl, &amp;ldquo;hello, world!&amp;rdquo;, sizeof(&amp;ldquo;hello, world!&amp;rdquo;)；
SSL_read(ssl, buffer, 255);
printf(&amp;ldquo;received: %s\n&amp;rdquo;,buffer);
memset(buffer,0,255);
&amp;nbsp;
Sleep(1000);
}
//断开SSL链接
SSL_shutdown(ssl);
//释放当前SSL链接结构体
SSL_free(ssl);
closesocket(client);
//释放上下文
SSL_CTX_free(ssl_ctx);
&amp;nbsp;
return 0;
}
&amp;nbsp;
&lt;/pre&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>用openssl命令制作生成证书和自签名</title>
      <link>http://www.daniex.tk/blog/2011/generated-with-the-openssl-command-to-create-self-signed-certificates-and/</link>
      <pubDate>Sat, 16 Apr 2011 10:04:41 &#43;0000</pubDate>
      <author>Daniex</author>
      <guid>http://www.daniex.tk/blog/2011/generated-with-the-openssl-command-to-create-self-signed-certificates-and/</guid>
      <description>&lt;p&gt;前文描述了如何在window下按安装openssl后，这里说下如何利用openssl生成证书。&lt;/p&gt;

&lt;p&gt;1、  新建工作目录，将openssl安装路径下的apps/CA.pl 和 apps/openssl.cnf（在window中该文件会显示成名为openssl的快速拨号程序）文件复制到该路径。可以修改openssl.cnf文件中的一些参数。启动控制台，执行命令
CA.pl -newca
生成CA工作所需的文件和文件夹。即该目录下新生成的demoCA文件夹。将openssl安装路径下的apps\demoCA\serial文件复制到生成的demoCA文件夹下。&lt;/p&gt;

&lt;p&gt;可以略去该步骤，在安装路径\apps下执行后续步骤。&lt;/p&gt;

&lt;p&gt;2、  生成根证书和对应的私钥
openssl req -new -x509 -keyout cakey.pem -out cacert.pem -config openssl.cnf
记住输入的pass phrase、国家、省、组织等参数，不能全为空。将生成的cakey.pem放到demoCA/private目录下，将cacert.pem放到demoCA目录下。
注意：在window下需要openssl命令都需要增加-config openssl.cnf参数，防止因找不到配置文件而报错。Linux下不需要该参数。
&lt;img alt=&#34;&#34; src=&#34;http://farm6.static.flickr.com/5189/5620697845_30c20ca29e.jpg&#34; title=&#34;生成证书&#34; class=&#34;aligncenter&#34; width=&#34;500&#34; height=&#34;483&#34; /&gt;&lt;/p&gt;

&lt;p&gt;3、  生成服务证书私钥和证书请求文件
openssl req -newkey rsa:2048 -out newCSR.pem -keyout newKey.pem -config openssl.cnf
如果要生成多个证书私钥对，注意输入Common Name值要不同。如果不是自签名，可将生成的证书请求文件newCSR.pem交由相关组织签发证书。&lt;/p&gt;

&lt;p&gt;4、  用根证书签发该服务证书
openssl ca -in newCSR.pem -out newCert.pem -config openssl.cnf
&lt;img alt=&#34;&#34; src=&#34;http://farm6.static.flickr.com/5189/5620697845_30c20ca29e.jpg&#34; title=&#34;签名&#34; class=&#34;aligncenter&#34; width=&#34;500&#34; height=&#34;483&#34; /&gt;&lt;/p&gt;

&lt;p&gt;至此，我们生成了根证书和私钥cakey.pem、cacert.pem。用于服务由根证书签发了的证书newCert.pem和对应私钥newKey.pem。openssl编程过程中，需要验证newCert.pem和newKey.pem是否匹配。用根证书cacert.pem验证newCert.pem是否可信。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Windows下安装OpenSSL</title>
      <link>http://www.daniex.tk/blog/2011/windows-install-openssl/</link>
      <pubDate>Mon, 28 Mar 2011 03:25:40 &#43;0000</pubDate>
      <author>Daniex</author>
      <guid>http://www.daniex.tk/blog/2011/windows-install-openssl/</guid>
      <description>&lt;p&gt;环境：window xp； OpenSSL：0.9.8k；IDE：MS Visual Studio 2008&lt;/p&gt;

&lt;p&gt;解压OpenSSL， 在其目录下可以有个INSTALL.W32文件，这个文件就是在windows下的安装说明。用UltraEdit等工具打开它查看安装编译方法。&lt;/p&gt;

&lt;p&gt;安装前需要准备的是VS环境和perl环境。vs安装就不说了。perl可以到&lt;a href=&#34;http://www.activestate.com/ActivePerl&#34;&gt;http://www.activestate.com/ActivePerl&lt;/a&gt; 去下载安装。注意加入环境变量。&lt;/p&gt;

&lt;p&gt;再之后就可以安装了，使用vs提供的控制台安装。否则安装过程中会报出&amp;rdquo;ml&amp;rdquo;不是内部或外部命令之类的提示。&lt;/p&gt;

&lt;p&gt;&lt;a title=&#34;Flickr 上 Daniex Jiang 的 cl&#34; href=&#34;http://www.flickr.com/photos/daniex/5566069829/&#34;&gt;&lt;img src=&#34;http://farm6.static.flickr.com/5189/5566069829_862458b6e8_z.jpg&#34; alt=&#34;cl&#34; width=&#34;640&#34; height=&#34;105&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;打开控制台口依次：&lt;/p&gt;

&lt;p&gt;1.输入：perl Configure VC-WIN32&lt;/p&gt;

&lt;p&gt;2.使用MASM，输入：ms\do_masm&lt;/p&gt;

&lt;p&gt;3.接着输入：nmake -f ms\ntdll.mak 安装&lt;/p&gt;

&lt;p&gt;4.输入：nmake -f ms\ntdll.mak test 测试安装是否成功。&lt;/p&gt;

&lt;p&gt;最后会显示 all tests passed提示。编译就通过了，在out32dll目录下面就可以看到生成的dll文件和可执行文件。&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>谷歌地图多个标记（marker）和信息窗口（information window）显示</title>
      <link>http://www.daniex.tk/blog/2010/marker-information-window/</link>
      <pubDate>Wed, 16 Jun 2010 16:21:00 &#43;0000</pubDate>
      <author>Daniex</author>
      <guid>http://www.daniex.tk/blog/2010/marker-information-window/</guid>
      <description>&lt;p&gt;当谷歌地图上有多个标记（marker）和信息窗口（information window）需要显示的时候，使用基本的增加监听click的事件响应的方法，信息窗口的显示会出现问题。即在任意标记上点击，需要显示信息窗口时，窗口会固定的显示在最后画上的标记上面。&lt;/p&gt;

&lt;p&gt;添加click事件监听方法的代码：
&lt;div id=&#34;_mcePaste&#34;&gt;GEvent.addListener(marker, &amp;ldquo;click&amp;rdquo;, function() {&lt;/div&gt;
&lt;div id=&#34;_mcePaste&#34;&gt;marker.openInfoWindowHtml(&amp;rsquo;&amp;lt;b&amp;gt;info:&amp;lt;/b&amp;gt; &amp;lsquo;+ info);&lt;/div&gt;
&lt;div id=&#34;_mcePaste&#34;&gt;});&lt;/div&gt;
&lt;div id=&#34;_mcePaste&#34;&gt;map.addOverlay(marker);&lt;/div&gt;
查阅网上资料后，发现一个解决方案，即使用&lt;span style=&#34;font-family: &#39;Andale Mono&#39;, &#39;Lucida Console&#39;, Monaco, fixed, monospace; line-height: 18px; font-size: 12px; white-space: pre;&#34;&gt;bindInfoWindowHtml方法。&lt;span style=&#34;font-family: Georgia, &#39;Times New Roman&#39;, &#39;Bitstream Charter&#39;, Times, serif; line-height: 19px; white-space: normal; font-size: 13px;&#34;&gt;以上的信息显示只需修改一小部分即可：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;marker = new GMarker(point);&lt;/p&gt;

&lt;p&gt;marker.bindInfoWindowHtml(&amp;rsquo;&amp;lt;b&amp;gt;info:&amp;lt;/b&amp;gt; &amp;lsquo;+info)&lt;/p&gt;

&lt;p&gt;map.addOverlay(marker);&lt;/p&gt;

&lt;p&gt;&lt;span style=&#34;font-family: &#39;Andale Mono&#39;, &#39;Lucida Console&#39;, Monaco, fixed, monospace; line-height: 18px; font-size: 12px; white-space: pre;&#34;&gt;在两个网址有很详细的代码示例：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&#34;font-family: &#39;Andale Mono&#39;, &#39;Lucida Console&#39;, Monaco, fixed, monospace; line-height: 18px; font-size: 12px; white-space: pre;&#34;&gt;&lt;a href=&#34;http://www.cnblogs.com/yuzhongwusan/archive/2009/01/09/1372275.html&#34; target=&#34;_blank&#34;&gt;雨中无伞&lt;/a&gt; 和 &lt;a href=&#34;http://www.ibm.com/developerworks/cn/web/0910_chengfu_mashup/&#34; target=&#34;_blank&#34;&gt;IBM&lt;/a&gt;&lt;span style=&#34;font-family: verdana, nsimsun, sans-serif; line-height: 19px; white-space: normal;&#34;&gt;&lt;a href=&#34;http://www.ibm.com/developerworks/cn/web/0910_chengfu_mashup/&#34; target=&#34;_blank&#34;&gt;使用开放 API 和工具快速开发情景式 mashup 应用&lt;/a&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&#34;font-family: verdana, nsimsun, sans-serif; font-size: small;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>