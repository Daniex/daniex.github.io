<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>C on Daniex </title>
      <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>http://www.daniex.tk/tags/c/index.xml/</link>
    <language>zh-cn</language>
    <author>Daniex</author>
    
    <updated>Sat, 19 Nov 2011 09:33:37 &#43;0000</updated>
    
    <item>
      <title>wordpress自定义个性化首页</title>
      <link>http://www.daniex.tk/blog/2011/wordpress-custom-home-page/</link>
      <pubDate>Sat, 19 Nov 2011 09:33:37 &#43;0000</pubDate>
      <author>Daniex</author>
      <guid>http://www.daniex.tk/blog/2011/wordpress-custom-home-page/</guid>
      <description>&lt;p&gt;自己好不容易折腾了个wordpress博客，发现所有人的首页样式都大同小异，是不是很没创意，很扫兴？下面就来说说如何制作一个wordpress个性化首页，让你随心所欲的改变首页的样式，让你有个不一样的主页。最后效果如我的&lt;a title=&#34;澄清的半亩方糖&#34; href=&#34;http://danie.info&#34; target=&#34;_blank&#34;&gt;&lt;strong&gt;首页&lt;/strong&gt;&lt;/a&gt;，截图如下：
&lt;p style=&#34;text-align: center;&#34;&gt;&lt;img class=&#34;aligncenter size-full wp-image-974&#34; title=&#34;ss&#34; src=&#34;http://daniex.info/wp-content/uploads/2011/11/ss.jpg&#34; alt=&#34;&#34; width=&#34;590&#34; height=&#34;482&#34; /&gt;&lt;/p&gt;
&amp;nbsp;
&lt;div style=&#34;background-color: #e3e3e3;&#34;&gt;
&lt;h2&gt;一、 设置wordpress首页&lt;/h2&gt;
&lt;/div&gt;
wordpress有设置page页作为默认首页的功能，下面的方法就是自定义一个page也模板，然后添加一个用这个模板制作的page页，最后将这个page页设为首页。&lt;/p&gt;

&lt;p&gt;1) ftp或者cpanel到部署wordpress空间或其他。复制wordpress主题目录下的page.php文件，重名名。比如，找到文件（wp目录）/wp-content/themes/zbench/page.php 重命名为 myhomepage.php&lt;/p&gt;

&lt;p&gt;2) 用文本编辑器打开myhomepage.php，例如用记事本打开，在文件首位添加以下代码：
&lt;blockquote&gt;&amp;lt;?php
/*
Template Name: 首页
*/
?&amp;gt;&lt;/blockquote&gt;
“Template Name : ” 后的文字可以是任意的。这样我们就添加了一个新的page页模板。自定义的首页内容其实就是这个myhomepage.php的内容。如何设计修改这个文件，建立自己的个性化首页，会在后面提到。我们先将它设为首页。&lt;/p&gt;

&lt;p&gt;3) 添加一个新的page页：浏览器登录wordpress后台控制面板，dashboard -&amp;gt;pages -&amp;gt; add new。 输入标题，在右方page attributes 面板中会有parent 和 template 的下拉框，在模板下拉框中选择刚刚添加的模板。如图，我添加的模板名字叫“首页”，我就选择它。&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-full wp-image-961&#34; title=&#34;selecttemplate&#34; src=&#34;http://daniex.info/wp-content/uploads/2011/11/selecttemplate.jpg&#34; alt=&#34;&#34; width=&#34;281&#34; height=&#34;253&#34; /&gt;选择好后，给这个page也命名，我是在title那输入的“首页”。然后就可以发表了，其他的内容什么可以都不用写。&lt;/p&gt;

&lt;p&gt;4) 设置首页的最后一步，点击后台的reading设置项：dashboard -&amp;gt; settings -&amp;gt; reading。在第一个设置项目里选择第二项 a static page ，然后再它下方的第一个下拉选项框里选则刚刚给page页设置的名字。比如我的“首页”。&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-full wp-image-962&#34; title=&#34;setreading&#34; src=&#34;http://daniex.info/wp-content/uploads/2011/11/setreading.png&#34; alt=&#34;&#34; width=&#34;552&#34; height=&#34;506&#34; /&gt;点击 save changes 保存配置。&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;这样，我们把首页重新设置好了。这个时候访问首页的时候我们会发现，我们的首页除了头上的标题名称、侧边栏、底部栏之外就什么都没有。&lt;/p&gt;

&lt;p&gt;&amp;nbsp;
&lt;div style=&#34;background-color: #e3e3e3;&#34;&gt;
&lt;h2&gt;二、 设计自己的wordpress首页&lt;/h2&gt;
&lt;/div&gt;
我们已经把wordpress的首页换掉，但是这个首页现在是一片空白，我们要怎么去填充这片空白呢？如果你有html、css、js功底，那就是你一展身手的时候。如果水平一般，那也没关系，能看懂一点点代码，那就有办法去使用一些好的模板，好的插件，设计出一个自己满意的首页还是可以的。我就只是能看懂代码的那种，根本不熟悉网页前端开发。
&lt;h4&gt;&lt;strong&gt;方法一&lt;/strong&gt;&lt;/h4&gt;
怎么给这个首页填充内容，最简单的方法就是，编辑我们之前添加的page页。之前我们并没有在文章内容里添加任何东西。只要你有好内容，好方案，就可以像写一个新的文章一样这里出一个你自己的主页。
&lt;h4&gt;&lt;strong&gt;方法二&lt;/strong&gt;&lt;/h4&gt;
这个方法就需要去修改我们的myhomepage.php文件。前端开发的牛人大有人在，我也不多说。就把我的一些代码贴出来，有心思看到朋友可以参考下。主要用到的几个函数我罗列一下：
&lt;blockquote&gt;&amp;lt;?php if(function_exists(&amp;lsquo;wp_thumbnails_for_category&amp;rsquo;)) { wp_thumbnails_for_category(&amp;lsquo;id=7&amp;amp;num=1&amp;rsquo;); } ?&amp;gt;&lt;/blockquote&gt;
这是我使用的wp-thumbnail插件提供的函数，用于显示分类中的文章和缩略图。在wp-thumbnail插件设置中设置好分类文章的相关数据，如图片大小、标题位置。然后再这里调用。id=7表示文章分类id为7的分类下的文章，num=1表示显示一篇。文章分类ID是几可以参考&lt;a title=&#34;wordpress查看分类category的id&#34; href=&#34;http://daniex.info/view-category-id-wordpress.html&#34; target=&#34;_blank&#34;&gt;&lt;strong&gt;这篇文章&lt;/strong&gt;&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;嵌入的探讨tt1 tt2 的css代码是控制左侧栏目的背景。另外有block1和block2的代码是用来控制左右两部分的布局。
&lt;blockquote&gt;.tt1 {background:#E3E3E3;width:270px;height350px}
.tt2 {background:#E3E3E3;width:210px;height310px;margin:30px}&lt;/p&gt;

&lt;p&gt;.block2 { float:left; width:250px; height:700px}
.block3 { float:right; width:350px; height:700px}&lt;/blockquote&gt;
中间栏的随机文章和标题评论控制是用这些函数：
&lt;blockquote&gt;$args = array( &amp;lsquo;numberposts&amp;rsquo; =&amp;gt; 5, &amp;lsquo;orderby&amp;rsquo; =&amp;gt; &amp;lsquo;rand&amp;rsquo;, &amp;lsquo;category&amp;rsquo; =&amp;gt; 7 );
$rand_posts = get_posts( $args );
foreach( $rand_posts as $post ) : setup_postdata($post); ?&amp;gt;&lt;/p&gt;

&lt;p&gt;。。。&lt;/blockquote&gt;
&amp;nbsp;
&lt;blockquote&gt;&amp;lt;?php if(function_exists(&amp;lsquo;the_views&amp;rsquo;)) { echo &amp;ldquo; | &amp;ldquo;;the_views(); } ?&amp;gt;&lt;/blockquote&gt;
这段代码是用了postviews+的插件，用于统计文章浏览次数。&lt;/p&gt;

&lt;p&gt;更多代码：
&lt;blockquote&gt;&amp;lt;?php
/*
Template Name: 首页
*/
?&amp;gt;
&amp;lt;?php get_header() ?&amp;gt;
&amp;lt;div id=&amp;ldquo;content&amp;rdquo;&amp;gt;
&amp;lt;?php the_post(); ?&amp;gt;
&amp;lt;div &amp;lt;?php post_class(&amp;lsquo;post post-page&amp;rsquo;); ?&amp;gt; id=&amp;ldquo;post-&amp;lt;?php the_ID(); ?&amp;gt;&amp;ldquo;&amp;gt;
&amp;lt;div class=&amp;ldquo;block2&amp;rdquo;&amp;gt;
&amp;lt;h2&amp;gt;&amp;lt;a href=&amp;ldquo;&lt;a href=&#34;http://daniex.info/category/coding&amp;quot;&amp;gt;编程开发&amp;lt;/a&amp;gt;&amp;lt;/h2&amp;gt;&amp;lt;span&amp;gt;C/C++&#34;&gt;http://daniex.info/category/coding&amp;quot;&amp;gt;编程开发&amp;lt;/a&amp;gt;&amp;lt;/h2&amp;gt;&amp;lt;span&amp;gt;C/C++&lt;/a&gt; java C# wpf php&amp;hellip;&amp;lt;/span&amp;gt;
&amp;lt;div class=&amp;ldquo;tt1&amp;rdquo;&amp;gt;
&amp;lt;div class=&amp;ldquo;tt2&amp;rdquo;&amp;gt;
&amp;lt;?php if(function_exists(&amp;lsquo;wp_thumbnails_for_category&amp;rsquo;)) { wp_thumbnails_for_category(&amp;lsquo;id=7&amp;amp;num=1&amp;rsquo;); } ?&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div class=&amp;ldquo;tt1&amp;rdquo;&amp;gt;
&amp;lt;div class=&amp;ldquo;tt2&amp;rdquo;&amp;gt;
&amp;lt;?php if(function_exists(&amp;lsquo;wp_thumbnails_for_category&amp;rsquo;)) { wp_thumbnails_for_category(&amp;lsquo;id=7&amp;amp;num=1&amp;amp;order=recent&amp;rsquo;); } ?&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;style&amp;gt;
.tt1 {background:#E3E3E3;width:270px;height350px}
.tt2 {background:#E3E3E3;width:210px;height310px;margin:30px}
&amp;lt;/style&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div class=&amp;ldquo;block3&amp;rdquo;&amp;gt;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;?php
$args = array( &amp;lsquo;numberposts&amp;rsquo; =&amp;gt; 5, &amp;lsquo;orderby&amp;rsquo; =&amp;gt; &amp;lsquo;rand&amp;rsquo;, &amp;lsquo;category&amp;rsquo; =&amp;gt; 7 );
$rand_posts = get_posts( $args );
foreach( $rand_posts as $post ) : setup_postdata($post); ?&amp;gt;
&amp;lt;h3&amp;gt;&amp;lt;a href=&amp;rdquo;&amp;lt;?php the_permalink(); ?&amp;gt;&amp;ldquo;&amp;gt;&amp;lt;?php the_title(); ?&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/h3&amp;gt;
&amp;lt;?php if (&amp;lsquo;open&amp;rsquo; == $post-&amp;gt;comment_status) { ?&amp;gt;
&amp;lt;div&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;span&amp;gt;&amp;lt;?php the_time(get_option( &amp;lsquo;date_format&amp;rsquo; )); ?&amp;gt;&amp;lt;/span&amp;gt;
&amp;lt;span id=&amp;ldquo;gotocomments&amp;rdquo;&amp;gt;&amp;lt;?php comments_popup_link(&lt;strong&gt;(&amp;lsquo;0 评论&amp;rsquo;, &amp;lsquo;zbench&amp;rsquo;), __(&amp;lsquo;1 评论&amp;rsquo;, &amp;lsquo;zbench&amp;rsquo;), &amp;lsquo;% &amp;lsquo;.&lt;/strong&gt;(&amp;rsquo; 评论&amp;rsquo;, &amp;lsquo;zbench&amp;rsquo;)); ?&amp;gt;&amp;lt;?php if(function_exists(&amp;lsquo;the_views&amp;rsquo;)) { echo &amp;ldquo; | &amp;ldquo;;the_views(); } ?&amp;gt;&amp;lt;/span&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;!&amp;ndash;&amp;lt;div&amp;gt;
&amp;lt;?php if ( $options[&amp;lsquo;excerpt_check&amp;rsquo;]==&amp;lsquo;true&amp;rsquo; ) { the_excerpt(&lt;strong&gt;(&amp;rsquo;&amp;amp;raquo; Read more&amp;hellip;&amp;lsquo;,&amp;lsquo;zbench&amp;rsquo;)); } else { the_content(&lt;/strong&gt;(&amp;rsquo;&amp;amp;raquo; Read more&amp;hellip;&amp;lsquo;,&amp;lsquo;zbench&amp;rsquo;)); } ?&amp;gt;
&amp;lt;/div&amp;gt; END entry &amp;ndash;&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;?php if(is_sticky()) { ?&amp;gt;
&amp;lt;div&amp;gt;&amp;lt;p&amp;gt;&amp;lt;?php _e(&amp;lsquo;This is a sticky post!&amp;rsquo;, &amp;lsquo;zbench&amp;rsquo;); ?&amp;gt; &amp;lt;a href=&amp;rdquo;&amp;lt;?php the_permalink() ?&amp;gt;&amp;ldquo;&amp;gt;&amp;lt;?php _e(&amp;lsquo;continue reading?&amp;rsquo;, &amp;lsquo;zbench&amp;rsquo;); ?&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;?php } ?&amp;gt;
&amp;lt;?php } else { ?&amp;gt;
&amp;lt;div style=&amp;ldquo;height:1px;&amp;rdquo;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;?php } ?&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;?php echo mb_strimwidth(strip_tags(apply_filters(‘the_content’, $post-&amp;gt;post_content)), 0, 100,&amp;ldquo;&amp;hellip;&amp;rdquo;); ?&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;
&amp;lt;?php endforeach; ?&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;/div&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;/div&amp;gt;&amp;lt;!&amp;ndash; END post &amp;ndash;&amp;gt;
&amp;lt;/div&amp;gt;&amp;lt;!&amp;ndash;content&amp;ndash;&amp;gt;
&amp;lt;?php get_sidebar() ?&amp;gt;
&amp;lt;?php get_footer() ?&amp;gt;&lt;/blockquote&gt;
&amp;nbsp;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>wpf toolkit datagrid 添加图片</title>
      <link>http://www.daniex.tk/blog/2011/wpf-toolkit-datagrid-add-a-picture/</link>
      <pubDate>Sat, 22 Oct 2011 03:43:32 &#43;0000</pubDate>
      <author>Daniex</author>
      <guid>http://www.daniex.tk/blog/2011/wpf-toolkit-datagrid-add-a-picture/</guid>
      <description>&lt;p&gt;&lt;del&gt;找了半天，不幸地发现，wpf toolkit datagrid 要添加图片列，没有普遍的方法。除非加另外的库或者写很复杂的代码。&lt;/del&gt;
&lt;h2&gt;&lt;span style=&#34;color: #0000ff;&#34;&gt;该句删除，因为，下午刚发现这是有办法的！！！&lt;/span&gt;&lt;/h2&gt;
网上大多加图片的例子都是基于.net 4.0自带的datagrid控件，不要折腾wpf toolkit了，直接升4.0或者更高吧。。。&lt;/p&gt;

&lt;p&gt;列几个参考地址：&lt;a href=&#34;http://www.cnblogs.com/wainiwann/archive/2011/05/27/WPF_DataGrid.html&#34; target=&#34;_blank&#34;&gt;wpf中自定义DataGrid控件&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.cnblogs.com/nickli/archive/2010/10/07/1845175.html&#34; target=&#34;_blank&#34;&gt;wpf datagrid数据绑定&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a id=&#34;ctl02_TitleUrl&#34; href=&#34;http://www.cnblogs.com/mr0512/archive/2011/04/12/2014118.html&#34; target=&#34;_blank&#34;&gt;Datagrid动态绑定的数据作为图片列添加&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;比较方便的方法还是篇中的方法：
&lt;pre&gt;28 &amp;lt;DataGridTemplateColumn.CellTemplate&amp;gt;
29 &amp;lt;DataTemplate &amp;gt;
30 &amp;lt;Grid Height=&amp;ldquo;75&amp;rdquo; Background=&amp;ldquo;Transparent&amp;rdquo; &amp;gt;
31 &amp;lt;Grid.ColumnDefinitions&amp;gt;
32 &amp;lt;ColumnDefinition Width=&amp;rdquo;&lt;em&gt;&amp;rdquo;/&amp;gt;
33 &amp;lt;ColumnDefinition Width=&amp;ldquo;6&lt;/em&gt;&amp;rdquo;/&amp;gt;
34 &amp;lt;/Grid.ColumnDefinitions&amp;gt;
35 &amp;lt;Grid Margin=&amp;ldquo;10,0,0,0&amp;rdquo; Grid.Column=&amp;ldquo;1&amp;rdquo; &amp;gt;
36 &amp;lt;Grid.RowDefinitions&amp;gt;
37 &amp;lt;RowDefinition Height=&amp;rdquo;&lt;em&gt;&amp;rdquo;/&amp;gt;
38 &amp;lt;RowDefinition Height=&amp;ldquo;2&lt;/em&gt;&amp;rdquo;/&amp;gt;
39 &amp;lt;/Grid.RowDefinitions&amp;gt;
40 &amp;lt;TextBlock Grid.Row=&amp;ldquo;0&amp;rdquo; Margin=&amp;ldquo;0,5,0,0&amp;rdquo; Height=&amp;ldquo;24&amp;rdquo; Foreground=&amp;ldquo;Red&amp;rdquo; FontSize=&amp;ldquo;20&amp;rdquo; FontFamily=&amp;ldquo;方正舒体&amp;rdquo; TextWrapping=&amp;ldquo;Wrap&amp;rdquo; Text=&amp;ldquo;{Binding Sex}&amp;rdquo;/&amp;gt;
41 &amp;lt;TextBlock Margin=&amp;ldquo;1.429,15,0,0&amp;rdquo; Foreground=&amp;ldquo;Blue&amp;rdquo; Grid.Row=&amp;ldquo;1&amp;rdquo; FontFamily=&amp;ldquo;微软雅黑&amp;rdquo; TextWrapping=&amp;ldquo;Wrap&amp;rdquo; Text=&amp;ldquo;{Binding Name}&amp;rdquo;/&amp;gt;
42 &amp;lt;/Grid&amp;gt;
43 &amp;lt;Image Margin=&amp;ldquo;7,9,8,8&amp;rdquo; Source=&amp;ldquo;{Binding Pic}&amp;rdquo;/&amp;gt;
44
45 &amp;lt;/Grid&amp;gt;
46 &amp;lt;/DataTemplate&amp;gt;
47 &amp;lt;/DataGridTemplateColumn.CellTemplate&amp;gt;&lt;/pre&gt;
&lt;span style=&#34;color: #ff6600;&#34;&gt; ##################################################&lt;/span&gt;
&lt;h2&gt;&lt;span style=&#34;color: #ff6600;&#34;&gt;我承认我二！极其地特别的！！wpf toolkit datagrid有添加图片有方法！！！超简单！！！！&lt;/span&gt;&lt;/h2&gt;
&lt;pre&gt;&amp;lt;my:DataGridTemplateColumn Header=&amp;ldquo;{x:Static resx:Resources.tcDetailStatus}&amp;rdquo;&amp;gt;
&amp;lt;my:DataGridTemplateColumn.CellTemplate&amp;gt;
&amp;lt;DataTemplate&amp;gt;
&amp;lt;Image Source=&amp;ldquo;Images/Untested.png&amp;rdquo; /&amp;gt;
&amp;lt;/DataTemplate&amp;gt;
&amp;lt;/my:DataGridTemplateColumn.CellTemplate&amp;gt;
&amp;lt;/my:DataGridTemplateColumn&amp;gt;&lt;/pre&gt;
&amp;nbsp;&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;羞愧！掩面。。。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SYBASE数据库日志详解(转)</title>
      <link>http://www.daniex.tk/blog/2011/sybase-database-log-r/</link>
      <pubDate>Sun, 09 Oct 2011 02:18:46 &#43;0000</pubDate>
      <author>Daniex</author>
      <guid>http://www.daniex.tk/blog/2011/sybase-database-log-r/</guid>
      <description>&lt;p&gt;写了点sybase相关的代码，发现数据库配置的时候少做了点配置，导致日志很快就满，无法进行下一步操作。查了下资料，转载过来。&lt;/p&gt;

&lt;p&gt;弄sybase遇到一个比较诡异的事情，就是ABC三人弄了三个sybase数据库，A连AB没问题连C有问题，B连B没问题连C有问题，C连A没问题，连BC有问题。数据库连接的代码都是一样的，闹腾啊。&lt;/p&gt;

&lt;p&gt;&amp;nbsp;
&lt;h1&gt;SYBASE数据库日志详解&lt;/h1&gt;
&lt;div&gt;&lt;/p&gt;

&lt;p&gt;每个数据库都有自己的事务日志（Transaction　Log），即系统表（Syslogs），日志对于数据库的数据安全性、完整性至关重要，本文详解SYBASE数据库日志。&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;&lt;/div&gt;
我们知道，SYBASE　SQL Server用事务（Transaction）来跟踪所有数据库的变化。事务是SQL　Server的工作单元。一个事务包含一条或多条作为整体执行的 T-SQL语句。每个数据库都有自己的事务日志（Transaction　Log），即系统表（Syslogs）。事务日志自动记录每个用户发出的每个事 务。日志对于数据库的数据安全性、完整性至关重要，我们进行数据库开发和维护必须熟知日志的相关知识。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一、SYBASE　SQL Server 如何记录和读取日志信息&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;SYBASE　SQL Server是先记Log的机制。每当用户执行将修改数据库的语句时，SQL　Server就会自动地把变化写入日志。一条语句所产生的所有变化都被记录 到日志后，它们就被写到数据页在缓冲区的拷贝里。该数据页保存在缓冲区中，直到别的数据页需要该内存时，该数据页才被写到磁盘上。若事务中的某条语句没能 完成，SQL　Server将回滚事务产生的所有变化。这样就保证了整个数据库系统的一致性和完整性。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、日志设备&lt;/strong&gt;
Log和数据库的Data一样，需要存放在数据库设备上，可以将Log和Data存放在同一设备上，也可以分开 存放。一般来说，应该将一个数据库的Data和Log存放在不同的数据库设备上。这样做有如下好处：一是可以单独地备份Backup　事务日志；二是防 止数据库溢满；三是可以看到Log的空间使用情况。
所建Log设备的大小，没有十分精确的方法来确定。一般来说，对于新建的数据库，Log的大小 应为数据库大小的30%左右。Log的大小还取决于数据库修改的频繁程度。如果数据库修改频繁，则Log的增长十分迅速。所以说Log空间大小依赖于用户 是如何使用数据库的。此外，还有其它因素影响Log大小，我们应该根据实际操作情况估计Log大小，并间隔一段时间就对Log进行备份和清除。
&lt;strong&gt;三、日志的清除&lt;/strong&gt;
随着数据库的使用，数据库的Log是不断增长的，必须在它占满空间之前将它们清除掉。清除Log有两种方法：
&lt;strong&gt;1.自动清除法
&lt;/strong&gt;
开放数据库选项 Trunc Log on Chkpt，使数据库系统每隔一段时间自动清除Log。此方法的优点是无须人工干预，由SQL　Server自动执行，并且一般不会出现Log溢满的情况；缺点是只清除Log而不做备份。
&lt;strong&gt;2.手动清除法&lt;/strong&gt;
执行命令“dump transaction”来清除Log。以下两条命令都可以清除日志：
&lt;table width=&#34;400&#34; border=&#34;1&#34; cellspacing=&#34;0&#34; cellpadding=&#34;2&#34; align=&#34;center&#34;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td bgcolor=&#34;#e6e6e6&#34;&gt;
dump transaction with truncate_only
dump transaction with no_log
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
通常删除事务日志中不活跃的部分可使用“dump transaction with trancate_only”命令，这条命令写进事务日志时，还要做必要的并发性检查。SYBASE提供“dump transaction with no_log”来处理某些非常紧迫的情况，使用这条命令有很大的危险性，SQL　Server会弹出一条警告信息。为了尽量确保数据库的一致性，你应将它 作为“最后一招”。
以上两种方法只是清除日志，而不做日志备份，若想备份日志，应执行“dump transaction database_name to dumpdevice”命令。
&lt;strong&gt;四、管理庞大的事务&lt;/strong&gt;
有些操作会大批量地修改数据，如大量数据的修改（Update）、删除一个表的所有数据（Delete）、大量数据的插入（Insert），这样会使Log增长速度很快，有溢满的危险。下面笔者给大家介绍一下如何拆分大事务，以避免日志的溢满。
例 如执行“update tab_a set col_a=0”命令时，若表tab_a很大，则此Update动作在未完成之前就可能使Log溢满，引起1105错误（Log Full），而且执行这种大的事务所产生的独占锁（Exclusive Table Lock），会阻止其他用户在执行Update操作期间修改这个表，这就有可能引起死锁。为避免这些情况发生，我们可以把这个大的事务分成几个小的事务， 并执行“dump transaction”动作。
上例中的情况就可以分成两个或多个小的事务：
&lt;table width=&#34;400&#34; border=&#34;1&#34; cellspacing=&#34;0&#34; cellpadding=&#34;2&#34; align=&#34;center&#34;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td bgcolor=&#34;#e6e6e6&#34;&gt;
update tab_a set col_a=0 where col_b&amp;gt;x
go
dump transaction database_name with truncate_only
go
update tab_a set col_a=0 where col_b &amp;lt;=x
go
dump transaction database_name with truncate_only
go
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
这样，一个大的事务就被分成两个较小的事务。
按照上述方法可以根据需要任意拆分大的事务。若这个事务需要备份到介质上，则不用“with truncate_only”选项。若执行“dump transaction with truncate_only”命令，应该先执行“dump database”。以此类推，我们可以对表删除、表插入等大事务做相应的拆分。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>C#线程开始/暂停/终止</title>
      <link>http://www.daniex.tk/blog/2011/csharp-thread-start-stop-pause/</link>
      <pubDate>Thu, 29 Sep 2011 07:44:39 &#43;0000</pubDate>
      <author>Daniex</author>
      <guid>http://www.daniex.tk/blog/2011/csharp-thread-start-stop-pause/</guid>
      <description>&lt;p&gt;写测试工具需要多线程的暂停终止。用C#的 Thread.about()  join() resume() suspend()又提示函数过时了，不建议使用。于是四处找方法，信号量、互斥锁什么的方法也不少，找到下面这个方法，倒是很实用，转载如下：&lt;/p&gt;

&lt;p&gt;&amp;nbsp;
&lt;h1&gt;C#关于AutoResetEvent的使用介绍（转）&lt;/h1&gt;
&lt;strong&gt;AutoResetEvent&lt;/strong&gt; 允许线程通过发信号互相通信。通常，此通信涉及线程需要独占访问的资源。&lt;/p&gt;

&lt;p&gt;线程通过调用 &lt;strong&gt;AutoResetEvent&lt;/strong&gt; 上的 &lt;span style=&#34;color: #1d58d1;&#34;&gt;WaitOne&lt;/span&gt; 来等待信号。如果 &lt;strong&gt;AutoResetEvent&lt;/strong&gt; 处于非终止状态，则该线程阻塞，并等待当前控制资源的线程
通过调用 &lt;span style=&#34;color: #1d58d1;&#34;&gt;Set&lt;/span&gt; 发出资源可用的信号。&lt;/p&gt;

&lt;p&gt;调用 &lt;strong&gt;Set&lt;/strong&gt; 向 &lt;strong&gt;AutoResetEvent&lt;/strong&gt; 发信号以释放等待线程。&lt;strong&gt;AutoResetEvent&lt;/strong&gt; 将保持终止状态，直到一个正在等待的线程被释放，然后自动返回非终止状态。如果没有任何线程在等待，则状态将无限期地保持为终止状态。&lt;/p&gt;

&lt;p&gt;可以通过将一个布尔值传递给构造函数来控制 &lt;strong&gt;AutoResetEvent&lt;/strong&gt; 的初始状态，如果初始状态为终止状态，则为 &lt;strong&gt;true&lt;/strong&gt;；否则为 &lt;strong&gt;false&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;通俗的来讲只有等myResetEven.Set()成功运行后,myResetEven.WaitOne()才能够获得运行机会;Set是发信号，WaitOne是等待信号，只有发了信号，
等待的才会执行。如果不发的话，WaitOne后面的程序就永远不会执行。下面我们来举一个例子：我去书店买书，当我选中一本书后我会去收费处付钱，
付好钱后再去仓库取书。这个顺序不能颠倒，我作为主线程，收费处和仓库做两个辅助线程，代码如下：
&lt;pre&gt;using System;
using System.Linq;
using System.Activities;
using System.Activities.Statements;
using System.Threading;&lt;/p&gt;

&lt;p&gt;namespace CaryAREDemo
{
    class Me
    {
        const int numIterations = 550;
        static AutoResetEvent myResetEvent = new AutoResetEvent(false);
        static AutoResetEvent ChangeEvent = new AutoResetEvent(false);
        //static ManualResetEvent myResetEvent = new ManualResetEvent(false);
        //static ManualResetEvent ChangeEvent = new ManualResetEvent(false);
        static int number; //这是关键资源&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    static void Main()
    {
        Thread payMoneyThread = new Thread(new ThreadStart(PayMoneyProc));
        payMoneyThread.Name = &amp;quot;付钱线程&amp;quot;;
        Thread getBookThread = new Thread(new ThreadStart(GetBookProc));
        getBookThread.Name = &amp;quot;取书线程&amp;quot;;
        payMoneyThread.Start();
        getBookThread.Start();

        for (int i = 1; i &amp;amp;lt;= numIterations; i++)
        {
            Console.WriteLine(&amp;quot;买书线程：数量{0}&amp;quot;, i);
            number = i;
            //Signal that a value has been written.
            myResetEvent.Set();
            ChangeEvent.Set();
            Thread.Sleep(0);
        }
        payMoneyThread.Abort();
        getBookThread.Abort();
    }

    static void PayMoneyProc()
    {
        while (true)
        {
            myResetEvent.WaitOne();
            //myResetEvent.Reset();
            Console.WriteLine(&amp;quot;{0}：数量{1}&amp;quot;, Thread.CurrentThread.Name, number);
        }
    }
    static void GetBookProc()
    {
        while (true)
        {
            ChangeEvent.WaitOne();
            // ChangeEvent.Reset();               
            Console.WriteLine(&amp;quot;{0}：数量{1}&amp;quot;, Thread.CurrentThread.Name, number);
            Console.WriteLine(&amp;quot;------------------------------------------&amp;quot;);
            Thread.Sleep(0);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
运行结果如下：&lt;/pre&gt;
&lt;p style=&#34;text-align: center;&#34;&gt;&lt;img class=&#34;aligncenter&#34; style=&#34;border: 0pt none;&#34; src=&#34;http://www.csharpwin.com/upload/003250JL-0.png&#34; alt=&#34;image&#34; width=&#34;242&#34; height=&#34;229&#34; border=&#34;0&#34; /&gt;&lt;/p&gt;
AutoResetEvent与ManualResetEvent的区别&lt;/p&gt;

&lt;p&gt;他们的用法\声明都很类似，Set方法将信号置为发送状态 Reset方法将信号置为不发送状态WaitOne等待信号的发送。其实,从名字就可以看出一个手动,
一个自动，这个手动和自动实际指的是在Reset方法的处理上,如下面例子：&lt;/p&gt;

&lt;p&gt;public AutoResetEvent autoevent=new AutoResetEvent(true);
public ManualResetEvent manualevent=new ManualResetEvent(true);&lt;/p&gt;

&lt;p&gt;默认信号都处于发送状态,&lt;/p&gt;

&lt;p&gt;autoevent.WaitOne();
manualevent.WaitOne();&lt;/p&gt;

&lt;p&gt;如果 某个线程调用上面该方法,则当信号处于发送状态时,该线程会得到信号,得以继续执行。差别就在调用后,autoevent.WaitOne()每次只允许一个线程
进入,当某个线程得到信号(也就是有其他线程调用了autoevent.Set()方法后)后,autoevent会自动又将信号置为不发送状态,则其他调用WaitOne的线程只
有继续等待.也就是说,autoevent一次只唤醒一个线程。而manualevent则可以唤醒多个线程,因为当某个线程调用了set方法后,其他调用waitone的线程
获得信号得以继续执行,而manualevent不会自动将信号置为不发送.也就是说,除非手工调用了manualevent.Reset().方法,则 manualevent将一直保持有信号状态,manualevent也就可以同时唤醒多个线程继续执行。如果上面的程序换成 ManualResetEvent的话，就需要在waitone后面做下reset。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>WPF数据绑定UI显示同步变更例子</title>
      <link>http://www.daniex.tk/blog/2011/wpf-data-binding-ui-shows-examples-of-simultaneous-changes/</link>
      <pubDate>Mon, 26 Sep 2011 08:04:35 &#43;0000</pubDate>
      <author>Daniex</author>
      <guid>http://www.daniex.tk/blog/2011/wpf-data-binding-ui-shows-examples-of-simultaneous-changes/</guid>
      <description>&lt;p&gt;WPF数据绑定功能很好，很强大。只需要写一点代码就可以做到数据的绑定，数据变更后UI的数据同步显示。UI和主程序多线程间的数据交互问题可以通过这个轻松解决。对“由于其他线程拥有此对象，因此调用线程无法对其进行访问”这样的问题，wpf 的dispatcher 是一个可能的解决方法，数据绑定也是一个方式。&lt;/p&gt;

&lt;p&gt;定义类
&lt;pre class=&#34;brush:csharp&#34;&gt;using System;
using System.ComponentModel;&lt;/p&gt;

&lt;p&gt;namespace Demo.View
{
    public class DemoBinding: INotifyPropertyChanged
    {
        private double fail;
        public double Fail
        {
            get { return fail; }
            set
            {
                fail= value;
                NotifyPropertyChanged(&amp;ldquo;Fail&amp;rdquo;);
            }
        }&lt;/p&gt;

&lt;p&gt;        private String pass = Properties.Resources.statusPass + &amp;ldquo;0&amp;rdquo;;
        public String Pass
        {
            get { return pass; }
            set
            {
                pass = value;
                NotifyPropertyChanged(&amp;ldquo;Pass&amp;rdquo;);
            }
        }&lt;/p&gt;

&lt;p&gt;        public event PropertyChangedEventHandler PropertyChanged;&lt;/p&gt;

&lt;p&gt;        public void NotifyPropertyChanged(String propertyName)
        {
            if (PropertyChanged != null)
            {
                PropertyChanged(this, new PropertyChangedEventArgs(propertyName));
            }
        }
    }
}&lt;/pre&gt;
xaml 文件内容：
&lt;pre class=&#34;brush:xml&#34;&gt; &amp;lt;ProgressBar Name=&amp;ldquo;progressBar&amp;rdquo; Value=&amp;ldquo;{Binding Fail}&amp;rdquo; Height=&amp;ldquo;30&amp;rdquo; Margin=&amp;ldquo;4&amp;rdquo; /&amp;gt;
&amp;lt;Label Name=&amp;ldquo;label_pass&amp;rdquo;  Foreground=&amp;ldquo;Green&amp;rdquo; FontSize=&amp;ldquo;14&amp;rdquo; Content=&amp;ldquo;{Binding Pass}&amp;rdquo; /&amp;gt;&lt;/pre&gt;
当数据需要改变时，只要使数据对象DemoBinding data的属性值赋值，数据和UI都会随之改变，如:data.fail = 50;&lt;/p&gt;

&lt;p&gt;当然，可以把类对象定义为static的静态对象，这样就不需要保证对象唯一性的代码了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>A Versatile TreeView for WPF</title>
      <link>http://www.daniex.tk/blog/2011/a-versatile-treeview-for-wpf/</link>
      <pubDate>Thu, 22 Sep 2011 08:58:58 &#43;0000</pubDate>
      <author>Daniex</author>
      <guid>http://www.daniex.tk/blog/2011/a-versatile-treeview-for-wpf/</guid>
      <description>&lt;p&gt;写自动化测试工具的时候要用到tree view，于是上网各种找。C#的Infragistics NetAdvantage，DevExpress之类框架。都太大了，小工具用不着这么大的。用自带的tree view又觉得土了点，WPF又是在边学边做。终于折腾着找个到一个，看着挺好，用着也还合适。&lt;/p&gt;

&lt;p&gt;&lt;span style=&#34;color: #0000ff;&#34;&gt;&lt;a title=&#34;A Versatile TreeView for WPF&#34; href=&#34;http://www.codeproject.com/KB/WPF/versatile_treeview.aspx&#34; target=&#34;_blank&#34;&gt;&lt;span style=&#34;color: #0000ff;&#34;&gt;A Versatile TreeView for WPF&lt;/span&gt;&lt;/a&gt;&lt;/span&gt; 来自&lt;span style=&#34;color: #0000ff;&#34;&gt; &lt;a title=&#34;codeproject&#34; href=&#34;http://www.codeproject.com/&#34; target=&#34;_blank&#34;&gt;&lt;span style=&#34;color: #0000ff;&#34;&gt;codeproject  &lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;他是个DLL，加到工程就好，还提供例子程序，对于我这种WPF未入门的来说正好。在他代码上边学边改，学着不少。例程如下图：
&lt;p style=&#34;text-align: center;&#34;&gt;&lt;img class=&#34;aligncenter&#34; title=&#34;wpf tree view ui&#34; src=&#34;http://www.codeproject.com/KB/WPF/versatile_treeview/sampleapp.png&#34; alt=&#34;&#34; width=&#34;571&#34; height=&#34;420&#34; /&gt;&lt;/p&gt;
树的展开，折叠，选中，状态变更更换图片，增加删除节点，排序，筛选等等功能都支持。&lt;/p&gt;

&lt;p&gt;但是也发现了问题，比如，根节点不好删除，重新加载/更换树也不方便。需要继续努力学习wpf去改代码了。任重道远哦～&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;另外还用了wpf toolkit 这个插件花datagrid，由于用的是.net3.5 平台，居然都没有datagrid！搜下下载安装就好，也挺好用的一个工具。详见&lt;a href=&#34;../wpf-datagrid.html&#34;&gt;&lt;span style=&#34;color: #0000ff;&#34;&gt;WPF DataGrid 绑定数据 &lt;/span&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;#######################################&lt;/p&gt;

&lt;p&gt;总结下删除树更换节点的问题，之前提到的都不是问题。方法如下：&lt;/p&gt;

&lt;p&gt;继承的TreeViewBase&amp;lt;T&amp;gt;类没有提供相应的接口去删除根节点，但是，由于整个树都是绑定于可自己定义的数据结构上。例如，例程中将树形结构绑定到ShopUtil中的一个列表中，对该列表直接进行操作，删除，更换节点，甚至更换整个树形结构。其后刷新树就可以得到新的结构了。&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>wpf在xaml文件中调用resx资源文件</title>
      <link>http://www.daniex.tk/blog/2011/use-resx-in-xaml/</link>
      <pubDate>Fri, 16 Sep 2011 02:49:17 &#43;0000</pubDate>
      <author>Daniex</author>
      <guid>http://www.daniex.tk/blog/2011/use-resx-in-xaml/</guid>
      <description>&lt;p&gt;找了不少方法，有些都比较麻烦。列举如下：&lt;/p&gt;

&lt;p&gt;1、最简单的 ：&lt;/p&gt;

&lt;p&gt;xmlns:resx=&amp;ldquo;clr-namespace:wpfapplicationname.Properties&amp;rdquo;
Title=&amp;ldquo;{x:Static resx:Resources.name}&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;2、&lt;/p&gt;

&lt;p&gt;用第三方工具 例如&lt;a title=&#34;WPF_Resx_Localization&#34; href=&#34;http://www.codeproject.com/KB/WPF/WPF_Resx_Localization.aspx&#34; target=&#34;_blank&#34;&gt;&lt;a href=&#34;http://www.codeproject.com/KB/WPF/WPF_Resx_Localization.aspx&#34;&gt;http://www.codeproject.com/KB/WPF/WPF_Resx_Localization.aspx&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;3、&lt;/p&gt;

&lt;p&gt;// Get all properties from resx resource object
Type resType = typeof( Xyz.Xyz.Properties.Resources );
PropertyInfo[] properties = resType.GetProperties( BindingFlags.Static | BindingFlags.NonPublic );&lt;/p&gt;

&lt;p&gt;then do&lt;/p&gt;

&lt;p&gt;// Add properties to XAML Application.Resources
foreach( PropertyInfo property in properties )
{
//
if( property.PropertyType == typeof( string ) )
Resources.Add( property.Name, property.GetValue( null, null ) );
}&lt;/p&gt;

&lt;p&gt;Then in your XAML code simply do:&lt;/p&gt;

&lt;p&gt;&amp;lt;TextBlock&amp;gt;&amp;lt;StaticResource ResourceKey=&amp;ldquo;theResNameFromYourResX&amp;rdquo; /&amp;gt;&amp;lt;/TextBlock&amp;gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>WPF DataGrid 绑定数据</title>
      <link>http://www.daniex.tk/blog/2011/wpf-datagrid/</link>
      <pubDate>Thu, 01 Sep 2011 03:07:33 &#43;0000</pubDate>
      <author>Daniex</author>
      <guid>http://www.daniex.tk/blog/2011/wpf-datagrid/</guid>
      <description>&lt;p&gt;写WPF程序，需要表格。用的是.net3.5，于是找了个WPF Toolkit工具用着。&lt;/p&gt;

&lt;p&gt;地址：wpf toolkit &lt;a title=&#34;wpf toolkit website&#34; href=&#34;http://wpf.codeplex.com/&#34; target=&#34;_blank&#34;&gt;&lt;span style=&#34;color: #0000ff;&#34;&gt;&lt;a href=&#34;http://wpf.codeplex.com/&#34;&gt;http://wpf.codeplex.com/&lt;/a&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在绑定数据的时候遇到点麻烦，当然绑定数据的方法有很多中，这里转一个。在最后绑定数据的时候方法不止一种，在下面的代码中我稍作添加。&lt;/p&gt;

&lt;p&gt;地址：&lt;a title=&#34;WPFToolkit DataGrid 使用介绍&#34; href=&#34;http://www.cnblogs.com/xh831213/archive/2010/04/01/1702279.html&#34; target=&#34;_blank&#34;&gt;&lt;span style=&#34;color: #0000ff;&#34;&gt;&lt;a href=&#34;http://www.cnblogs.com/xh831213/archive/2010/04/01/1702279.html&#34;&gt;http://www.cnblogs.com/xh831213/archive/2010/04/01/1702279.html&lt;/a&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&amp;nbsp;
&lt;pre class=&#34;brush: xml&#34;&gt;
xaml文件如下：
&lt;div&gt;
&lt;div&gt;&amp;lt;Window x:Class=&amp;ldquo;WpfAppTest.WPFDataGrid&amp;rdquo;
xmlns=&amp;ldquo;&lt;a href=&#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation&amp;quot;&#34;&gt;http://schemas.microsoft.com/winfx/2006/xaml/presentation&amp;quot;&lt;/a&gt;
xmlns:x=&amp;ldquo;&lt;a href=&#34;http://schemas.microsoft.com/winfx/2006/xaml&amp;quot;&#34;&gt;http://schemas.microsoft.com/winfx/2006/xaml&amp;quot;&lt;/a&gt;
xmlns:sys=&amp;ldquo;clr-namespace:System;assembly=mscorlib&amp;rdquo;
xmlns:toolkit=&amp;ldquo;&lt;a href=&#34;http://schemas.microsoft.com/wpf/2008/toolkit&amp;quot;&#34;&gt;http://schemas.microsoft.com/wpf/2008/toolkit&amp;quot;&lt;/a&gt;
xmlns:myWPFDataGrid=&amp;ldquo;clr-namespace:WpfAppTest;assembly=WpfAppTest&amp;rdquo;
Title=&amp;ldquo;WPFDataGrid&amp;rdquo; Height=&amp;ldquo;351&amp;rdquo; Width=&amp;ldquo;647&amp;rdquo; Loaded=&amp;ldquo;Window_Loaded&amp;rdquo;&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;Window.Resources&amp;gt;
&amp;lt;ObjectDataProvider x:Key=&amp;ldquo;myEnum&amp;rdquo; MethodName=&amp;ldquo;GetValues&amp;rdquo; ObjectType=&amp;ldquo;{x:Type sys:Enum}&amp;rdquo;&amp;gt;
&amp;lt;ObjectDataProvider.MethodParameters&amp;gt;
&amp;lt;x:Type TypeName=&amp;ldquo;myWPFDataGrid:sampleType&amp;rdquo;/&amp;gt;
&amp;lt;/ObjectDataProvider.MethodParameters&amp;gt;
&amp;lt;/ObjectDataProvider&amp;gt;
&amp;lt;/Window.Resources&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;Grid&amp;gt;
&amp;lt;toolkit:DataGrid Name=&amp;ldquo;SampleDataGrid&amp;rdquo; AutoGenerateColumns=&amp;ldquo;False&amp;rdquo; ItemsSource=&amp;ldquo;{Binding}&amp;rdquo;&amp;gt;
&amp;lt;toolkit:DataGrid.Columns&amp;gt;
&amp;lt;toolkit:DataGridTextColumn Header=&amp;ldquo;ID&amp;rdquo;  Binding=&amp;ldquo;{Binding ID}&amp;rdquo;/&amp;gt;
&amp;lt;toolkit:DataGridTextColumn Header=&amp;ldquo;Name&amp;rdquo; Binding=&amp;ldquo;{Binding Name}&amp;ldquo; /&amp;gt;
&amp;lt;toolkit:DataGridHyperlinkColumn Header=&amp;ldquo;Link&amp;rdquo; Binding=&amp;ldquo;{Binding Link}&amp;ldquo;  ContentBinding=&amp;rdquo;{Binding Link}&amp;ldquo; /&amp;gt;
&amp;lt;toolkit:DataGridCheckBoxColumn Header=&amp;ldquo;IsBool&amp;rdquo; Binding=&amp;ldquo;{Binding IsBool}&amp;ldquo; /&amp;gt;
&amp;lt;toolkit:DataGridComboBoxColumn Header=&amp;ldquo;MyType&amp;rdquo; SelectedItemBinding=&amp;ldquo;{Binding MyType}&amp;ldquo; ItemsSource=&amp;rdquo;{Binding Source={StaticResource myEnum}}&amp;ldquo; TextBinding=&amp;rdquo;{Binding MyType}&amp;ldquo; /&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;/toolkit:DataGrid.Columns&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;/toolkit:DataGrid&amp;gt;
&amp;lt;/Grid&amp;gt;
&amp;lt;/Window&amp;gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/pre&gt;
&amp;nbsp;&lt;/p&gt;

&lt;p&gt;c#文件如下：
&lt;pre class=&#34;brush: csharp&#34;&gt;
&lt;div&gt;using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Shapes;
using System.Data;&lt;/p&gt;

&lt;p&gt;namespace WpfAppTest
{
/// &amp;lt;summary&amp;gt;
/// Interaction logic for WPFDataGrid.xaml
/// &amp;lt;/summary&amp;gt;
public partial class WPFDataGrid : Window
{
public WPFDataGrid()
{
InitializeComponent();
}&lt;/p&gt;

&lt;p&gt;private void Window_Loaded(object sender, RoutedEventArgs e)
{
DataTable dt = new DataTable();
DataColumn dc = new DataColumn(&amp;ldquo;ID&amp;rdquo;, typeof(System.String));
dt.Columns.Add(dc);
dc = new DataColumn(&amp;ldquo;Name&amp;rdquo;, typeof(System.String));
dt.Columns.Add(dc);
dc = new DataColumn(&amp;ldquo;Link&amp;rdquo;, typeof(System.String));
dt.Columns.Add(dc);
dc = new DataColumn(&amp;ldquo;IsBool&amp;rdquo;, typeof(System.Boolean));
dt.Columns.Add(dc);
dc = new DataColumn(&amp;ldquo;MyType&amp;rdquo;, typeof(sampleType));
dt.Columns.Add(dc);
for (int i = 0; i &amp;lt; 10; i++)
{
dt.Rows.Add(new object[] { i.ToString(), &amp;rdquo;Name&amp;rdquo; + i.ToString(), &amp;rdquo;Link&amp;rdquo; + i.ToString(), true, sampleType.C });
}&lt;/div&gt;
&lt;h3&gt;&lt;span style=&#34;color: #800000;&#34;&gt;//可以使用下面注释的一行代码替换其后的三行，数据也能绑定成功&lt;/span&gt;
&lt;span style=&#34;color: #800000;&#34;&gt;//SampleDataGrid.ItemsSource = dt.DefaultView;&lt;/span&gt;&lt;/h3&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;DataSet ds = new DataSet();
ds.Tables.Add(dt);&lt;/p&gt;

&lt;p&gt;SampleDataGrid.DataContext = ds.Tables[0];&lt;/div&gt;
&lt;div&gt;}
}&lt;/p&gt;

&lt;p&gt;public enum sampleType
{ A, B, C, D, E };
}&lt;/div&gt;
&lt;/pre&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>WPF中使用USERCONTROL</title>
      <link>http://www.daniex.tk/blog/2011/wpf-using-usercontrol/</link>
      <pubDate>Wed, 17 Aug 2011 07:58:11 &#43;0000</pubDate>
      <author>Daniex</author>
      <guid>http://www.daniex.tk/blog/2011/wpf-using-usercontrol/</guid>
      <description>&lt;p&gt;想着怎么在wpf的xaml文件中嵌入另一个xaml文件，找了会发现可以通过usercontrol控件实现。&lt;/p&gt;

&lt;p&gt;右键项目添加用户控件，生成一个xaml文件。注意其namespase和类属性：
&lt;pre id=&#34;pre0&#34; lang=&#34;xml&#34;&gt;&amp;lt;UserControl
    Name=&amp;ldquo;UserControlToolTip&amp;rdquo;
   &lt;span style=&#34;color: #ff6600;&#34;&gt; x:Class=&amp;ldquo;CustomToolTip.UserControl1&amp;rdquo;&lt;/span&gt;
    xmlns=&amp;ldquo;&lt;a href=&#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation&amp;quot;&#34;&gt;http://schemas.microsoft.com/winfx/2006/xaml/presentation&amp;quot;&lt;/a&gt;
    xmlns:x=&amp;ldquo;&lt;a href=&#34;http://schemas.microsoft.com/winfx/2006/xaml&amp;quot;&#34;&gt;http://schemas.microsoft.com/winfx/2006/xaml&amp;quot;&lt;/a&gt;
    xmlns:d=&amp;ldquo;&lt;a href=&#34;http://schemas.microsoft.com/expression/blend/2008&amp;quot;&#34;&gt;http://schemas.microsoft.com/expression/blend/2008&amp;quot;&lt;/a&gt;
    xmlns:mc=&amp;ldquo;&lt;a href=&#34;http://schemas.openxmlformats.org/markup-compatibility/2006&amp;quot;&#34;&gt;http://schemas.openxmlformats.org/markup-compatibility/2006&amp;quot;&lt;/a&gt;
    mc:Ignorable=&amp;ldquo;d&amp;rdquo; RenderTransformOrigin=&amp;ldquo;0,0&amp;rdquo; HorizontalAlignment=&amp;ldquo;Left&amp;rdquo;
    VerticalAlignment=&amp;ldquo;Top&amp;rdquo; &amp;gt;
&amp;lt;/UserControl&amp;gt;
&lt;/pre&gt;
在window中调用的时候需要这样：&lt;/p&gt;

&lt;pre id=&#34;pre2&#34; lang=&#34;xml&#34;&gt;&amp;lt;Window x:Class=&#34;WpfApplication1.Window1&#34;
    xmlns=&#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation&#34;
    xmlns:x=&#34;http://schemas.microsoft.com/winfx/2006/xaml&#34;
    &lt;span style=&#34;color: #ff6600;&#34;&gt;xmlns:myToolTip=&#34;clr-namespace:CustomToolTip;assembly=CustomToolTip&#34;&lt;/span&gt;
    Title=&#34;Window1&#34; Height=&#34;600&#34; Width=&#34;800&#34;&amp;gt;
&amp;lt;/Window&amp;gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>http协议头部与keep-alive</title>
      <link>http://www.daniex.tk/blog/2011/http-keep-alive/</link>
      <pubDate>Thu, 28 Jul 2011 10:40:11 &#43;0000</pubDate>
      <author>Daniex</author>
      <guid>http://www.daniex.tk/blog/2011/http-keep-alive/</guid>
      <description>

&lt;p&gt;上一篇讲&lt;a href=&#34;../java-send-http-request-example.html&#34;&gt;java发送http请求例子&lt;/a&gt;遇到的问题并不是java发送请求的代码问题。经检查是http server代码不完善导致，连接状态即http头中Connection参数设置有问题。&lt;/p&gt;

&lt;p&gt;在网上看到一篇挺好的文章，找了半天才找到原文出处，这就是在网上码字的悲哀。我也转个：&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;-——————————————————————————————————&lt;/p&gt;

&lt;p&gt;这样被判了死刑&amp;ndash;吴秦 &lt;a title=&#34;HTTP协议头部与Keep-Alive模式详解 &#34; href=&#34;http://www.cnblogs.com/skynet/archive/2010/12/11/1903347.html&#34; target=&#34;_blank&#34;&gt;&lt;a href=&#34;http://www.cnblogs.com/skynet/archive/2010/12/11/1903347.html&#34;&gt;http://www.cnblogs.com/skynet/archive/2010/12/11/1903347.html&lt;/a&gt;&lt;/a&gt;
&lt;div id=&#34;cnblogs_post_body&#34;&gt;&lt;/p&gt;

&lt;p&gt;——献给那些向我这样对HTTP的“伪”熟悉者。&lt;/p&gt;

&lt;p&gt;故事发生在10月份的一次面试经历中，本来我不想说出来丢人显眼，但是为了警醒自己和告诫后人，我决定写成博文发出来。因为在面试过程中，我讲在2009年写过QQ农场助手，在这期间深入学习了HTTP协议，而且在2010-05-18写了博文：&lt;a href=&#34;http://www.cnblogs.com/skynet/archive/2010/05/18/1738301.html&#34;&gt;HTTP协议及其POST与GET操作差异 &amp;amp; C#中如何使用POST、GET等&lt;/a&gt;。面试官说既然我熟悉HTTP协议，就问“当HTTP采用keepalive模式，当客户端向服务器发生请求之后，客户端如何判断服务器的数据已经发生完成？”&lt;/p&gt;

&lt;p&gt;说实话，当时我懵了，一直没有关注过keepalive模式。我只知道：&lt;strong&gt;HTTP协议中客户端发送一个小请求，服务器响应以所期望的信息（例如一个html文件或一副gif图像）。服务器通常在发送回所请求的数据之后就关闭连接。这样客户端读数据时会返回EOF（-1），就知道数据已经接收完全了。&lt;/strong&gt;我就这样被面试官判了死刑！！！说我完全停留在表面，没有深入（当时真的很受打击，一直自认为技术还不错！）。我当时真的很想找各种借口：
&lt;ul&gt;
    &lt;li&gt;
&lt;div&gt;之前没有用到HTTP的keepalive模式，所以没有深入&lt;/div&gt;&lt;/li&gt;
    &lt;li&gt;
&lt;div&gt;好久没有用HTTP协议，细节忘了&lt;/div&gt;&lt;/li&gt;
    &lt;li&gt;
&lt;div&gt;实习的东西跟HTTP协议没有关系，用得少了就忘了&lt;/div&gt;&lt;/li&gt;
    &lt;li&gt;
&lt;div&gt;。。。。。。&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
觉得各种解释都是那么苍白无力！我再次感叹书到用时方恨少，也感叹一个人的时间是多么的有限（曾一度想成为一个IT专业全才），根本没有精力面面俱 到，而且当没有真正使用一个东西的时候，往往会忽略掉很多细节。朋友如果你也答不上来，请认真细看下文，不要怀着浮躁了的心，说不定下次就有人问你这个问 题。
&lt;h1&gt;1、什么是Keep-Alive模式？&lt;/h1&gt;
我们知道HTTP协议采用“请求-应答”模式，当使用普通模式，即非KeepAlive模式时，每个请求/应答客户和服务器都要新建一个连接，完成 之后立即断开连接（HTTP协议为无连接的协议）；当使用Keep-Alive模式（又称持久连接、连接重用）时，Keep-Alive功能使客户端到服 务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接。&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter&#34; title=&#34;Connection&#34; src=&#34;http://upload.wikimedia.org/wikipedia/commons/thumb/d/d5/HTTP_persistent_connection.svg/450px-HTTP_persistent_connection.svg.png&#34; alt=&#34;&#34; width=&#34;450&#34; height=&#34;280&#34; /&gt;&lt;/p&gt;

&lt;p&gt;http 1.0中默认是关闭的，需要在http头加入&amp;rdquo;Connection: Keep-Alive&amp;rdquo;，才能启用Keep-Alive；http 1.1中默认启用Keep-Alive，如果加入&amp;rdquo;Connection: close &amp;ldquo;，才关闭。目前大部分浏览器都是用http1.1协议，也就是说默认都会发起Keep-Alive的连接请求了，所以是否能完成一个完整的Keep- Alive连接就看服务器设置情况。
&lt;h1&gt;2、启用Keep-Alive的优点&lt;/h1&gt;
从上面的分析来看，启用Keep-Alive模式肯定更高效，性能更高。因为避免了建立/释放连接的开销。下面是&lt;a href=&#34;http://tools.ietf.org/html/rfc2616&#34;&gt;RFC 2616&lt;/a&gt;上的总结：
&lt;ol&gt;
    &lt;li&gt;
&lt;ol&gt;
    &lt;li&gt;
&lt;div&gt;By opening and closing fewer TCP connections, CPU time is saved in routers and hosts (clients, servers, proxies, gateways, tunnels, or caches), and memory used for TCP protocol control blocks can be saved in hosts.&lt;/div&gt;&lt;/li&gt;
    &lt;li&gt;
&lt;div&gt;HTTP requests and responses can be pipelined on a connection. Pipelining allows a client to make multiple requests without waiting for each response, allowing a single TCP connection to be used much more efficiently, with much lower elapsed time.&lt;/div&gt;&lt;/li&gt;
    &lt;li&gt;
&lt;div&gt;Network congestion is reduced by reducing the number of packets caused by TCP opens, and by allowing TCP sufficient time to determine the congestion state of the network.&lt;/div&gt;&lt;/li&gt;
    &lt;li&gt;
&lt;div&gt;Latency on subsequent requests is reduced since there is no time spent in TCP&amp;rsquo;s connection opening handshake.&lt;/div&gt;&lt;/li&gt;
    &lt;li&gt;
&lt;div&gt;HTTP can evolve more gracefully, since errors can be reported without the penalty of closing the TCP connection. Clients using     future versions of HTTP might optimistically try a new feature, but if communicating with an older server, retry with old   semantics after an error is reported.&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;a href=&#34;http://tools.ietf.org/html/rfc2616&#34;&gt;RFC 2616&lt;/a&gt;（P47）还指出：单用户客户端与任何服务器或代理之间的连接数不应该超过2个。一个代理与其它服务器或代码之间应该使用超过2 * N的活跃并发连接。这是为了提高HTTP响应时间，避免拥塞（冗余的连接并不能代码执行性能的提升）。
&lt;h1&gt;3、回到我们的问题（即如何判断消息内容/长度的大小？）&lt;/h1&gt;
Keep-Alive模式，客户端如何判断请求所得到的响应数据已经接收完成（或者说如何知道服务器已经发生完了数据）？我们已经知道 了，Keep-Alive模式发送玩数据HTTP服务器不会自动断开连接，所有不能再使用返回EOF（-1）来判断（当然你一定要这样使用也没有办法，可 以想象那效率是何等的低）！下面我介绍两种来判断方法。
&lt;h2&gt;3.1、使用消息首部字段Conent-Length&lt;/h2&gt;
故名思意，Conent-Length表示实体内容长度，客户端（服务器）可以根据这个值来判断数据是否接收完成。但是如果消息中没有Conent-Length，那该如何来判断呢？又在什么情况下会没有Conent-Length呢？请继续往下看……
&lt;h2&gt;3.2、使用消息首部字段Transfer-Encoding&lt;/h2&gt;
当客户端向服务器请求一个静态页面或者一张图片时，服务器可以很清楚的知道内容大小，然后通过Content-length消息首部字段告诉客户端 需要接收多少数据。但是如果是动态页面等时，服务器是不可能预先知道内容大小，这时就可以使用Transfer-Encoding：chunk模式来传输 数据了。即如果要一边产生数据，一边发给客户端，服务器就需要使用&amp;rdquo;Transfer-Encoding: chunked&amp;rdquo;这样的方式来代替Content-Length。&lt;/p&gt;

&lt;p&gt;chunk编码将数据分成一块一块的发生。Chunked编码将使用若干个Chunk串连而成，由一个标明&lt;strong&gt;长度为0&lt;/strong&gt;的chunk标示结束。每个Chunk分为头部和正文两部分，头部内容指定正文的字符总数（&lt;strong&gt;十六进制的数字&lt;/strong&gt;）和数量单位（一般不写），正文部分就是指定长度的实际内容，两部分之间用&lt;strong&gt;回车换行(CRLF)&lt;/strong&gt;隔开。在最后一个长度为0的Chunk中的内容是称为footer的内容，是一些附加的Header信息（通常可以直接忽略）。
&lt;blockquote&gt;Chunk编码的格式如下：&lt;/p&gt;

&lt;p&gt;Chunked-Body = *&lt;strong&gt;chunk&lt;/strong&gt;
&amp;ldquo;0&amp;rdquo; CRLF
footer
CRLF
chunk = chunk-size [ chunk-ext ] CRLF
chunk-data CRLF&lt;/p&gt;

&lt;p&gt;hex-no-zero = &amp;lt;HEX excluding &amp;ldquo;0&amp;rdquo;&amp;gt;&lt;/p&gt;

&lt;p&gt;chunk-size = hex-no-zero *HEX
chunk-ext = *( &amp;ldquo;;&amp;rdquo; chunk-ext-name [ &amp;ldquo;=&amp;rdquo; chunk-ext-value ] )
chunk-ext-name = token
chunk-ext-val = token | quoted-string
chunk-data = chunk-size(OCTET)&lt;/p&gt;

&lt;p&gt;footer = *entity-header&lt;/p&gt;

&lt;p&gt;即Chunk编码由四部分组成：1、&lt;strong&gt;0至多个chunk块&lt;/strong&gt;，2、&lt;strong&gt;&amp;ldquo;0&amp;rdquo; CRLF&lt;/strong&gt;，3、&lt;strong&gt;footer&lt;/strong&gt;，4、&lt;strong&gt;CRLF&lt;/strong&gt;&lt;strong&gt;.&lt;/strong&gt;而每个chunk块由：chunk-size、chunk-ext（可选）、CRLF、chunk-data、CRLF组成。&lt;/blockquote&gt;
&lt;h1&gt;4、消息长度的总结&lt;/h1&gt;
其实，上面2中方法都可以归纳为是如何判断http消息的大小、消息的数量。&lt;a href=&#34;http://tools.ietf.org/html/rfc2616&#34;&gt;RFC 2616&lt;/a&gt;对 消息的长度总结如下：一个消息的transfer-length（传输长度）是指消息中的message-body（消息体）的长度。当应用了 transfer-coding（传输编码），每个消息中的message-body（消息体）的长度（transfer-length）由以下几种情况 决定（优先级由高到低）：
&lt;ul&gt;
    &lt;li&gt;任何不含有消息体的消息（如1XXX、204、304等响应消息和任何头(HEAD，首部)请求的响应消息），总是由一个空行（CLRF）结束。&lt;/li&gt;
    &lt;li&gt;如果出现了Transfer-Encoding头字段 并且值为非“identity”，那么transfer-length由“chunked” 传输编码定义，除非消息由于关闭连接而终止。&lt;/li&gt;
    &lt;li&gt;如果出现了Content-Length头字段，它的值表示entity-length（实体长度）和transfer-length（传输长 度）。如果这两个长度的大小不一样（i.e.设置了Transfer-Encoding头字段），那么将不能发送Content-Length头字段。并 且如果同时收到了Transfer-Encoding字段和Content-Length头字段，那么必须忽略Content-Length字段。&lt;/li&gt;
    &lt;li&gt;如果消息使用媒体类型“multipart/byteranges”，并且transfer-length 没有另外指定，那么这种自定界（self-delimiting）媒体类型定义transfer-length 。除非发送者知道接收者能够解析该类型，否则不能使用该类型。&lt;/li&gt;
    &lt;li&gt;由服务器关闭连接确定消息长度。（注意：关闭连接不能用于确定请求消息的结束，因为服务器不能再发响应消息给客户端了。）&lt;/li&gt;
&lt;/ul&gt;
为了兼容HTTP/1.0应用程序，HTTP/1.1的请求消息体中必须包含一个合法的Content-Length头字段，除非知道服务器兼容 HTTP/1.1。一个请求包含消息体，并且Content-Length字段没有给定，如果不能判断消息的长度，服务器应该用用400 (bad request) 来响应；或者服务器坚持希望收到一个合法的Content-Length字段，用 411 (length required)来响应。&lt;/p&gt;

&lt;p&gt;所有HTTP/1.1的接收者应用程序必须接受“chunked” transfer-coding (传输编码)，因此当不能事先知道消息的长度，允许使用这种机制来传输消息。消息不应该够同时包含 Content-Length头字段和non-identity transfer-coding。如果一个消息同时包含non-identity transfer-coding和Content-Length ，必须忽略Content-Length 。
&lt;h1&gt;5、HTTP头字段总结&lt;/h1&gt;
最后我总结下HTTP协议的头部字段。
&lt;ul&gt;
    &lt;li&gt;1、 Accept：告诉WEB服务器自己接受什么介质类型，&lt;em&gt;/&lt;/em&gt; 表示任何类型，type/* 表示该类型下的所有子类型，type/sub-type。&lt;/li&gt;
    &lt;li&gt;2、 Accept-Charset： 浏览器申明自己接收的字符集
Accept-Encoding： 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate）
Accept-Language：浏览器申明自己接收的语言
语言跟字符集的区别：中文是语言，中文有多种字符集，比如big5，gb2312，gbk等等。&lt;/li&gt;
    &lt;li&gt;3、 Accept-Ranges：WEB服务器表明自己是否接受获取其某个实体的一部分（比如文件的一部分）的请求。bytes：表示接受，none：表示不接受。&lt;/li&gt;
    &lt;li&gt;4、 Age：当代理服务器用自己缓存的实体去响应请求时，用该头部表明该实体从产生到现在经过多长时间了。&lt;/li&gt;
    &lt;li&gt;5、 Authorization：当客户端接收到来自WEB服务器的 WWW-Authenticate 响应时，用该头部来回应自己的身份验证信息给WEB服务器。&lt;/li&gt;
    &lt;li&gt;6、 Cache-Control：请求：no-cache（不要缓存的实体，要求现在从WEB服务器去取）
max-age：（只接受 Age 值小于 max-age 值，并且没有过期的对象）
max-stale：（可以接受过去的对象，但是过期时间必须小于 max-stale 值）
min-fresh：（接受其新鲜生命期大于其当前 Age 跟 min-fresh 值之和的缓存对象）
响应：public(可以用 Cached 内容回应任何用户)
private（只能用缓存内容回应先前请求该内容的那个用户）
no-cache（可以缓存，但是只有在跟WEB服务器验证了其有效后，才能返回给客户端）
max-age：（本响应包含的对象的过期时间）
ALL: no-store（不允许缓存）&lt;/li&gt;
    &lt;li&gt;7、 Connection：请求：close（告诉WEB服务器或者代理服务器，在完成本次请求的响应后，断开连接，不要等待本次连接的后续请求了）。
keepalive（告诉WEB服务器或者代理服务器，在完成本次请求的响应后，保持连接，等待本次连接的后续请求）。
响应：close（连接已经关闭）。
keepalive（连接保持着，在等待本次连接的后续请求）。
Keep-Alive：如果浏览器请求保持连接，则该头部表明希望 WEB 服务器保持连接多长时间（秒）。例如：Keep-Alive：300&lt;/li&gt;
    &lt;li&gt;8、 Content-Encoding：WEB服务器表明自己使用了什么压缩方法（gzip，deflate）压缩响应中的对象。例如：Content-Encoding：gzip&lt;/li&gt;
    &lt;li&gt;9、Content-Language：WEB 服务器告诉浏览器自己响应的对象的语言。&lt;/li&gt;
    &lt;li&gt;10、Content-Length： WEB 服务器告诉浏览器自己响应的对象的长度。例如：Content-Length: 26012&lt;/li&gt;
    &lt;li&gt;11、Content-Range： WEB 服务器表明该响应包含的部分对象为整个对象的哪个部分。例如：Content-Range: bytes 21010-&lt;sup&gt;47021&lt;/sup&gt;&amp;frasl;&lt;sub&gt;47022&lt;/sub&gt;&lt;/li&gt;
    &lt;li&gt;12、Content-Type： WEB 服务器告诉浏览器自己响应的对象的类型。例如：Content-Type：application/xml&lt;/li&gt;
    &lt;li&gt;13、ETag：就是一个对象（比如URL）的标志值，就一个对象而言，比如一个 html 文件，如果被修改了，其 Etag 也会别修改，所以ETag 的作用跟 Last-Modified 的作用差不多，主要供 WEB 服务器判断一个对象是否改变了。比如前一次请求某个 html 文件时，获得了其 ETag，当这次又请求这个文件时，浏览器就会把先前获得的 ETag 值发送给WEB 服务器，然后 WEB 服务器会把这个 ETag 跟该文件的当前 ETag 进行对比，然后就知道这个文件有没有改变了。&lt;/li&gt;
    &lt;li&gt;14、 Expired：WEB服务器表明该实体将在什么时候过期，对于过期了的对象，只有在跟WEB服务器验证了其有效性后，才能用来响应客户请求。是 HTTP/1.0 的头部。例如：Expires：Sat, 23 May 2009 10:02:12 GMT&lt;/li&gt;
    &lt;li&gt;15、 Host：客户端指定自己想访问的WEB服务器的域名/IP 地址和端口号。例如：Host：rss.sina.com.cn&lt;/li&gt;
    &lt;li&gt;16、 If-Match：如果对象的 ETag 没有改变，其实也就意味著对象没有改变，才执行请求的动作。&lt;/li&gt;
    &lt;li&gt;17、 If-None-Match：如果对象的 ETag 改变了，其实也就意味著对象也改变了，才执行请求的动作。&lt;/li&gt;
    &lt;li&gt;18、 If-Modified-Since：如果请求的对象在该头部指定的时间之后修改了，才执行请求的动作（比如返回对象），否则返回代码304，告诉浏览器 该对象没有修改。例如：If-Modified-Since：Thu, 10 Apr 2008 09:14:42 GMT&lt;/li&gt;
    &lt;li&gt;19、 If-Unmodified-Since：如果请求的对象在该头部指定的时间之后没修改过，才执行请求的动作（比如返回对象）。&lt;/li&gt;
    &lt;li&gt;20、 If-Range：浏览器告诉 WEB 服务器，如果我请求的对象没有改变，就把我缺少的部分给我，如果对象改变了，就把整个对象给我。浏览器通过发送请求对象的 ETag 或者 自己所知道的最后修改时间给 WEB 服务器，让其判断对象是否改变了。总是跟 Range 头部一起使用。&lt;/li&gt;
    &lt;li&gt;21、 Last-Modified：WEB 服务器认为对象的最后修改时间，比如文件的最后修改时间，动态页面的最后产生时间等等。例如：Last-Modified：Tue, 06 May 2008 02:42:43 GMT&lt;/li&gt;
    &lt;li&gt;22、 Location：WEB 服务器告诉浏览器，试图访问的对象已经被移到别的位置了，到该头部指定的位置去取。例如：Location：&lt;a href=&#34;http://i0.sinaimg.cn/dy/deco/2008/0528/sinahome_0803_ws_005_text_0.gif&#34;&gt;http://i0.sinaimg.cn/dy/deco/2008/0528/sinahome_0803_ws_005_text_0.gif&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;23、 Pramga：主要使用 Pramga: no-cache，相当于 Cache-Control： no-cache。例如：Pragma：no-cache&lt;/li&gt;
    &lt;li&gt;24、 Proxy-Authenticate： 代理服务器响应浏览器，要求其提供代理身份验证信息。Proxy-Authorization：浏览器响应代理服务器的身份验证请求，提供自己的身份信息。&lt;/li&gt;
    &lt;li&gt;25、 Range：浏览器（比如 Flashget 多线程下载时）告诉 WEB 服务器自己想取对象的哪部分。例如：Range: bytes=1173546-&lt;/li&gt;
    &lt;li&gt;26、 Referer：浏览器向 WEB 服务器表明自己是从哪个 网页/URL 获得/点击 当前请求中的网址/URL。例如：Referer：&lt;a href=&#34;http://www.sina.com/&#34;&gt;http://www.sina.com/&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;27、 Server: WEB 服务器表明自己是什么软件及版本等信息。例如：Server：Apache/2.0.61 (Unix)&lt;/li&gt;
    &lt;li&gt;28、 User-Agent: 浏览器表明自己的身份（是哪种浏览器）。例如：User-Agent：Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.8.1.14) Gecko/20080404 Firefox/2、0、0、14&lt;/li&gt;
    &lt;li&gt;29、 Transfer-Encoding: WEB 服务器表明自己对本响应消息体（不是消息体里面的对象）作了怎样的编码，比如是否分块（chunked）。例如：Transfer-Encoding: chunked&lt;/li&gt;
    &lt;li&gt;30、 Vary: WEB服务器用该头部的内容告诉 Cache 服务器，在什么条件下才能用本响应所返回的对象响应后续的请求。假如源WEB服务器在接到第一个请求消息时，其响应消息的头部为：Content- Encoding: gzip; Vary: Content-Encoding那么 Cache 服务器会分析后续请求消息的头部，检查其 Accept-Encoding，是否跟先前响应的 Vary 头部值一致，即是否使用相同的内容编码方法，这样就可以防止 Cache 服务器用自己 Cache 里面压缩后的实体响应给不具备解压能力的浏览器。例如：Vary：Accept-Encoding&lt;/li&gt;
    &lt;li&gt;31、 Via： 列出从客户端到 OCS 或者相反方向的响应经过了哪些代理服务器，他们用什么协议（和版本）发送的请求。当客户端请求到达第一个代理服务器时，该服务器会在自己发出的请求里面添 加 Via 头部，并填上自己的相关信息，当下一个代理服务器收到第一个代理服务器的请求时，会在自己发出的请求里面复制前一个代理服务器的请求的Via 头部，并把自己的相关信息加到后面，以此类推，当 OCS 收到最后一个代理服务器的请求时，检查 Via 头部，就知道该请求所经过的路由。例如：Via：1.0 236.D0707195.sina.com.cn:80 (squid/2.6.STABLE13)&lt;/li&gt;&lt;/p&gt;

&lt;h1 id=&#34;toc_0&#34;&gt;&lt;/ul&gt;&lt;/h1&gt;

&lt;p&gt;HTTP 请求消息头部实例：
Host：rss.sina.com.cn
User-Agent：Mozilla/5、0 (Windows; U; Windows NT 5、1; zh-CN; rv:1、8、1、14) Gecko/20080404 Firefox/2、0、0、14
Accept：text/xml,application/xml,application/xhtml+xml,text/html;q=0、9,text/plain;q=0、8,image/png,&lt;em&gt;/&lt;/em&gt;;q=0、5
Accept-Language：zh-cn,zh;q=0、5
Accept-Encoding：gzip,deflate
Accept-Charset：gb2312,utf-8;q=0、7,*;q=0、7
Keep-Alive：300
Connection：keep-alive
Cookie：userId=C5bYpXrimdmsiQmsBPnE1Vn8ZQmdWSm3WRlEB3vRwTnRtW &amp;amp;lt;&amp;ndash; Cookie
If-Modified-Since：Sun, 01 Jun 2008 12:05:30 GMT
Cache-Control：max-age=0
HTTP 响应消息头部实例：
Status：OK - 200 &amp;amp;lt;&amp;ndash; 响应状态码，表示 web 服务器处理的结果。
Date：Sun, 01 Jun 2008 12:35:47 GMT
Server：Apache/2、0、61 (Unix)
Last-Modified：Sun, 01 Jun 2008 12:35:30 GMT
Accept-Ranges：bytes
Content-Length：18616
Cache-Control：max-age=120
Expires：Sun, 01 Jun 2008 12:37:47 GMT
Content-Type：application/xml
Age：2
X-Cache：HIT from 236-41、D07071951、sina、com、cn &amp;amp;lt;&amp;ndash; 反向代理服务器使用的 HTTP 头部
Via：1.0 236-41.D07071951.sina.com.cn:80 (squid/2.6.STABLE13)
Connection：close&lt;/p&gt;

&lt;p&gt;本节摘自：&lt;a href=&#34;http://ynhu33.blog.51cto.com/412835/408801&#34;&gt;http://ynhu33.blog.51cto.com/412835/408801&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;——最后我想说：“怪自己学艺不精，浪费了一次机会（而且是我最想进的公司）”&lt;/p&gt;

&lt;p&gt;希望老天再给我一次机会。&lt;/p&gt;

&lt;p&gt;PS：还有一点加速了我的死亡，我学习过&lt;a href=&#34;http://www.cnblogs.com/skynet/category/241385.html&#34; target=&#34;_blank&#34;&gt;Android开发&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;但是用的是JAVA，经理说研究Android开发就得用NDK，那才是核心。&lt;/p&gt;

&lt;p&gt;&lt;/div&gt;
&lt;div id=&#34;MySignature&#34;&gt;&lt;/p&gt;

&lt;p&gt;作者：吴秦
出处：&lt;a href=&#34;http://www.cnblogs.com/skynet/&#34;&gt;http://www.cnblogs.com/skynet/&lt;/a&gt;
本文基于&lt;a href=&#34;http://creativecommons.org/licenses/by/2.5/cn/&#34; target=&#34;_blank&#34;&gt;署名 2.5 中国大陆&lt;/a&gt;许可协议发布，欢迎转载，演绎或用于商业目的，但是必须保留本文的署名&lt;a href=&#34;http://www.cnblogs.com/skynet/&#34; target=&#34;_blank&#34;&gt;吴秦&lt;/a&gt;（包含链接）.&lt;/p&gt;

&lt;p&gt;—————————————————————————————————————————————————————————————————&lt;/p&gt;

&lt;p&gt;全文到此为止。。。&lt;/p&gt;

&lt;p&gt;&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>C#调用C&#43;&#43;DLL--委托</title>
      <link>http://www.daniex.tk/blog/2011/c-calling-c-dll-commissioned/</link>
      <pubDate>Tue, 21 Jun 2011 09:01:38 &#43;0000</pubDate>
      <author>Daniex</author>
      <guid>http://www.daniex.tk/blog/2011/c-calling-c-dll-commissioned/</guid>
      <description>&lt;p&gt;直接上代码，ref类型参数传递也是可以的。和之前一篇用反射调用可以互相参考。&lt;span style=&#34;text-decoration: underline;&#34;&gt;&lt;em&gt;&lt;a title=&#34;C#调用C++写的DLL--反射&#34; href=&#34;http://daniex.info/c-call-dll-written-in-c.html&#34; target=&#34;_blank&#34;&gt;C#调用C++DLL&amp;ndash;反射&lt;/a&gt;&lt;/em&gt;&lt;/span&gt;
&lt;pre class=&#34;brush: csharp&#34;&gt;using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;&lt;/p&gt;

&lt;p&gt;using System.Runtime.InteropServices;&lt;/p&gt;

&lt;p&gt;namespace Test
{
    class DLLLoader
    {
            [DllImport(&amp;ldquo;kernel32.dll&amp;rdquo;)]
            public extern static IntPtr LoadLibrary(string path);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        [DllImport(&amp;quot;kernel32.dll&amp;quot;)]
        public extern static IntPtr GetProcAddress(IntPtr lib, string funcName);

        [DllImport(&amp;quot;kernel32.dll&amp;quot;)]
        public extern static bool FreeLibrary(IntPtr lib);

        [DllImport(&amp;quot;kernel32.dll&amp;quot;)]
        public static extern IntPtr GetStdHandle(int nStdHandle);

        [DllImport(&amp;quot;user32&amp;quot;, EntryPoint = &amp;quot;CallWindowProc&amp;quot;)]
        public static extern int CallWindowProc(IntPtr lpPrevWndFunc, int hwnd, int MSG, int wParam, int lParam);

        IntPtr DllLib;//DLL文件名柄     
        #region 构造函数
        public DLLLoader()
        { }
        public DLLLoader(string dllpath)
        {
            DllLib = LoadLibrary(dllpath);
        }
        #endregion
        ///      
        /// 析构函数     
        ///      
        ~DLLLoader()
        {
            FreeLibrary(DllLib);//释放名柄     
        }
        public void initPath(string dllpath)
        {
            if (DllLib == IntPtr.Zero)
            {
                DllLib = LoadLibrary(dllpath);
            }
        }
        ///      
        /// 获取ＤＬＬ中一个方法的委托     
        ///      
        /// &amp;lt;param name=&amp;quot;methodname&amp;quot; /&amp;gt;     
        /// &amp;lt;param name=&amp;quot;methodtype&amp;quot; /&amp;gt;     
        ///      
        public Delegate InvokeMethod(string methodname, Type methodtype)
        {
            IntPtr MethodPtr = GetProcAddress(DllLib, methodname);

            return (Delegate)Marshal.GetDelegateForFunctionPointer(MethodPtr, methodtype);
        }      

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;*********&lt;strong&gt;&lt;em&gt;调用&lt;/em&gt;&lt;/strong&gt;************
        DLLLoader loaddll = new DLLLoader(&amp;ldquo;E:\workspaces\WpfApplication1\Debug\DLL.dll&amp;rdquo;);//实例化加载ＤＬＬ文件的类，，如上&lt;br /&gt;
        public delegate int delegateadd(ref int a);//声明此方法的一个委托&lt;/p&gt;

&lt;p&gt;public void testMethod()
{
        int a = 1;
        delegateadd m = (delegateadd)loaddll.InvokeMethod(&amp;ldquo;add&amp;rdquo;, typeof(delegateadd));//获取其中方法的委托&lt;br /&gt;
        int re = m(ref a);//得到ＲＥ，成功&lt;br /&gt;
}&lt;/p&gt;

&lt;p&gt;***********&lt;strong&gt;&lt;em&gt;DLL&lt;/em&gt;&lt;/strong&gt;***********
extern &amp;ldquo;C&amp;rdquo; __declspec(dllexport) int add(int &amp;amp; a);&lt;/p&gt;

&lt;p&gt;int add(int &amp;amp; a)
{
    a = 10;
    return 20;
}
&lt;/pre&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>C#调用C&#43;&#43;写的DLL</title>
      <link>http://www.daniex.tk/blog/2011/c-call-dll-written-in-c/</link>
      <pubDate>Thu, 12 May 2011 06:48:53 &#43;0000</pubDate>
      <author>Daniex</author>
      <guid>http://www.daniex.tk/blog/2011/c-call-dll-written-in-c/</guid>
      <description>&lt;p&gt;方法有不少，这里记录其中的一个方法。编译、调用通过了的。期间遇到的问题是C#调用时传递string类型的参数和返回值会报错。TargetInvocationException异常，值不在范围内，内存不可访问等等。&lt;/p&gt;

&lt;p&gt;解决方法是；在c++的DLL中将string类型的参数返回值改为LPTSTR类型。在C#程序中使用StringBuilder类型来传入参数和接受返回值。&lt;/p&gt;

&lt;p&gt;下面是代码：
&lt;pre class=&#34;brush: csharp&#34;&gt;using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;&lt;/p&gt;

&lt;p&gt;//1.       打开项目“Tzb”，打开类视图，右击“Tzb”，选择“添加”&amp;ndash;&amp;gt;“类”，类名设置为“dld”，
//即dynamic loading dll 的每个单词的开头字母。
//2.       添加所需的命名空间及声明参数传递方式枚举：
using System.Runtime.InteropServices; // 用 DllImport 需用此 命名空间
using System.Reflection; // 使用 Assembly 类需用此 命名空间
using System.Reflection.Emit; // 使用 ILGenerator 需用此 命名空间&lt;/p&gt;

&lt;p&gt;namespace WpfApplication1
{
    //在“public class dld”上面添加如下代码声明参数传递方式枚举：
    ///
    /// 参数传递方式枚举 ,ByValue 表示值传递 ,ByRef 表示址传递
    ///&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public enum ModePass
{
    ByValue = 0x0001,
    ByRef = 0x0002
}
public class DLD
{      

    //3.       声明LoadLibrary、GetProcAddress、FreeLibrary及私有变量hModule和farProc：        
    /// 
    /// 原型是 :HMODULE LoadLibrary(LPCTSTR lpFileName);
    /// 
    /// &amp;lt; param name=&amp;quot;lpFileName&amp;quot; / &amp;gt;DLL 文件名 
    ///  函数库模块的句柄 
    [DllImport(&amp;quot;kernel32.dll&amp;quot;)]
    static extern IntPtr LoadLibrary(string lpFileName);

    /// 
    /// 原型是 : FARPROC GetProcAddress(HMODULE hModule, LPCWSTR lpProcName);
    /// 
    /// &amp;lt; param name=&amp;quot;hModule&amp;quot; / &amp;gt; 包含需调用函数的函数库模块的句柄 
    /// &amp;lt; param name=&amp;quot;lpProcName&amp;quot; / &amp;gt; 调用函数的名称 
    ///  函数指针 

    [DllImport(&amp;quot;kernel32.dll&amp;quot;)]
    static extern IntPtr GetProcAddress(IntPtr hModule, string lpProcName);

    /// 
    /// 原型是 : BOOL FreeLibrary(HMODULE hModule);
    /// 
    /// &amp;lt; param name=&amp;quot;hModule&amp;quot; / &amp;gt; 需释放的函数库模块的句柄 
    ///  是否已释放指定的 Dll

    [DllImport(&amp;quot;kernel32&amp;quot;, EntryPoint = &amp;quot;FreeLibrary&amp;quot;, SetLastError = true)]
    static extern bool FreeLibrary(IntPtr hModule);

    /// 
    /// Loadlibrary 返回的函数库模块的句柄
    /// 

    private IntPtr hModule = IntPtr.Zero;

    /// 
    /// GetProcAddress 返回的函数指针
    /// 

    public IntPtr farProc = IntPtr.Zero;


    //4.       添加LoadDll方法，并为了调用时方便，重载了这个方法：
    /// 
    /// 装载 Dll
    /// 
    /// &amp;lt; param name=&amp;quot;lpFileName&amp;quot; / &amp;gt;DLL 文件名 

    public void LoadDll(string lpFileName)
    {

        hModule = LoadLibrary(lpFileName);
        if (hModule == IntPtr.Zero)
            throw (new Exception(&amp;quot; 没有找到 :&amp;quot; + lpFileName + &amp;quot;.&amp;quot;));
    }


    //         若已有已装载Dll的句柄，可以使用LoadDll方法的第二个版本：
    public void LoadDll(IntPtr HMODULE)
    {
        if (HMODULE == IntPtr.Zero)
            throw (new Exception(&amp;quot; 所传入的函数库模块的句柄 HMODULE 为空 .&amp;quot;));
        hModule = HMODULE;
    }


    //5.       添加LoadFun方法，并为了调用时方便，也重载了这个方法，方法的具体代码及注释如下：
    /// 
    /// 获得函数指针
    /// 
    /// &amp;lt; param name=&amp;quot;lpProcName&amp;quot; / &amp;gt; 调用函数的名称 

    public void LoadFun(string lpProcName)
    { // 若函数库模块的句柄为空，则抛出异常

        if (hModule == IntPtr.Zero)
            throw (new Exception(&amp;quot; 函数库模块的句柄为空 , 请确保已进行 LoadDll 操作 !&amp;quot;));
        // 取得函数指针
        farProc = GetProcAddress(hModule, lpProcName);

        // 若函数指针，则抛出异常
        if (farProc == IntPtr.Zero)
            throw (new Exception(&amp;quot; 没有找到 : &amp;quot; + lpProcName + &amp;quot; 这个函数的入口点 &amp;quot;));

    }

    /// 
    /// 获得函数指针
    /// 
    /// &amp;lt; param name=&amp;quot;lpFileName&amp;quot; / &amp;gt; 包含需调用函数的 DLL 文件名 
    /// &amp;lt; param name=&amp;quot;lpProcName&amp;quot; / &amp;gt; 调用函数的名称 

    public void LoadFun(string lpFileName, string lpProcName)
    { // 取得函数库模块的句柄
        hModule = LoadLibrary(lpFileName);

        // 若函数库模块的句柄为空，则抛出异常
        if (hModule == IntPtr.Zero)
            throw (new Exception(&amp;quot; 没有找到 :&amp;quot; + lpFileName + &amp;quot;.&amp;quot;));

        // 取得函数指针
        farProc = GetProcAddress(hModule, lpProcName);

        // 若函数指针，则抛出异常
        if (farProc == IntPtr.Zero)
            throw (new Exception(&amp;quot; 没有找到 :&amp;quot; + lpProcName + &amp;quot; 这个函数的入口点 &amp;quot;));

    }


    //6.  添加UnLoadDll及Invoke方法，Invoke方法也进行了重载：
    /// 
    /// 卸载 Dll
    /// 

    public void UnLoadDll()
    {
        FreeLibrary(hModule);
        hModule = IntPtr.Zero;
        farProc = IntPtr.Zero;
    }

    /// 
    /// 调用所设定的函数
    /// 
    /// &amp;lt; param name=&amp;quot;ObjArray_Parameter&amp;quot; / &amp;gt; 实参 
    /// &amp;lt; param name=&amp;quot;TypeArray_ParameterType&amp;quot; / &amp;gt; 实参类型 
    /// &amp;lt; param name=&amp;quot;ModePassArray_Parameter&amp;quot; / &amp;gt; 实参传送方式 
    /// &amp;lt; param name=&amp;quot;Type_Return&amp;quot; / &amp;gt; 返回类型 
    ///  返回所调用函数的 object

    public object Invoke(object[] ObjArray_Parameter, Type[] TypeArray_ParameterType, 
                             ModePass[] ModePassArray_Parameter, Type Type_Return)
    {

        // 下面 3 个 if 是进行安全检查 , 若不能通过 , 则抛出异常
        if (hModule == IntPtr.Zero)
            throw (new Exception(&amp;quot; 函数库模块的句柄为空 , 请确保已进行 LoadDll 操作 !&amp;quot;));
        if (farProc == IntPtr.Zero)
            throw (new Exception(&amp;quot; 函数指针为空 , 请确保已进行 LoadFun 操作 !&amp;quot;));
        if (ObjArray_Parameter.Length != ModePassArray_Parameter.Length)
            throw (new Exception(&amp;quot; 参数个数及其传递方式的个数不匹配 .&amp;quot;));

        // 下面是创建 MyAssemblyName 对象并设置其 Name 属性
        AssemblyName MyAssemblyName = new AssemblyName();
        MyAssemblyName.Name = &amp;quot;InvokeFun&amp;quot;;

        // 生成单模块配件
        AssemblyBuilder MyAssemblyBuilder = AppDomain.CurrentDomain.DefineDynamicAssembly(
                                                   MyAssemblyName, AssemblyBuilderAccess.Run);
        ModuleBuilder MyModuleBuilder = MyAssemblyBuilder.DefineDynamicModule(&amp;quot;InvokeDll&amp;quot;);

        // 定义要调用的方法 , 方法名为“ MyFun ”，返回类型是“ Type_Return ”
        //参数类型是“ TypeArray_ParameterType ”
        MethodBuilder MyMethodBuilder = MyModuleBuilder.DefineGlobalMethod(
                                      &amp;quot;Init&amp;quot;, MethodAttributes.Public | MethodAttributes.Static, 
                                      Type_Return, TypeArray_ParameterType);

        // 获取一个 ILGenerator ，用于发送所需的 IL
        ILGenerator IL = MyMethodBuilder.GetILGenerator();

        int i;
        for (i = 0; i &amp;amp;lt; ObjArray_Parameter.Length; i++)
        {// 用循环将参数依次压入堆栈
            switch (ModePassArray_Parameter[i])
            {
                case ModePass.ByValue:
                    IL.Emit(OpCodes.Ldarg, i);
                    break;
                case ModePass.ByRef:
                    IL.Emit(OpCodes.Ldarga, i);
                    break;
                default:
                    throw (new Exception(&amp;quot; 第 &amp;quot; + (i + 1).ToString() + &amp;quot; 个参数没有给定正确的传递方式 .&amp;quot;));
            }
        }

        if (IntPtr.Size == 4)
        {// 判断处理器类型
            IL.Emit(OpCodes.Ldc_I4, farProc.ToInt32());
        }
        else if (IntPtr.Size == 8 )
        {
            IL.Emit(OpCodes.Ldc_I8, farProc.ToInt64());
        }
        else
        {
            throw new PlatformNotSupportedException();
        }

        IL.EmitCalli(OpCodes.Calli, CallingConvention.StdCall, Type_Return, TypeArray_ParameterType);
        IL.Emit(OpCodes.Ret); // 返回值
        MyModuleBuilder.CreateGlobalFunctions();

        // 取得方法信息
        MethodInfo MyMethodInfo = MyModuleBuilder.GetMethod(&amp;quot;Init&amp;quot;);
        return MyMethodInfo.Invoke(null, ObjArray_Parameter);// 调用方法，并返回其值
    }



    //Invoke方法的第二个版本，它是调用了第一个版本的：
    /// 
    /// 调用所设定的函数
    /// 
    /// &amp;lt; param name=&amp;quot;IntPtr_Function&amp;quot; / &amp;gt; 函数指针 
    /// &amp;lt; param name=&amp;quot;ObjArray_Parameter&amp;quot; / &amp;gt; 实参 
    /// &amp;lt; param name=&amp;quot;TypeArray_ParameterType&amp;quot; / &amp;gt; 实参类型 
    /// &amp;lt; param name=&amp;quot;ModePassArray_Parameter&amp;quot; / &amp;gt; 实参传送方式 
    /// &amp;lt; param name=&amp;quot;Type_Return&amp;quot; / &amp;gt; 返回类型 
    ///  返回所调用函数的 object

    public object Invoke(IntPtr IntPtr_Function, object[] ObjArray_Parameter, 
                           Type[] TypeArray_ParameterType, ModePass[] ModePassArray_Parameter, 
                           Type Type_Return)
    {

        // 下面 2 个 if 是进行安全检查 , 若不能通过 , 则抛出异常
        if (hModule == IntPtr.Zero)
            throw (new Exception(&amp;quot; 函数库模块的句柄为空 , 请确保已进行 LoadDll 操作 !&amp;quot;));
        if (IntPtr_Function == IntPtr.Zero)
            throw (new Exception(&amp;quot; 函数指针 IntPtr_Function 为空 !&amp;quot;));
        farProc = IntPtr_Function;
        return Invoke(ObjArray_Parameter, TypeArray_ParameterType, ModePassArray_Parameter, Type_Return);
    }            

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
&lt;/pre&gt;
&lt;pre class=&#34;brush: csharp&#34;&gt;/****&lt;strong&gt;&lt;em&gt;调用方法&lt;/em&gt;&lt;/strong&gt;***/
        private void button1_Click(object sender, RoutedEventArgs e)
        {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        DLD newDLL = new DLD();
        newDLL.LoadFun(&amp;quot;E:\\workspaces\\WpfApplication1\\Debug\\DLL.dll&amp;quot;, &amp;quot;Init&amp;quot;);
        StringBuilder MyStringBuilder = new StringBuilder(&amp;quot;Hello World!&amp;quot;);
        object[] obj = new object[] { MyStringBuilder };
        Type[] ty = new Type[] { typeof(StringBuilder) };
        ModePass[] mode = new ModePass[] { ModePass.ByValue };
        Type Type_Return = typeof(StringBuilder);
        StringBuilder j = (StringBuilder)newDLL.Invoke(obj, ty, mode, Type_Return);

    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;/*****&lt;strong&gt;&lt;em&gt;c++DLL中的函数&lt;/em&gt;&lt;/strong&gt;****/&lt;/p&gt;

&lt;p&gt;extern &amp;ldquo;C&amp;rdquo; __declspec(dllexport) LPTSTR Init(LPTSTR a);&lt;/p&gt;

&lt;p&gt;LPTSTR Init(LPTSTR a)
{
    strcat((char *)a, &amp;ldquo;added&amp;rdquo;);
    return a;
}
&lt;/pre&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>