<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Java on Daniex </title>
      <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>http://www.daniex.tk/tags/java/index.xml/</link>
    <language>zh-cn</language>
    <author>Daniex</author>
    
    <updated>Fri, 27 Jan 2012 11:58:33 &#43;0000</updated>
    
    <item>
      <title>使用JavaMail API</title>
      <link>http://www.daniex.tk/blog/2012/the-javamail-api/</link>
      <pubDate>Fri, 27 Jan 2012 11:58:33 &#43;0000</pubDate>
      <author>Daniex</author>
      <guid>http://www.daniex.tk/blog/2012/the-javamail-api/</guid>
      <description>&lt;p&gt;使用JavaMail API，接上文&lt;a title=&#34;javax.mail.internet API 学习&#34; href=&#34;http://daniex.info/javax-mail-internet-api.html&#34; target=&#34;_blank&#34;&gt;&lt;span style=&#34;color: #3366ff;&#34;&gt;javax.mail.internet api 学习&lt;/span&gt;
&lt;/a&gt;1．发送邮件
在获得了Session后，建立并填入邮件信息，然后发送它到邮件服务器。这便是使用Java Mail API发送邮件的过程，在发送邮件之前，我们需要设置SMTP服务器：通过设置Properties的mail.smtp.host属性。
&lt;blockquote&gt;String host = &amp;hellip;;
String from = &amp;hellip;;
String to = &amp;hellip;;
// Get system properties
Properties props = System.getProperties();
// Setup mail server
props.put(&amp;ldquo;mail.smtp.host&amp;rdquo;, host);
// Get session
Session session = Session.getDefaultInstance(props, null);// Define message
MimeMessage message = new MimeMessage(session);
message.setFrom(new InternetAddress(from));message.addRecipient(Message.RecipientType.TO,   new InternetAddress(to));message.setSubject(&amp;ldquo;Hello JavaMail&amp;rdquo;);
message.setText(&amp;ldquo;Welcome to JavaMail&amp;rdquo;);
// Send message
Transport.send(message);&lt;/blockquote&gt;
由于建立邮件信息和发送邮件的过程中可能会抛出异常，所以我们需要将上面的代码放入到try-catch结构块中。
2．接收邮件
为了在读取邮件，我们获得了session，并且连接到了邮箱的相应store，打开相应的Folder，然后得到我们想要的邮件，当然别忘记了在结束时关闭连接。
&lt;blockquote&gt;String host = &amp;hellip;;
String username = &amp;hellip;;
String password = &amp;hellip;;
// Create empty properties
Properties props = new Properties();
// Get session
Session session = Session.getDefaultInstance(props, null);
// Get the store
Store store = session.getStore(&amp;ldquo;pop3&amp;rdquo;);
store.connect(host, username, password);
// Get folder
Folder folder = store.getFolder(&amp;ldquo;INBOX&amp;rdquo;);
folder.open(Folder.READ_ONLY);
// Get directory
Message message[] = folder.getMessages();
for (int i=0, n=message.length; i++)&amp;hellip;&lt;/blockquote&gt;
上面的代码所作的是从邮箱中读取每个邮件，并且显示邮件的发信人地址和主题。从技术角度讲，这里存在着一个异常的可能：当发信人地址为空时，getFrom()[0]将抛出异常。&lt;/p&gt;

&lt;p&gt;下 面的代码片断有效的说明了如何读取邮件内容，在显示每个邮件发信人和主题后，将出现用户提示从而得到用户是否读取该邮件的确认，如果输入YES的话，我们 可用Message.writeTo(java.io.OutputStream os)方法将邮件内容输出到控制台上，关于 Message.writeTo()的具体用法请看JavaMail API。
&lt;blockquote&gt;BufferedReader reader = new BufferedReader (  new InputStreamReader(System.in));
// Get directory
Message message[] = folder.getMessages();
for (int i=0, n=message.length; i&amp;hellip;&lt;/blockquote&gt;
3．删除邮件和标志
设置与message相关的Flags是删除邮件的常用方法。这些Flags表示了一些系统定义和用户定义的不同状态。在Flags类的内部类Flag中预定义了一些标志：
&lt;blockquote&gt;Flags.Flag.ANSWERED
Flags.Flag.DELETED
Flags.Flag.DRAFT
Flags.Flag.FLAGGED
Flags.Flag.RECENT
Flags.Flag.SEEN
Flags.Flag.USER&lt;/blockquote&gt;
但 需要在使用时注意的：标志存在并非意味着这个标志被所有的邮件服务器所支持。例如，对于删除邮件的操作，POP协议不支持上面的任何一个。所以要确定哪些 标志是被支持的??通过访问一个已经打开的Folder对象的getPermanetFlags()方法，它将返回当前被支持的Flags类对象。
删除邮件时，我们可以设置邮件的DELETED标志：
&lt;blockquote&gt;message.setFlag(Flags.Flag.DELETED, true);&lt;/blockquote&gt;
但是首先要采用READ_WRITE的方式打开Folder：
&lt;blockquote&gt;folder.open(Folder.READ_WRITE);&lt;/blockquote&gt;
在对邮件进行删除操作后关闭Folder时，需要传递一个true作为对删除邮件的擦除确认。
&lt;blockquote&gt;folder.close(true);&lt;/blockquote&gt;
Folder类中另一种用于删除邮件的方法expunge()也同样可删除邮件，但是它并不为sun提供的POP3实现支持，而其它第三方提供的POP3实现支持或者并不支持这种方法。
另外，介绍一种检查某个标志是否被设置的方法：Message.isSet(Flags.Flag flag)方法，其中参数为被检查的标志。&lt;/p&gt;

&lt;p&gt;4．邮件认证
我 们在前面已经学会了如何使用Authenticator类来代替直接使用用户名和密码这两字符串作为 Session.getDefaultInstance()或者Session.getInstance()方法的参数。在前面的小试牛刀后，现在我们将 了解到全面认识一下邮件认证。
我们在此取代了直接使用邮件服务器主机名、用户名、密码这三个字符串作为连接到POP3 Store的方式，使用存储了邮件服务器主机名信息的属性文件，并在获得Session时传入自定义的Authenticator实例：
&lt;blockquote&gt;// Setup properties
Properties props = System.getProperties();
props.put(&amp;ldquo;mail.pop3.host&amp;rdquo;, host);
// Setup authentication, get session
Authenticator auth = new PopupAuthenticator();
Session session = Session.getDefaultInstance(props, auth);
// Get the store
Store store = session.getStore(&amp;ldquo;pop3&amp;rdquo;);
store.connect();&lt;/blockquote&gt;
PopupAuthenticator 类继承了抽象类Authenticator，并且通过重载Authenticator类的getPasswordAuthentication()方法返 回PasswordAuthentication类对象。而getPasswordAuthentication()方法的参数param是以逗号分割的 用户名、密码组成的字符串。
&lt;blockquote&gt;import javax.mail.&lt;em&gt;;
import java.util.&lt;/em&gt;;&lt;/p&gt;

&lt;p&gt;public class PopupAuthenticator extends Authenticator {
public PasswordAuthentication getPasswordAuthentication(String param) {
String username, password;
StringTokenizer st = new StringTokenizer(param, &amp;rdquo;,&amp;ldquo;);
username = st.nextToken();
password = st.nextToken();
return new PasswordAuthentication(username, password);
}
}&lt;/blockquote&gt;
5．回复邮件
回复邮件的方法很简单：使用Message类的reply()方法，通过配 置回复邮件的收件人地址和主题（如果没有提供主题的话，系统将默认将“Re：”作为邮件的主体），这里不需要设置任何的邮件内容，只要复制发信人或者 reply-to到新的收件人。而reply()方法中的boolean参数表示是否将邮件回复给发送者（参数值为false），或是恢复给所有人（参数 值为true）。
补充一下，reply-to地址需要在发信时使用setReplyTo()方法设置。
&lt;blockquote&gt;MimeMessage reply = (MimeMessage)message.reply(false);
reply.setFrom(new InternetAddress(&amp;ldquo;president@whitehouse.gov&amp;rdquo;));
reply.setText(&amp;ldquo;Thanks&amp;rdquo;);
Transport.send(reply);&lt;/blockquote&gt;
6．转发邮件
转发邮件的过程不如前面的回复邮件那样简单，它将建立一个转发邮件，这并非一个方法就能做到。
每 个邮件是由多个部分组成，每个部分称为一个邮件体部分，是一个BodyPart类对象，对于MIME类型邮件来讲就是MimeBodyPart类对象。这 些邮件体包含在成为Multipart的容器中对于MIME类型邮件来讲就是MimeMultiPart类对象。在转发邮件时，我们建立一个文字邮件体部 分和一个被转发的文字邮件体部分，然后将这两个邮件体放到一个Multipart中。说明一下，复制一个邮件内容到另一个邮件的方法是仅复制它的 DataHandler（数据处理者）即可。这是由JavaBeans Activation Framework定义的一个类，它提供了对邮件内容的操 作命令的访问、管理了邮件内容操作，是不同的数据源和数据格式之间的一致性接口。
&lt;blockquote&gt;// Create the message to forward
Message forward = new MimeMessage(session);
// Fill in header
forward.setSubject(&amp;ldquo;Fwd: &amp;rdquo; + message.getSubject());
forward.setFrom(new InternetAddress(from));
forward.addRecipient(Message.RecipientType.TO,   new InternetAddress(to));
// Create your new message part
BodyPart messageBodyPart = new MimeBodyPart();
messageBodyPart.setText(  &amp;rdquo;Here you go with the original message:\n\n&amp;rdquo;);
// Create a multi-part to combine the parts
Multipart multipart = new MimeMultipart();
multipart.addBodyPart(messageBodyPart);
// Create and fill part for the forwarded content
messageBodyPart = new MimeBodyPart();
messageBodyPart.setDataHandler(message.getDataHandler());
// Add part to multi part
multipart.addBodyPart(messageBodyPart);
// Associate multi-part with message
forward.setContent(multipart);
// Send message
Transport.send(forward);&lt;/blockquote&gt;
7．使用附件
附件作为与邮件相关的资源经常以文本、表格、图片等格式出现，如流行的邮件客户端一样，我们可以用JavaMail API从邮件中获取附件或是发送带有附件的邮件。&lt;/p&gt;

&lt;p&gt;A．发送带有附件的邮件
发送带有附件的邮件的过程有些类似转发邮件，我们需要建立一个完整邮件的各个邮件体部分，在第一个部分（即我们的邮件内容文字）后，增加一个具有DataHandler的附件而不是在转发邮件时那样复制第一个部分的DataHandler。&lt;/p&gt;

&lt;p&gt;如果我们将文件作为附件发送，那么要建立FileDataSource类型的对象作为附件数据源；如果从URL读取数据作为附件发送，那么将要建立URLDataSource类型的对象作为附件数据源。&lt;/p&gt;

&lt;p&gt;然后将这个数据源（FileDataSource或是URLDataSource）对象作为DataHandler类构造方法的参数传入，从而建立一个DataHandler对象作为数据源的DataHandler。&lt;/p&gt;

&lt;p&gt;接着将这个DataHandler设置为邮件体部分的DataHandler。这样就完成了邮件体与附件之间的关联工作，下面的工作就是BodyPart的setFileName()方法设置附件名为原文件名。&lt;/p&gt;

&lt;p&gt;最后将两个邮件体放入到Multipart中，设置邮件内容为这个容器Multipart，发送邮件。
&lt;blockquote&gt;// Define message
Message message = new MimeMessage(session);
message.setFrom(new InternetAddress(from));
message.addRecipient(Message.RecipientType.TO,   new InternetAddress(to));
message.setSubject(&amp;ldquo;Hello JavaMail Attachment&amp;rdquo;);
// Create the message part
BodyPart messageBodyPart = new MimeBodyPart();
// Fill the message
messageBodyPart.setText(&amp;ldquo;Pardon Ideas&amp;rdquo;);
Multipart multipart = new MimeMultipart();
multipart.addBodyPart(messageBodyPart);
// Part two is attachment
messageBodyPart = new MimeBodyPart();
DataSource source = new FileDataSource(filename);
messageBodyPart.setDataHandler(new DataHandler(source));
messageBodyPart.setFileName(filename);
multipart.addBodyPart(messageBodyPart);
// Put parts in message
message.setContent(multipart);
// Send the message
Transport.send(message);&lt;/blockquote&gt;
如果我们使用servlet实现发送带有附件的邮件，则必须上传附件给servlet，这时需要注意提交页面form中对编码类型的设置应为multipart/form-data。&lt;/p&gt;

&lt;p&gt;B．读取邮件中的附件
读取邮件中的附件的过程要比发送它的过程复杂一点。因为带有附件的邮件是多部分组成的，我们必须处理每一个部分获得邮件的内容和附件。
但 是如何辨别邮件信息内容和附件呢？Sun在Part类（BodyPart类实现的接口类）中提供了getDisposition()方法让开发者获得邮件 体部分的部署类型，当该部分是附件时，其返回之将是Part.ATTACHMENT。但附件也可以没有部署类型的方式存在或者部署类型为 Part.INLINE，无论部署类型为Part.ATTACHMENT还是Part.INLINE，我们都能把该邮件体部分导出保存。
&lt;blockquote&gt;Multipart mp = (Multipart)message.getContent();
for (int i=0, n=multipart.getCount(); i&amp;hellip;&lt;/blockquote&gt;
下列代码中使用了saveFile方法是自定义的方法，它根据附件的文件名建立一个文件，如果本地磁盘上存在名为附件的文件，那么将在文件名后增加数字表示区别。然后从邮件体中读取数据写入到本地文件中（代码省略）。
&lt;blockquote&gt;// from saveFile()
File file = new File(filename);
for (int i=0; file.exists(); i++)
{
file = new File(filename+i);
}&lt;/blockquote&gt;
以上是邮件体部分被正确设置的简单例子，如果邮件体部分的部署类型为null，那么我们通过获得邮件体部分的MIME类型来判断其类型作相应的处理，代码结构框架如下：
&lt;blockquote&gt;if (disposition == null) {
// Check if plain
MimeBodyPart mbp = (MimeBodyPart)part;
if (mbp.isMimeType(&amp;ldquo;text/plain&amp;rdquo;)) {
// Handle plain
} else {
// Special non-attachment cases here of
// image/gif, text/html, .
..
}
&amp;hellip;
}&lt;/blockquote&gt;
8．处理HTML邮件
前面的例子中发送的邮件都是以文本为内容的（除了附件），下面将介绍如何接收和发送基于HTML的邮件。
A．发送HTML邮件
假如我们需要发送一个HTML文件作为邮件内容，并使邮件客户端在读取邮件时获取相关的图片或者文字的话，只要设置邮件内容为html代码，并设置内容类型为text/html即可：
&lt;blockquote&gt;String htmlText = &amp;rdquo;&amp;lt;h1&amp;gt;Hello&amp;lt;/h1&amp;gt;&amp;rdquo; ;
message.setContent(htmlText, &amp;rdquo;text/html&amp;rdquo;));&lt;/blockquote&gt;
请注意：这里的图片并不是在邮件中内嵌的，而是在URL中定义的。邮件接收者只有在线时才能看到。
在接收邮件时，如果我们使用JavaMail API接收邮件的话是无法实现以HTML方式显示邮件内容的。因为JavaMail API邮件内容视为二进制流。所以要显示HTML内容的邮件，我们必须使用JEditorPane或者第三方HTML展现组件。&lt;/p&gt;

&lt;p&gt;以下代码显示了如何使用JEditorPane显示邮件内容：
&lt;blockquote&gt;if (message.getContentType().equals(&amp;ldquo;text/html&amp;rdquo;)) {
String content = (String)message.getContent();
JFrame frame = new JFrame();
JEditorPane text = new JEditorPane(&amp;ldquo;text/html&amp;rdquo;, content);
text.setEditable(false);
JScrollPane pane = new JScrollPane(text);
frame.getContentPane().add(pane);
frame.setSize(300, 300);
frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
frame.show();
}&lt;/blockquote&gt;
B．在邮件中包含图片
如 果我们在邮件中使用HTML作为内容，那么最好将HTML中使用的图片作为邮件的一部分，这样无论是否在线都会正确的显示HTML中的图片。处理方法就是 将HTML中用到的图片作为邮件附件并使用特殊的cid URL作为图片的引用，这个cid就是对图片附件的Content-ID头的引用。
处理内嵌图片就像向邮件中添加附件一样，不同之处在于我们必须通过设置图片附件所在的邮件体部分的header中Content-ID为一个随机字符串，并在HTML中img的src标记中设置为该字符串。这样就完成了图片附件与HTML的关联。
&lt;blockquote&gt;
String file = &amp;hellip;;
// Create the messageMessage message = new MimeMessage(session);// Fill its headers
message.setSubject(&amp;ldquo;Embedded Image&amp;rdquo;);
message.setFrom(new InternetAddress(from));
message.addRecipient(Message.RecipientType.TO,   new InternetAddress(to));
// Create your new message part
BodyPart messageBodyPart = new MimeBodyPart();String htmlText = &amp;rdquo;&amp;rdquo;&amp;lt;h1&amp;gt;Hello&amp;lt;/h1&amp;gt;&amp;rdquo; ;
messageBodyPart.setContent(htmlText, &amp;rdquo;text/html&amp;rdquo;);
// Create a related multi-part to combine the parts
MimeMultipart multipart = new MimeMultipart(&amp;ldquo;related&amp;rdquo;);
multipart.addBodyPart(messageBodyPart);
// Create part for the image
messageBodyPart = new MimeBodyPart();
// Fetch the image and associate to part
DataSource fds = new FileDataSource(file);
messageBodyPart.setDataHandler(new DataHandler(fds));
messageBodyPart.setHeader(&amp;ldquo;Content-ID&amp;rdquo;,&amp;ldquo;&amp;rdquo;);
// Add part to multi-part
multipart.addBodyPart(messageBodyPart);
// Associate multi-part with message
message.setContent(multipart);&lt;/blockquote&gt;
9．在邮件中搜索短语
JavaMail API提供了过滤器机制，它被用来建立搜索短语。这个短语由javax.mail.search包中的SearchTerm抽象类来定义，在定义后我们便可以使用Folder的Search()方法在Folder中查找邮件：
SearchTerm st = &amp;hellip;;Message[] msgs = folder.search(st);
下面有22个不同的类（继承了SearchTerm类）供我们使用：
AND terms (class AndTerm)
OR terms (class OrTerm)
NOT terms (class NotTerm)
SENT DATE terms (class SentDateTerm)
CONTENT terms (class BodyTerm)
HEADER terms (FromTerm / FromStringTerm, RecipientTerm / RecipientStringTerm, SubjectTerm, etc.)
使用这些类定义的断语集合，我们可以构造一个逻辑表达式，并在Folder中进行搜索。下面是一个实例：在Folder中搜索邮件主题含有“ADV”字符串或者发信人地址为friend@public.com的邮件。
&lt;blockquote&gt;SearchTerm st = new OrTerm(new SubjectTerm(&amp;ldquo;ADV:&amp;ldquo;), new FromStringTerm(&amp;ldquo;friend@public.com&amp;rdquo;));
Message[] msgs = folder.search(st);
&lt;/blockquote&gt;
&amp;nbsp;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>javax.mail.internet API 学习</title>
      <link>http://www.daniex.tk/blog/2012/javax-mail-internet-api/</link>
      <pubDate>Fri, 20 Jan 2012 14:34:58 &#43;0000</pubDate>
      <author>Daniex</author>
      <guid>http://www.daniex.tk/blog/2012/javax-mail-internet-api/</guid>
      <description>&lt;p&gt;前些天编程，用了个这样的数据传输方式，在http POST消息中传MIME数据包。于是找到javax.mail.internet的包用。在Java EE 1.5的库里包含这个包。现在有的MIME包不仅仅这一个，还有很多，更有千秋。比如这个包的Countent-Type 的 boundary字段是自动生成的，还不太方便取出来。有些包是能够自己设置boundary字段。&lt;/p&gt;

&lt;p&gt;下面转载了这个包的基本使用方法，供学习参考。&lt;span style=&#34;color: #3366ff;&#34;&gt;&lt;a title=&#34;MIME详细介绍&#34; href=&#34;http://daniex.info/mime-details.html&#34; target=&#34;_blank&#34;&gt;&lt;span style=&#34;color: #3366ff;&#34;&gt;MIME学习请参考这里&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;++++++++++++++++++++++++++++++++++++++++++++&lt;/p&gt;

&lt;p&gt;打开JavaMail.jar文件，我们将发现在javax.mail的包下面存在着一些核心类：Session、Message、Address、Authenticator、Transport、Store、Folder。而且在 javax.mail.internet包中还有一些常用的子类。&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A．Session&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Session类定义了基本的邮件会话。就像Http会话那样，我们进行收发邮件的工作都是基于这个会话的。Session对象利用了java.util.Properties对象获得了邮件服务器、用户名、密码信息和整个应用程序都要使用到的共享信息。&lt;/p&gt;

&lt;p&gt;Session类的构造方法是私有的，所以我们可以使用Session类提供的getDefaultInstance()这个静态工厂方法获得一个默认的Session对象：
&lt;div&gt;
&lt;blockquote&gt;
&lt;div&gt;1 Properties props = new Properties();// fill props with any information
2  Session session = Session.getDefaultInstance(props, null);&lt;/div&gt;&lt;/blockquote&gt;
&lt;/div&gt;
或者使用getInstance()这个静态工厂方法获得自定义的Session:
&lt;div&gt;
&lt;blockquote&gt;
&lt;div&gt;1 Properties props = new Properties();// fill props with any information
2  Session session = Session.getInstance(props, null);&lt;/div&gt;&lt;/blockquote&gt;
&lt;/div&gt;
从上面的两个例子中不难发现，getDefaultInstance()和getInstance()方法的第二个参数都是null，这是因为在上面的例子中并没有使用到邮件授权，下文中将对授权进行详细介绍。
从很多的实例看，在对mail server进行访问的过程中使用共享的Session是足够的，即使是工作在多个用户邮箱的模式下也不例外。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;B．&lt;/strong&gt;&lt;strong&gt;Message&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当我们建立了Session对象后，便可以构造被 发送的信息体了。在这里SUN提供了Message类型来帮助开发者完成这项工作。由于Message是一个抽象类，大多数情况下，我们使用 javax.mail.internet.MimeMessage这个子类，该类是使用MIME类型、MIME信息头的邮箱信息。信息头只能使用US- ASCII字符，而非ASCII字符将通过编码转换为ASCII的方式使用。&lt;/p&gt;

&lt;p&gt;为了建立一个MimeMessage对象，我们必须将Session对象作为MimeMessage构造方法的参数传入：
&lt;div&gt;
&lt;blockquote&gt;
&lt;div&gt;1 MimeMessage message = new MimeMessage(session);&lt;/div&gt;&lt;/blockquote&gt;
&lt;/div&gt;
注意：对于MimeMessage类来讲存在着多种构造方法，比如使用输入流作为参数的构造方法。&lt;/p&gt;

&lt;p&gt;在建立了MimeMessage对象后，我们需要设置它的各个part，对于MimeMessage类来说，这些part就是MimePart接口。最基本的设置信息内容的方法就是通过表示信息内容和米么类型的参数调用setContent()方法：
&lt;div&gt;
&lt;blockquote&gt;
&lt;div&gt;1 message.setContent(&amp;ldquo;Hello&amp;rdquo;, &amp;ldquo;text/plain&amp;rdquo;);&lt;/div&gt;&lt;/blockquote&gt;
&lt;/div&gt;
然而，如果我们所使用的MimeMessage中信息内容是文本的话，我们便可以直接使用setText()方法来方便的设置文本内容：
&lt;div&gt;
&lt;blockquote&gt;
&lt;div&gt;1 message.setText(&amp;ldquo;Hello&amp;rdquo;);&lt;/div&gt;&lt;/blockquote&gt;
&lt;/div&gt;
前面所讲的两种方法，对于文本信息，后者更为合适。而对于其它的一些信息类型，比如HTML信息，则要使用前者。
别忘记了，使用setSubject()方法对邮件设置邮件主题：
&lt;div&gt;
&lt;blockquote&gt;
&lt;div&gt;1 message.setSubject(&amp;ldquo;First&amp;rdquo;);&lt;/div&gt;&lt;/blockquote&gt;
&lt;/div&gt;
&lt;strong&gt;C．Address&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;到这里，我们已经建立了Session和Message，下面将介绍如何使用邮件地址类：Address。像Message一样，Address类也是一个抽象类，所以我们将使用javax.mail.internet.InternetAddress这个子类。&lt;/p&gt;

&lt;p&gt;通过传入代表邮件地址的字符串，我们可以建立一个邮件地址类：
&lt;div&gt;
&lt;blockquote&gt;
&lt;div&gt;1 Address address = new InternetAddress(&amp;ldquo;president@whitehouse.gov&amp;rdquo;);&lt;/div&gt;&lt;/blockquote&gt;
&lt;/div&gt;
如果要在邮件地址后面增加名字的话，可以通过传递两个参数：代表邮件地址和名字的字符串来建立一个具有邮件地址和名字的邮件地址类：
&lt;div&gt;
&lt;blockquote&gt;
&lt;div&gt;1 Address address = new InternetAddress(&amp;ldquo;president@whitehouse.gov&amp;rdquo;, &amp;ldquo;George Bush&amp;rdquo;);&lt;/div&gt;&lt;/blockquote&gt;
&lt;/div&gt;
本文在这里所讲的邮件地址类是为了设置邮件信息的发信人和收信人而准备的，在建立了邮件地址类后，我们通过message的setFrom()和setReplyTo()两种方法设置邮件的发信人：
&lt;div&gt;
&lt;blockquote&gt;
&lt;div&gt;1 message.setFrom(address);message.setReplyTo(address);&lt;/div&gt;&lt;/blockquote&gt;
&lt;/div&gt;
若在邮件中存在多个发信人地址，我们可用addForm()方法增加发信人：
&lt;div&gt;
&lt;blockquote&gt;
&lt;div&gt;1 Address address[] = &amp;hellip;;
2 message.addFrom(address);&lt;/div&gt;&lt;/blockquote&gt;
&lt;/div&gt;
为了设置收信人，我们使用addRecipient()方法增加收信人，此方法需要使用Message.RecipientType的常量来区分收信人的类型：
&lt;div&gt;
&lt;blockquote&gt;
&lt;div&gt;1 message.addRecipient(type, address)&lt;/div&gt;&lt;/blockquote&gt;
&lt;/div&gt;
下面是Message.RecipientType的三个常量：
&lt;div&gt;
&lt;blockquote&gt;
&lt;div&gt;1 Message.RecipientType.TO
2 Message.RecipientType.CC
3 Message.RecipientType.BCC&lt;/div&gt;&lt;/blockquote&gt;
&lt;/div&gt;
因此，如果我们要发送邮件给总统，并发用一个副本给第一夫人的话，下面的方法将被用到：
&lt;div&gt;
&lt;blockquote&gt;
&lt;div&gt;1 Address toAddress = new InternetAddress(&amp;ldquo;vice.president@whitehouse.gov&amp;rdquo;);
2 Address ccAddress = new InternetAddress(&amp;ldquo;first.lady@whitehouse.gov&amp;rdquo;);
3 message.addRecipient(Message.RecipientType.TO, toAddress);
4 message.addRecipient(Message.RecipientType.CC, ccAddress);&lt;/div&gt;&lt;/blockquote&gt;
&lt;/div&gt;
JavaMail API并没有提供检查邮件地址有效性的机制。当然我们可以自己完成这个功能：验证邮件地址的字符是否按照RFC822规定的格式书写或者通过DNS服务器上的MX记录验证等。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;D．Authenticator&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;像java.net类那样，JavaMail API通过使用授权者类 （Authenticator）以用户名、密码的方式访问那些受到保护的资源，在这里“资源”就是指邮件服务器。在javax.mail包中可以找到这个 JavaMail的授权者类（Authenticator）。&lt;/p&gt;

&lt;p&gt;在使用Authenticator这个抽象类时，我们必须采用继承该抽象类的方式，并且该继 承类必须具有返回PasswordAuthentication对象（用于存储认证时要用到的用户名、密 码）getPasswordAuthentication()方法。并且要在Session中进行注册，使Session能够了解在认证时该使用哪个类。&lt;/p&gt;

&lt;p&gt;下面代码片断中的MyAuthenticator就是一个Authenticator的子类：
&lt;div&gt;
&lt;blockquote&gt;
&lt;div&gt;1 Properties props = new Properties();// fill props with any information
2  Authenticator auth = new MyAuthenticator();
3 Session session = Session.getDefaultInstance(props, auth);&lt;/div&gt;&lt;/blockquote&gt;
&lt;/div&gt;
&lt;strong&gt;E．Transport&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在发送信息时，Transport类将被用到。这个类实现了发送信息的协议（通称为SMTP），此类是一个抽象类，我们可以使用这个类的静态方法send()来发送消息：
&lt;div&gt;
&lt;blockquote&gt;
&lt;div&gt;1 Transport.send(message);&lt;/div&gt;&lt;/blockquote&gt;
&lt;/div&gt;
当然，方法是多样的。我们也可由Session获得相应协议对应的Transport实例。并通过传递用户名、密码、邮件服务器主机名等参数建立与邮件服务器的连接，并使用sendMessage()方法将信息发送，最后关闭连接：
&lt;div&gt;
&lt;blockquote&gt;
&lt;div&gt;1 message.saveChanges(); // implicit with send()
2  Transport transport = session.getTransport(&amp;ldquo;smtp&amp;rdquo;);
3 transport.connect(host, username, password);
4 transport.sendMessage(message, message.getAllRecipients());
5 transport.close();&lt;/div&gt;&lt;/blockquote&gt;
&lt;/div&gt;
评论：上面的方法是一个很好的方法，尤其是在我们在同一个邮件服务器上发送多个邮件时。因为 这时我们将在连接邮件服务器后连续发送邮件，然后再关闭掉连接。send()这个基本的方法是在每次调用时进行与邮件服务器的连接的，对于在同一个邮件服 务器上发送多个邮件来讲可谓低效的方式。&lt;/p&gt;

&lt;p&gt;注意：如果需要在发送邮件过程中监控mail命令的话，可以在发送前设置debug标志：
&lt;div&gt;
&lt;blockquote&gt;
&lt;div&gt;1 session.setDebug(true)；&lt;/div&gt;&lt;/blockquote&gt;
&lt;/div&gt;
&lt;strong&gt;F．Store和Folder&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;接 收邮件和发送邮件很类似都要用到Session。但是在获得Session后，我们需要从Session中获取特定类型的Store，然后连接到 Store，这里的Store代表了存储邮件的邮件服务器。在连接Store的过程中，极有可能需要用到用户名、密码或者Authenticator。
&lt;div&gt;
&lt;blockquote&gt;
&lt;div&gt;1 Store store = session.getStore(&amp;ldquo;pop3&amp;rdquo;);
2 store.connect(host, username, password);&lt;/div&gt;&lt;/blockquote&gt;
&lt;/div&gt;
在连接到Store后，一个Folder对象即目录对象将通过Store的getFolder()方法被返回，我们可从这个Folder中读取邮件信息：
&lt;div&gt;
&lt;blockquote&gt;
&lt;div&gt;1 Folder folder = store.getFolder(&amp;ldquo;INBOX&amp;rdquo;);
2 folder.open(Folder.READ_ONLY);
3 Message message[] = folder.getMessages();&lt;/div&gt;&lt;/blockquote&gt;
&lt;/div&gt;
上面的例子首先从Store中获得INBOX这个Folder（对于POP3协议只有一个名为INBOX的Folder有效），然后以只读（Folder.READ_ONLY）的方式打开Folder，最后调用Folder的 getMessages()方法得到目录中所有Message的数组。&lt;/p&gt;

&lt;p&gt;注意：对于POP3协议只 有一个名为INBOX的Folder有效，而对于IMAP协议，我们可以访问多个Folder（想想前面讲的IMAP协议）。而且SUN在设计 Folder的getMessages()方法时采取了很智能的方式：首先接收新邮件列表，然后再需要的时候（比如读取邮件内容）才从邮件服务器读取邮件 内容。&lt;/p&gt;

&lt;p&gt;在读取邮件时，我们可以用Message类的getContent()方法接收邮件或是writeTo()方法将邮件保存，getContent()方法只接收邮件内容（不包含邮件头），而writeTo()方法将包括邮件头。
&lt;div&gt;
&lt;blockquote&gt;
&lt;div&gt;1 System.out.println(((MimeMessage)message).getContent());&lt;/div&gt;&lt;/blockquote&gt;
&lt;/div&gt;
在读取邮件内容后，别忘记了关闭Folder和Store。
&lt;div&gt;
&lt;blockquote&gt;
&lt;div&gt;1 folder.close(aBoolean);
2 store.close();&lt;/div&gt;&lt;/blockquote&gt;
&lt;/div&gt;
传递给Folder.close()方法的boolean类型参数表示是否在删除操作邮件后更新Folder。&lt;/p&gt;

&lt;p&gt;转自：&lt;a href=&#34;http://tech.ccidnet.com/art/3741/20060531/567247_1.html&#34;&gt;http://tech.ccidnet.com/art/3741/20060531/567247_1.html&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>wordpress自定义个性化首页</title>
      <link>http://www.daniex.tk/blog/2011/wordpress-custom-home-page/</link>
      <pubDate>Sat, 19 Nov 2011 09:33:37 &#43;0000</pubDate>
      <author>Daniex</author>
      <guid>http://www.daniex.tk/blog/2011/wordpress-custom-home-page/</guid>
      <description>&lt;p&gt;自己好不容易折腾了个wordpress博客，发现所有人的首页样式都大同小异，是不是很没创意，很扫兴？下面就来说说如何制作一个wordpress个性化首页，让你随心所欲的改变首页的样式，让你有个不一样的主页。最后效果如我的&lt;a title=&#34;澄清的半亩方糖&#34; href=&#34;http://danie.info&#34; target=&#34;_blank&#34;&gt;&lt;strong&gt;首页&lt;/strong&gt;&lt;/a&gt;，截图如下：
&lt;p style=&#34;text-align: center;&#34;&gt;&lt;img class=&#34;aligncenter size-full wp-image-974&#34; title=&#34;ss&#34; src=&#34;http://daniex.info/wp-content/uploads/2011/11/ss.jpg&#34; alt=&#34;&#34; width=&#34;590&#34; height=&#34;482&#34; /&gt;&lt;/p&gt;
&amp;nbsp;
&lt;div style=&#34;background-color: #e3e3e3;&#34;&gt;
&lt;h2&gt;一、 设置wordpress首页&lt;/h2&gt;
&lt;/div&gt;
wordpress有设置page页作为默认首页的功能，下面的方法就是自定义一个page也模板，然后添加一个用这个模板制作的page页，最后将这个page页设为首页。&lt;/p&gt;

&lt;p&gt;1) ftp或者cpanel到部署wordpress空间或其他。复制wordpress主题目录下的page.php文件，重名名。比如，找到文件（wp目录）/wp-content/themes/zbench/page.php 重命名为 myhomepage.php&lt;/p&gt;

&lt;p&gt;2) 用文本编辑器打开myhomepage.php，例如用记事本打开，在文件首位添加以下代码：
&lt;blockquote&gt;&amp;lt;?php
/*
Template Name: 首页
*/
?&amp;gt;&lt;/blockquote&gt;
“Template Name : ” 后的文字可以是任意的。这样我们就添加了一个新的page页模板。自定义的首页内容其实就是这个myhomepage.php的内容。如何设计修改这个文件，建立自己的个性化首页，会在后面提到。我们先将它设为首页。&lt;/p&gt;

&lt;p&gt;3) 添加一个新的page页：浏览器登录wordpress后台控制面板，dashboard -&amp;gt;pages -&amp;gt; add new。 输入标题，在右方page attributes 面板中会有parent 和 template 的下拉框，在模板下拉框中选择刚刚添加的模板。如图，我添加的模板名字叫“首页”，我就选择它。&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-full wp-image-961&#34; title=&#34;selecttemplate&#34; src=&#34;http://daniex.info/wp-content/uploads/2011/11/selecttemplate.jpg&#34; alt=&#34;&#34; width=&#34;281&#34; height=&#34;253&#34; /&gt;选择好后，给这个page也命名，我是在title那输入的“首页”。然后就可以发表了，其他的内容什么可以都不用写。&lt;/p&gt;

&lt;p&gt;4) 设置首页的最后一步，点击后台的reading设置项：dashboard -&amp;gt; settings -&amp;gt; reading。在第一个设置项目里选择第二项 a static page ，然后再它下方的第一个下拉选项框里选则刚刚给page页设置的名字。比如我的“首页”。&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-full wp-image-962&#34; title=&#34;setreading&#34; src=&#34;http://daniex.info/wp-content/uploads/2011/11/setreading.png&#34; alt=&#34;&#34; width=&#34;552&#34; height=&#34;506&#34; /&gt;点击 save changes 保存配置。&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;这样，我们把首页重新设置好了。这个时候访问首页的时候我们会发现，我们的首页除了头上的标题名称、侧边栏、底部栏之外就什么都没有。&lt;/p&gt;

&lt;p&gt;&amp;nbsp;
&lt;div style=&#34;background-color: #e3e3e3;&#34;&gt;
&lt;h2&gt;二、 设计自己的wordpress首页&lt;/h2&gt;
&lt;/div&gt;
我们已经把wordpress的首页换掉，但是这个首页现在是一片空白，我们要怎么去填充这片空白呢？如果你有html、css、js功底，那就是你一展身手的时候。如果水平一般，那也没关系，能看懂一点点代码，那就有办法去使用一些好的模板，好的插件，设计出一个自己满意的首页还是可以的。我就只是能看懂代码的那种，根本不熟悉网页前端开发。
&lt;h4&gt;&lt;strong&gt;方法一&lt;/strong&gt;&lt;/h4&gt;
怎么给这个首页填充内容，最简单的方法就是，编辑我们之前添加的page页。之前我们并没有在文章内容里添加任何东西。只要你有好内容，好方案，就可以像写一个新的文章一样这里出一个你自己的主页。
&lt;h4&gt;&lt;strong&gt;方法二&lt;/strong&gt;&lt;/h4&gt;
这个方法就需要去修改我们的myhomepage.php文件。前端开发的牛人大有人在，我也不多说。就把我的一些代码贴出来，有心思看到朋友可以参考下。主要用到的几个函数我罗列一下：
&lt;blockquote&gt;&amp;lt;?php if(function_exists(&amp;lsquo;wp_thumbnails_for_category&amp;rsquo;)) { wp_thumbnails_for_category(&amp;lsquo;id=7&amp;amp;num=1&amp;rsquo;); } ?&amp;gt;&lt;/blockquote&gt;
这是我使用的wp-thumbnail插件提供的函数，用于显示分类中的文章和缩略图。在wp-thumbnail插件设置中设置好分类文章的相关数据，如图片大小、标题位置。然后再这里调用。id=7表示文章分类id为7的分类下的文章，num=1表示显示一篇。文章分类ID是几可以参考&lt;a title=&#34;wordpress查看分类category的id&#34; href=&#34;http://daniex.info/view-category-id-wordpress.html&#34; target=&#34;_blank&#34;&gt;&lt;strong&gt;这篇文章&lt;/strong&gt;&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;嵌入的探讨tt1 tt2 的css代码是控制左侧栏目的背景。另外有block1和block2的代码是用来控制左右两部分的布局。
&lt;blockquote&gt;.tt1 {background:#E3E3E3;width:270px;height350px}
.tt2 {background:#E3E3E3;width:210px;height310px;margin:30px}&lt;/p&gt;

&lt;p&gt;.block2 { float:left; width:250px; height:700px}
.block3 { float:right; width:350px; height:700px}&lt;/blockquote&gt;
中间栏的随机文章和标题评论控制是用这些函数：
&lt;blockquote&gt;$args = array( &amp;lsquo;numberposts&amp;rsquo; =&amp;gt; 5, &amp;lsquo;orderby&amp;rsquo; =&amp;gt; &amp;lsquo;rand&amp;rsquo;, &amp;lsquo;category&amp;rsquo; =&amp;gt; 7 );
$rand_posts = get_posts( $args );
foreach( $rand_posts as $post ) : setup_postdata($post); ?&amp;gt;&lt;/p&gt;

&lt;p&gt;。。。&lt;/blockquote&gt;
&amp;nbsp;
&lt;blockquote&gt;&amp;lt;?php if(function_exists(&amp;lsquo;the_views&amp;rsquo;)) { echo &amp;ldquo; | &amp;ldquo;;the_views(); } ?&amp;gt;&lt;/blockquote&gt;
这段代码是用了postviews+的插件，用于统计文章浏览次数。&lt;/p&gt;

&lt;p&gt;更多代码：
&lt;blockquote&gt;&amp;lt;?php
/*
Template Name: 首页
*/
?&amp;gt;
&amp;lt;?php get_header() ?&amp;gt;
&amp;lt;div id=&amp;ldquo;content&amp;rdquo;&amp;gt;
&amp;lt;?php the_post(); ?&amp;gt;
&amp;lt;div &amp;lt;?php post_class(&amp;lsquo;post post-page&amp;rsquo;); ?&amp;gt; id=&amp;ldquo;post-&amp;lt;?php the_ID(); ?&amp;gt;&amp;ldquo;&amp;gt;
&amp;lt;div class=&amp;ldquo;block2&amp;rdquo;&amp;gt;
&amp;lt;h2&amp;gt;&amp;lt;a href=&amp;ldquo;&lt;a href=&#34;http://daniex.info/category/coding&amp;quot;&amp;gt;编程开发&amp;lt;/a&amp;gt;&amp;lt;/h2&amp;gt;&amp;lt;span&amp;gt;C/C++&#34;&gt;http://daniex.info/category/coding&amp;quot;&amp;gt;编程开发&amp;lt;/a&amp;gt;&amp;lt;/h2&amp;gt;&amp;lt;span&amp;gt;C/C++&lt;/a&gt; java C# wpf php&amp;hellip;&amp;lt;/span&amp;gt;
&amp;lt;div class=&amp;ldquo;tt1&amp;rdquo;&amp;gt;
&amp;lt;div class=&amp;ldquo;tt2&amp;rdquo;&amp;gt;
&amp;lt;?php if(function_exists(&amp;lsquo;wp_thumbnails_for_category&amp;rsquo;)) { wp_thumbnails_for_category(&amp;lsquo;id=7&amp;amp;num=1&amp;rsquo;); } ?&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div class=&amp;ldquo;tt1&amp;rdquo;&amp;gt;
&amp;lt;div class=&amp;ldquo;tt2&amp;rdquo;&amp;gt;
&amp;lt;?php if(function_exists(&amp;lsquo;wp_thumbnails_for_category&amp;rsquo;)) { wp_thumbnails_for_category(&amp;lsquo;id=7&amp;amp;num=1&amp;amp;order=recent&amp;rsquo;); } ?&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;style&amp;gt;
.tt1 {background:#E3E3E3;width:270px;height350px}
.tt2 {background:#E3E3E3;width:210px;height310px;margin:30px}
&amp;lt;/style&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div class=&amp;ldquo;block3&amp;rdquo;&amp;gt;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;?php
$args = array( &amp;lsquo;numberposts&amp;rsquo; =&amp;gt; 5, &amp;lsquo;orderby&amp;rsquo; =&amp;gt; &amp;lsquo;rand&amp;rsquo;, &amp;lsquo;category&amp;rsquo; =&amp;gt; 7 );
$rand_posts = get_posts( $args );
foreach( $rand_posts as $post ) : setup_postdata($post); ?&amp;gt;
&amp;lt;h3&amp;gt;&amp;lt;a href=&amp;rdquo;&amp;lt;?php the_permalink(); ?&amp;gt;&amp;ldquo;&amp;gt;&amp;lt;?php the_title(); ?&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/h3&amp;gt;
&amp;lt;?php if (&amp;lsquo;open&amp;rsquo; == $post-&amp;gt;comment_status) { ?&amp;gt;
&amp;lt;div&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;span&amp;gt;&amp;lt;?php the_time(get_option( &amp;lsquo;date_format&amp;rsquo; )); ?&amp;gt;&amp;lt;/span&amp;gt;
&amp;lt;span id=&amp;ldquo;gotocomments&amp;rdquo;&amp;gt;&amp;lt;?php comments_popup_link(&lt;strong&gt;(&amp;lsquo;0 评论&amp;rsquo;, &amp;lsquo;zbench&amp;rsquo;), __(&amp;lsquo;1 评论&amp;rsquo;, &amp;lsquo;zbench&amp;rsquo;), &amp;lsquo;% &amp;lsquo;.&lt;/strong&gt;(&amp;rsquo; 评论&amp;rsquo;, &amp;lsquo;zbench&amp;rsquo;)); ?&amp;gt;&amp;lt;?php if(function_exists(&amp;lsquo;the_views&amp;rsquo;)) { echo &amp;ldquo; | &amp;ldquo;;the_views(); } ?&amp;gt;&amp;lt;/span&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;!&amp;ndash;&amp;lt;div&amp;gt;
&amp;lt;?php if ( $options[&amp;lsquo;excerpt_check&amp;rsquo;]==&amp;lsquo;true&amp;rsquo; ) { the_excerpt(&lt;strong&gt;(&amp;rsquo;&amp;amp;raquo; Read more&amp;hellip;&amp;lsquo;,&amp;lsquo;zbench&amp;rsquo;)); } else { the_content(&lt;/strong&gt;(&amp;rsquo;&amp;amp;raquo; Read more&amp;hellip;&amp;lsquo;,&amp;lsquo;zbench&amp;rsquo;)); } ?&amp;gt;
&amp;lt;/div&amp;gt; END entry &amp;ndash;&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;?php if(is_sticky()) { ?&amp;gt;
&amp;lt;div&amp;gt;&amp;lt;p&amp;gt;&amp;lt;?php _e(&amp;lsquo;This is a sticky post!&amp;rsquo;, &amp;lsquo;zbench&amp;rsquo;); ?&amp;gt; &amp;lt;a href=&amp;rdquo;&amp;lt;?php the_permalink() ?&amp;gt;&amp;ldquo;&amp;gt;&amp;lt;?php _e(&amp;lsquo;continue reading?&amp;rsquo;, &amp;lsquo;zbench&amp;rsquo;); ?&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;?php } ?&amp;gt;
&amp;lt;?php } else { ?&amp;gt;
&amp;lt;div style=&amp;ldquo;height:1px;&amp;rdquo;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;?php } ?&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;?php echo mb_strimwidth(strip_tags(apply_filters(‘the_content’, $post-&amp;gt;post_content)), 0, 100,&amp;ldquo;&amp;hellip;&amp;rdquo;); ?&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;
&amp;lt;?php endforeach; ?&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;/div&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;/div&amp;gt;&amp;lt;!&amp;ndash; END post &amp;ndash;&amp;gt;
&amp;lt;/div&amp;gt;&amp;lt;!&amp;ndash;content&amp;ndash;&amp;gt;
&amp;lt;?php get_sidebar() ?&amp;gt;
&amp;lt;?php get_footer() ?&amp;gt;&lt;/blockquote&gt;
&amp;nbsp;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>http协议头部与keep-alive</title>
      <link>http://www.daniex.tk/blog/2011/http-keep-alive/</link>
      <pubDate>Thu, 28 Jul 2011 10:40:11 &#43;0000</pubDate>
      <author>Daniex</author>
      <guid>http://www.daniex.tk/blog/2011/http-keep-alive/</guid>
      <description>

&lt;p&gt;上一篇讲&lt;a href=&#34;../java-send-http-request-example.html&#34;&gt;java发送http请求例子&lt;/a&gt;遇到的问题并不是java发送请求的代码问题。经检查是http server代码不完善导致，连接状态即http头中Connection参数设置有问题。&lt;/p&gt;

&lt;p&gt;在网上看到一篇挺好的文章，找了半天才找到原文出处，这就是在网上码字的悲哀。我也转个：&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;-——————————————————————————————————&lt;/p&gt;

&lt;p&gt;这样被判了死刑&amp;ndash;吴秦 &lt;a title=&#34;HTTP协议头部与Keep-Alive模式详解 &#34; href=&#34;http://www.cnblogs.com/skynet/archive/2010/12/11/1903347.html&#34; target=&#34;_blank&#34;&gt;&lt;a href=&#34;http://www.cnblogs.com/skynet/archive/2010/12/11/1903347.html&#34;&gt;http://www.cnblogs.com/skynet/archive/2010/12/11/1903347.html&lt;/a&gt;&lt;/a&gt;
&lt;div id=&#34;cnblogs_post_body&#34;&gt;&lt;/p&gt;

&lt;p&gt;——献给那些向我这样对HTTP的“伪”熟悉者。&lt;/p&gt;

&lt;p&gt;故事发生在10月份的一次面试经历中，本来我不想说出来丢人显眼，但是为了警醒自己和告诫后人，我决定写成博文发出来。因为在面试过程中，我讲在2009年写过QQ农场助手，在这期间深入学习了HTTP协议，而且在2010-05-18写了博文：&lt;a href=&#34;http://www.cnblogs.com/skynet/archive/2010/05/18/1738301.html&#34;&gt;HTTP协议及其POST与GET操作差异 &amp;amp; C#中如何使用POST、GET等&lt;/a&gt;。面试官说既然我熟悉HTTP协议，就问“当HTTP采用keepalive模式，当客户端向服务器发生请求之后，客户端如何判断服务器的数据已经发生完成？”&lt;/p&gt;

&lt;p&gt;说实话，当时我懵了，一直没有关注过keepalive模式。我只知道：&lt;strong&gt;HTTP协议中客户端发送一个小请求，服务器响应以所期望的信息（例如一个html文件或一副gif图像）。服务器通常在发送回所请求的数据之后就关闭连接。这样客户端读数据时会返回EOF（-1），就知道数据已经接收完全了。&lt;/strong&gt;我就这样被面试官判了死刑！！！说我完全停留在表面，没有深入（当时真的很受打击，一直自认为技术还不错！）。我当时真的很想找各种借口：
&lt;ul&gt;
    &lt;li&gt;
&lt;div&gt;之前没有用到HTTP的keepalive模式，所以没有深入&lt;/div&gt;&lt;/li&gt;
    &lt;li&gt;
&lt;div&gt;好久没有用HTTP协议，细节忘了&lt;/div&gt;&lt;/li&gt;
    &lt;li&gt;
&lt;div&gt;实习的东西跟HTTP协议没有关系，用得少了就忘了&lt;/div&gt;&lt;/li&gt;
    &lt;li&gt;
&lt;div&gt;。。。。。。&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
觉得各种解释都是那么苍白无力！我再次感叹书到用时方恨少，也感叹一个人的时间是多么的有限（曾一度想成为一个IT专业全才），根本没有精力面面俱 到，而且当没有真正使用一个东西的时候，往往会忽略掉很多细节。朋友如果你也答不上来，请认真细看下文，不要怀着浮躁了的心，说不定下次就有人问你这个问 题。
&lt;h1&gt;1、什么是Keep-Alive模式？&lt;/h1&gt;
我们知道HTTP协议采用“请求-应答”模式，当使用普通模式，即非KeepAlive模式时，每个请求/应答客户和服务器都要新建一个连接，完成 之后立即断开连接（HTTP协议为无连接的协议）；当使用Keep-Alive模式（又称持久连接、连接重用）时，Keep-Alive功能使客户端到服 务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接。&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter&#34; title=&#34;Connection&#34; src=&#34;http://upload.wikimedia.org/wikipedia/commons/thumb/d/d5/HTTP_persistent_connection.svg/450px-HTTP_persistent_connection.svg.png&#34; alt=&#34;&#34; width=&#34;450&#34; height=&#34;280&#34; /&gt;&lt;/p&gt;

&lt;p&gt;http 1.0中默认是关闭的，需要在http头加入&amp;rdquo;Connection: Keep-Alive&amp;rdquo;，才能启用Keep-Alive；http 1.1中默认启用Keep-Alive，如果加入&amp;rdquo;Connection: close &amp;ldquo;，才关闭。目前大部分浏览器都是用http1.1协议，也就是说默认都会发起Keep-Alive的连接请求了，所以是否能完成一个完整的Keep- Alive连接就看服务器设置情况。
&lt;h1&gt;2、启用Keep-Alive的优点&lt;/h1&gt;
从上面的分析来看，启用Keep-Alive模式肯定更高效，性能更高。因为避免了建立/释放连接的开销。下面是&lt;a href=&#34;http://tools.ietf.org/html/rfc2616&#34;&gt;RFC 2616&lt;/a&gt;上的总结：
&lt;ol&gt;
    &lt;li&gt;
&lt;ol&gt;
    &lt;li&gt;
&lt;div&gt;By opening and closing fewer TCP connections, CPU time is saved in routers and hosts (clients, servers, proxies, gateways, tunnels, or caches), and memory used for TCP protocol control blocks can be saved in hosts.&lt;/div&gt;&lt;/li&gt;
    &lt;li&gt;
&lt;div&gt;HTTP requests and responses can be pipelined on a connection. Pipelining allows a client to make multiple requests without waiting for each response, allowing a single TCP connection to be used much more efficiently, with much lower elapsed time.&lt;/div&gt;&lt;/li&gt;
    &lt;li&gt;
&lt;div&gt;Network congestion is reduced by reducing the number of packets caused by TCP opens, and by allowing TCP sufficient time to determine the congestion state of the network.&lt;/div&gt;&lt;/li&gt;
    &lt;li&gt;
&lt;div&gt;Latency on subsequent requests is reduced since there is no time spent in TCP&amp;rsquo;s connection opening handshake.&lt;/div&gt;&lt;/li&gt;
    &lt;li&gt;
&lt;div&gt;HTTP can evolve more gracefully, since errors can be reported without the penalty of closing the TCP connection. Clients using     future versions of HTTP might optimistically try a new feature, but if communicating with an older server, retry with old   semantics after an error is reported.&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;a href=&#34;http://tools.ietf.org/html/rfc2616&#34;&gt;RFC 2616&lt;/a&gt;（P47）还指出：单用户客户端与任何服务器或代理之间的连接数不应该超过2个。一个代理与其它服务器或代码之间应该使用超过2 * N的活跃并发连接。这是为了提高HTTP响应时间，避免拥塞（冗余的连接并不能代码执行性能的提升）。
&lt;h1&gt;3、回到我们的问题（即如何判断消息内容/长度的大小？）&lt;/h1&gt;
Keep-Alive模式，客户端如何判断请求所得到的响应数据已经接收完成（或者说如何知道服务器已经发生完了数据）？我们已经知道 了，Keep-Alive模式发送玩数据HTTP服务器不会自动断开连接，所有不能再使用返回EOF（-1）来判断（当然你一定要这样使用也没有办法，可 以想象那效率是何等的低）！下面我介绍两种来判断方法。
&lt;h2&gt;3.1、使用消息首部字段Conent-Length&lt;/h2&gt;
故名思意，Conent-Length表示实体内容长度，客户端（服务器）可以根据这个值来判断数据是否接收完成。但是如果消息中没有Conent-Length，那该如何来判断呢？又在什么情况下会没有Conent-Length呢？请继续往下看……
&lt;h2&gt;3.2、使用消息首部字段Transfer-Encoding&lt;/h2&gt;
当客户端向服务器请求一个静态页面或者一张图片时，服务器可以很清楚的知道内容大小，然后通过Content-length消息首部字段告诉客户端 需要接收多少数据。但是如果是动态页面等时，服务器是不可能预先知道内容大小，这时就可以使用Transfer-Encoding：chunk模式来传输 数据了。即如果要一边产生数据，一边发给客户端，服务器就需要使用&amp;rdquo;Transfer-Encoding: chunked&amp;rdquo;这样的方式来代替Content-Length。&lt;/p&gt;

&lt;p&gt;chunk编码将数据分成一块一块的发生。Chunked编码将使用若干个Chunk串连而成，由一个标明&lt;strong&gt;长度为0&lt;/strong&gt;的chunk标示结束。每个Chunk分为头部和正文两部分，头部内容指定正文的字符总数（&lt;strong&gt;十六进制的数字&lt;/strong&gt;）和数量单位（一般不写），正文部分就是指定长度的实际内容，两部分之间用&lt;strong&gt;回车换行(CRLF)&lt;/strong&gt;隔开。在最后一个长度为0的Chunk中的内容是称为footer的内容，是一些附加的Header信息（通常可以直接忽略）。
&lt;blockquote&gt;Chunk编码的格式如下：&lt;/p&gt;

&lt;p&gt;Chunked-Body = *&lt;strong&gt;chunk&lt;/strong&gt;
&amp;ldquo;0&amp;rdquo; CRLF
footer
CRLF
chunk = chunk-size [ chunk-ext ] CRLF
chunk-data CRLF&lt;/p&gt;

&lt;p&gt;hex-no-zero = &amp;lt;HEX excluding &amp;ldquo;0&amp;rdquo;&amp;gt;&lt;/p&gt;

&lt;p&gt;chunk-size = hex-no-zero *HEX
chunk-ext = *( &amp;ldquo;;&amp;rdquo; chunk-ext-name [ &amp;ldquo;=&amp;rdquo; chunk-ext-value ] )
chunk-ext-name = token
chunk-ext-val = token | quoted-string
chunk-data = chunk-size(OCTET)&lt;/p&gt;

&lt;p&gt;footer = *entity-header&lt;/p&gt;

&lt;p&gt;即Chunk编码由四部分组成：1、&lt;strong&gt;0至多个chunk块&lt;/strong&gt;，2、&lt;strong&gt;&amp;ldquo;0&amp;rdquo; CRLF&lt;/strong&gt;，3、&lt;strong&gt;footer&lt;/strong&gt;，4、&lt;strong&gt;CRLF&lt;/strong&gt;&lt;strong&gt;.&lt;/strong&gt;而每个chunk块由：chunk-size、chunk-ext（可选）、CRLF、chunk-data、CRLF组成。&lt;/blockquote&gt;
&lt;h1&gt;4、消息长度的总结&lt;/h1&gt;
其实，上面2中方法都可以归纳为是如何判断http消息的大小、消息的数量。&lt;a href=&#34;http://tools.ietf.org/html/rfc2616&#34;&gt;RFC 2616&lt;/a&gt;对 消息的长度总结如下：一个消息的transfer-length（传输长度）是指消息中的message-body（消息体）的长度。当应用了 transfer-coding（传输编码），每个消息中的message-body（消息体）的长度（transfer-length）由以下几种情况 决定（优先级由高到低）：
&lt;ul&gt;
    &lt;li&gt;任何不含有消息体的消息（如1XXX、204、304等响应消息和任何头(HEAD，首部)请求的响应消息），总是由一个空行（CLRF）结束。&lt;/li&gt;
    &lt;li&gt;如果出现了Transfer-Encoding头字段 并且值为非“identity”，那么transfer-length由“chunked” 传输编码定义，除非消息由于关闭连接而终止。&lt;/li&gt;
    &lt;li&gt;如果出现了Content-Length头字段，它的值表示entity-length（实体长度）和transfer-length（传输长 度）。如果这两个长度的大小不一样（i.e.设置了Transfer-Encoding头字段），那么将不能发送Content-Length头字段。并 且如果同时收到了Transfer-Encoding字段和Content-Length头字段，那么必须忽略Content-Length字段。&lt;/li&gt;
    &lt;li&gt;如果消息使用媒体类型“multipart/byteranges”，并且transfer-length 没有另外指定，那么这种自定界（self-delimiting）媒体类型定义transfer-length 。除非发送者知道接收者能够解析该类型，否则不能使用该类型。&lt;/li&gt;
    &lt;li&gt;由服务器关闭连接确定消息长度。（注意：关闭连接不能用于确定请求消息的结束，因为服务器不能再发响应消息给客户端了。）&lt;/li&gt;
&lt;/ul&gt;
为了兼容HTTP/1.0应用程序，HTTP/1.1的请求消息体中必须包含一个合法的Content-Length头字段，除非知道服务器兼容 HTTP/1.1。一个请求包含消息体，并且Content-Length字段没有给定，如果不能判断消息的长度，服务器应该用用400 (bad request) 来响应；或者服务器坚持希望收到一个合法的Content-Length字段，用 411 (length required)来响应。&lt;/p&gt;

&lt;p&gt;所有HTTP/1.1的接收者应用程序必须接受“chunked” transfer-coding (传输编码)，因此当不能事先知道消息的长度，允许使用这种机制来传输消息。消息不应该够同时包含 Content-Length头字段和non-identity transfer-coding。如果一个消息同时包含non-identity transfer-coding和Content-Length ，必须忽略Content-Length 。
&lt;h1&gt;5、HTTP头字段总结&lt;/h1&gt;
最后我总结下HTTP协议的头部字段。
&lt;ul&gt;
    &lt;li&gt;1、 Accept：告诉WEB服务器自己接受什么介质类型，&lt;em&gt;/&lt;/em&gt; 表示任何类型，type/* 表示该类型下的所有子类型，type/sub-type。&lt;/li&gt;
    &lt;li&gt;2、 Accept-Charset： 浏览器申明自己接收的字符集
Accept-Encoding： 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate）
Accept-Language：浏览器申明自己接收的语言
语言跟字符集的区别：中文是语言，中文有多种字符集，比如big5，gb2312，gbk等等。&lt;/li&gt;
    &lt;li&gt;3、 Accept-Ranges：WEB服务器表明自己是否接受获取其某个实体的一部分（比如文件的一部分）的请求。bytes：表示接受，none：表示不接受。&lt;/li&gt;
    &lt;li&gt;4、 Age：当代理服务器用自己缓存的实体去响应请求时，用该头部表明该实体从产生到现在经过多长时间了。&lt;/li&gt;
    &lt;li&gt;5、 Authorization：当客户端接收到来自WEB服务器的 WWW-Authenticate 响应时，用该头部来回应自己的身份验证信息给WEB服务器。&lt;/li&gt;
    &lt;li&gt;6、 Cache-Control：请求：no-cache（不要缓存的实体，要求现在从WEB服务器去取）
max-age：（只接受 Age 值小于 max-age 值，并且没有过期的对象）
max-stale：（可以接受过去的对象，但是过期时间必须小于 max-stale 值）
min-fresh：（接受其新鲜生命期大于其当前 Age 跟 min-fresh 值之和的缓存对象）
响应：public(可以用 Cached 内容回应任何用户)
private（只能用缓存内容回应先前请求该内容的那个用户）
no-cache（可以缓存，但是只有在跟WEB服务器验证了其有效后，才能返回给客户端）
max-age：（本响应包含的对象的过期时间）
ALL: no-store（不允许缓存）&lt;/li&gt;
    &lt;li&gt;7、 Connection：请求：close（告诉WEB服务器或者代理服务器，在完成本次请求的响应后，断开连接，不要等待本次连接的后续请求了）。
keepalive（告诉WEB服务器或者代理服务器，在完成本次请求的响应后，保持连接，等待本次连接的后续请求）。
响应：close（连接已经关闭）。
keepalive（连接保持着，在等待本次连接的后续请求）。
Keep-Alive：如果浏览器请求保持连接，则该头部表明希望 WEB 服务器保持连接多长时间（秒）。例如：Keep-Alive：300&lt;/li&gt;
    &lt;li&gt;8、 Content-Encoding：WEB服务器表明自己使用了什么压缩方法（gzip，deflate）压缩响应中的对象。例如：Content-Encoding：gzip&lt;/li&gt;
    &lt;li&gt;9、Content-Language：WEB 服务器告诉浏览器自己响应的对象的语言。&lt;/li&gt;
    &lt;li&gt;10、Content-Length： WEB 服务器告诉浏览器自己响应的对象的长度。例如：Content-Length: 26012&lt;/li&gt;
    &lt;li&gt;11、Content-Range： WEB 服务器表明该响应包含的部分对象为整个对象的哪个部分。例如：Content-Range: bytes 21010-&lt;sup&gt;47021&lt;/sup&gt;&amp;frasl;&lt;sub&gt;47022&lt;/sub&gt;&lt;/li&gt;
    &lt;li&gt;12、Content-Type： WEB 服务器告诉浏览器自己响应的对象的类型。例如：Content-Type：application/xml&lt;/li&gt;
    &lt;li&gt;13、ETag：就是一个对象（比如URL）的标志值，就一个对象而言，比如一个 html 文件，如果被修改了，其 Etag 也会别修改，所以ETag 的作用跟 Last-Modified 的作用差不多，主要供 WEB 服务器判断一个对象是否改变了。比如前一次请求某个 html 文件时，获得了其 ETag，当这次又请求这个文件时，浏览器就会把先前获得的 ETag 值发送给WEB 服务器，然后 WEB 服务器会把这个 ETag 跟该文件的当前 ETag 进行对比，然后就知道这个文件有没有改变了。&lt;/li&gt;
    &lt;li&gt;14、 Expired：WEB服务器表明该实体将在什么时候过期，对于过期了的对象，只有在跟WEB服务器验证了其有效性后，才能用来响应客户请求。是 HTTP/1.0 的头部。例如：Expires：Sat, 23 May 2009 10:02:12 GMT&lt;/li&gt;
    &lt;li&gt;15、 Host：客户端指定自己想访问的WEB服务器的域名/IP 地址和端口号。例如：Host：rss.sina.com.cn&lt;/li&gt;
    &lt;li&gt;16、 If-Match：如果对象的 ETag 没有改变，其实也就意味著对象没有改变，才执行请求的动作。&lt;/li&gt;
    &lt;li&gt;17、 If-None-Match：如果对象的 ETag 改变了，其实也就意味著对象也改变了，才执行请求的动作。&lt;/li&gt;
    &lt;li&gt;18、 If-Modified-Since：如果请求的对象在该头部指定的时间之后修改了，才执行请求的动作（比如返回对象），否则返回代码304，告诉浏览器 该对象没有修改。例如：If-Modified-Since：Thu, 10 Apr 2008 09:14:42 GMT&lt;/li&gt;
    &lt;li&gt;19、 If-Unmodified-Since：如果请求的对象在该头部指定的时间之后没修改过，才执行请求的动作（比如返回对象）。&lt;/li&gt;
    &lt;li&gt;20、 If-Range：浏览器告诉 WEB 服务器，如果我请求的对象没有改变，就把我缺少的部分给我，如果对象改变了，就把整个对象给我。浏览器通过发送请求对象的 ETag 或者 自己所知道的最后修改时间给 WEB 服务器，让其判断对象是否改变了。总是跟 Range 头部一起使用。&lt;/li&gt;
    &lt;li&gt;21、 Last-Modified：WEB 服务器认为对象的最后修改时间，比如文件的最后修改时间，动态页面的最后产生时间等等。例如：Last-Modified：Tue, 06 May 2008 02:42:43 GMT&lt;/li&gt;
    &lt;li&gt;22、 Location：WEB 服务器告诉浏览器，试图访问的对象已经被移到别的位置了，到该头部指定的位置去取。例如：Location：&lt;a href=&#34;http://i0.sinaimg.cn/dy/deco/2008/0528/sinahome_0803_ws_005_text_0.gif&#34;&gt;http://i0.sinaimg.cn/dy/deco/2008/0528/sinahome_0803_ws_005_text_0.gif&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;23、 Pramga：主要使用 Pramga: no-cache，相当于 Cache-Control： no-cache。例如：Pragma：no-cache&lt;/li&gt;
    &lt;li&gt;24、 Proxy-Authenticate： 代理服务器响应浏览器，要求其提供代理身份验证信息。Proxy-Authorization：浏览器响应代理服务器的身份验证请求，提供自己的身份信息。&lt;/li&gt;
    &lt;li&gt;25、 Range：浏览器（比如 Flashget 多线程下载时）告诉 WEB 服务器自己想取对象的哪部分。例如：Range: bytes=1173546-&lt;/li&gt;
    &lt;li&gt;26、 Referer：浏览器向 WEB 服务器表明自己是从哪个 网页/URL 获得/点击 当前请求中的网址/URL。例如：Referer：&lt;a href=&#34;http://www.sina.com/&#34;&gt;http://www.sina.com/&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;27、 Server: WEB 服务器表明自己是什么软件及版本等信息。例如：Server：Apache/2.0.61 (Unix)&lt;/li&gt;
    &lt;li&gt;28、 User-Agent: 浏览器表明自己的身份（是哪种浏览器）。例如：User-Agent：Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.8.1.14) Gecko/20080404 Firefox/2、0、0、14&lt;/li&gt;
    &lt;li&gt;29、 Transfer-Encoding: WEB 服务器表明自己对本响应消息体（不是消息体里面的对象）作了怎样的编码，比如是否分块（chunked）。例如：Transfer-Encoding: chunked&lt;/li&gt;
    &lt;li&gt;30、 Vary: WEB服务器用该头部的内容告诉 Cache 服务器，在什么条件下才能用本响应所返回的对象响应后续的请求。假如源WEB服务器在接到第一个请求消息时，其响应消息的头部为：Content- Encoding: gzip; Vary: Content-Encoding那么 Cache 服务器会分析后续请求消息的头部，检查其 Accept-Encoding，是否跟先前响应的 Vary 头部值一致，即是否使用相同的内容编码方法，这样就可以防止 Cache 服务器用自己 Cache 里面压缩后的实体响应给不具备解压能力的浏览器。例如：Vary：Accept-Encoding&lt;/li&gt;
    &lt;li&gt;31、 Via： 列出从客户端到 OCS 或者相反方向的响应经过了哪些代理服务器，他们用什么协议（和版本）发送的请求。当客户端请求到达第一个代理服务器时，该服务器会在自己发出的请求里面添 加 Via 头部，并填上自己的相关信息，当下一个代理服务器收到第一个代理服务器的请求时，会在自己发出的请求里面复制前一个代理服务器的请求的Via 头部，并把自己的相关信息加到后面，以此类推，当 OCS 收到最后一个代理服务器的请求时，检查 Via 头部，就知道该请求所经过的路由。例如：Via：1.0 236.D0707195.sina.com.cn:80 (squid/2.6.STABLE13)&lt;/li&gt;&lt;/p&gt;

&lt;h1 id=&#34;toc_0&#34;&gt;&lt;/ul&gt;&lt;/h1&gt;

&lt;p&gt;HTTP 请求消息头部实例：
Host：rss.sina.com.cn
User-Agent：Mozilla/5、0 (Windows; U; Windows NT 5、1; zh-CN; rv:1、8、1、14) Gecko/20080404 Firefox/2、0、0、14
Accept：text/xml,application/xml,application/xhtml+xml,text/html;q=0、9,text/plain;q=0、8,image/png,&lt;em&gt;/&lt;/em&gt;;q=0、5
Accept-Language：zh-cn,zh;q=0、5
Accept-Encoding：gzip,deflate
Accept-Charset：gb2312,utf-8;q=0、7,*;q=0、7
Keep-Alive：300
Connection：keep-alive
Cookie：userId=C5bYpXrimdmsiQmsBPnE1Vn8ZQmdWSm3WRlEB3vRwTnRtW &amp;amp;lt;&amp;ndash; Cookie
If-Modified-Since：Sun, 01 Jun 2008 12:05:30 GMT
Cache-Control：max-age=0
HTTP 响应消息头部实例：
Status：OK - 200 &amp;amp;lt;&amp;ndash; 响应状态码，表示 web 服务器处理的结果。
Date：Sun, 01 Jun 2008 12:35:47 GMT
Server：Apache/2、0、61 (Unix)
Last-Modified：Sun, 01 Jun 2008 12:35:30 GMT
Accept-Ranges：bytes
Content-Length：18616
Cache-Control：max-age=120
Expires：Sun, 01 Jun 2008 12:37:47 GMT
Content-Type：application/xml
Age：2
X-Cache：HIT from 236-41、D07071951、sina、com、cn &amp;amp;lt;&amp;ndash; 反向代理服务器使用的 HTTP 头部
Via：1.0 236-41.D07071951.sina.com.cn:80 (squid/2.6.STABLE13)
Connection：close&lt;/p&gt;

&lt;p&gt;本节摘自：&lt;a href=&#34;http://ynhu33.blog.51cto.com/412835/408801&#34;&gt;http://ynhu33.blog.51cto.com/412835/408801&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;——最后我想说：“怪自己学艺不精，浪费了一次机会（而且是我最想进的公司）”&lt;/p&gt;

&lt;p&gt;希望老天再给我一次机会。&lt;/p&gt;

&lt;p&gt;PS：还有一点加速了我的死亡，我学习过&lt;a href=&#34;http://www.cnblogs.com/skynet/category/241385.html&#34; target=&#34;_blank&#34;&gt;Android开发&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;但是用的是JAVA，经理说研究Android开发就得用NDK，那才是核心。&lt;/p&gt;

&lt;p&gt;&lt;/div&gt;
&lt;div id=&#34;MySignature&#34;&gt;&lt;/p&gt;

&lt;p&gt;作者：吴秦
出处：&lt;a href=&#34;http://www.cnblogs.com/skynet/&#34;&gt;http://www.cnblogs.com/skynet/&lt;/a&gt;
本文基于&lt;a href=&#34;http://creativecommons.org/licenses/by/2.5/cn/&#34; target=&#34;_blank&#34;&gt;署名 2.5 中国大陆&lt;/a&gt;许可协议发布，欢迎转载，演绎或用于商业目的，但是必须保留本文的署名&lt;a href=&#34;http://www.cnblogs.com/skynet/&#34; target=&#34;_blank&#34;&gt;吴秦&lt;/a&gt;（包含链接）.&lt;/p&gt;

&lt;p&gt;—————————————————————————————————————————————————————————————————&lt;/p&gt;

&lt;p&gt;全文到此为止。。。&lt;/p&gt;

&lt;p&gt;&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>java发送http请求例子</title>
      <link>http://www.daniex.tk/blog/2011/java-send-http-request-example/</link>
      <pubDate>Wed, 27 Jul 2011 10:23:43 &#43;0000</pubDate>
      <author>Daniex</author>
      <guid>http://www.daniex.tk/blog/2011/java-send-http-request-example/</guid>
      <description>&lt;p&gt;&lt;code&gt; &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;折腾java的restful webservice，另外写程序发送http请求时进行性能方面测试。当向一个地址连续发送http请求不设置timeout参数时，会在一个http连接中发送多次数据。&lt;/p&gt;

&lt;p&gt;用sniffer抓包是发现在一次SYN建立tcp链接后，有两次发送请求数据。第二次发送的数据一直在等待响应程序阻塞。问题尚未解决，折腾ing。&lt;/p&gt;

&lt;p&gt;一下是http请求发送的代码。单个请求发送是成功的。&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.Reader;
import java.io.Writer;
import java.net.HttpURLConnection;
import java.net.ProtocolException;
import java.net.URL;
import java.net.URLConnection;&lt;/p&gt;

&lt;p&gt;public class HTTPRequestPoster
{
/**
* Sends an HTTP GET request to a url
*
* @param endpoint - The URL of the server. (Example: &amp;ldquo; &lt;a href=&#34;http://www.yahoo.com/search&amp;quot;&#34;&gt;http://www.yahoo.com/search&amp;quot;&lt;/a&gt;)
* @param requestParameters - all the request parameters (Example:  &amp;ldquo;param1=val1&amp;amp;param2=val2&amp;rdquo;). Note: This method will add the question  mark (?) to the request - DO NOT add it yourself
* @return - The response from the end point
*/
public static String sendGetRequest(String endpoint, String requestParameters)
{
String result = null;
if (endpoint.startsWith(&amp;ldquo;http://&amp;ldquo;))
{
// Send a GET request to the servlet
try
{&lt;/p&gt;

&lt;p&gt;// Send data
String urlStr = endpoint;
if (requestParameters != null &amp;amp;&amp;amp; requestParameters.length () &amp;gt; 0)
{
urlStr += &amp;ldquo;?&amp;rdquo; + requestParameters;
}
URL url = new URL(urlStr);
URLConnection conn = url.openConnection ();&lt;/p&gt;

&lt;p&gt;// Get the response
BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));
StringBuffer sb = new StringBuffer();
String line;
while ((line = rd.readLine()) != null)
{
sb.append(line);
}
rd.close();
result = sb.toString();
} catch (Exception e)
{
e.printStackTrace();
}
}
return result;
}&lt;/p&gt;

&lt;p&gt;/**
* Reads data from the data reader and posts it to a server via POST request.
* data - The data you want to send
* endpoint - The server&amp;rsquo;s address
* output - writes the server&amp;rsquo;s response to output
* @throws Exception
*/
public static void postData(Reader data, URL endpoint, Writer output) throws Exception
{
HttpURLConnection urlc = null;
try
{
urlc = (HttpURLConnection) endpoint.openConnection();
try
{
urlc.setRequestMethod(&amp;ldquo;POST&amp;rdquo;);
} catch (ProtocolException e)
{
throw new Exception(&amp;ldquo;Shouldn&amp;rsquo;t happen: HttpURLConnection doesn&amp;rsquo;t support POST??&amp;ldquo;, e);
}
urlc.setDoOutput(true);
urlc.setDoInput(true);
urlc.setUseCaches(false);
urlc.setAllowUserInteraction(false);
urlc.setRequestProperty(&amp;ldquo;Content-type&amp;rdquo;, &amp;ldquo;text/xml; charset=&amp;rdquo; + &amp;ldquo;UTF-8&amp;rdquo;);&lt;/p&gt;

&lt;p&gt;OutputStream out = urlc.getOutputStream();&lt;/p&gt;

&lt;p&gt;try
{
Writer writer = new OutputStreamWriter(out, &amp;ldquo;UTF-8&amp;rdquo;);
pipe(data, writer);
writer.close();
} catch (IOException e)
{
throw new Exception(&amp;ldquo;IOException while posting data&amp;rdquo;, e);
} finally
{
if (out != null)
out.close();
}&lt;/p&gt;

&lt;p&gt;InputStream in = urlc.getInputStream();
try
{
Reader reader = new InputStreamReader(in);
pipe(reader, output);
reader.close();
} catch (IOException e)
{
throw new Exception(&amp;ldquo;IOException while reading response&amp;rdquo;, e);
} finally
{
if (in != null)
in.close();
}&lt;/p&gt;

&lt;p&gt;} catch (IOException e)
{
throw new Exception(&amp;ldquo;Connection error (is server running at &amp;rdquo; + endpoint + &amp;ldquo; ?): &amp;ldquo; + e);
} finally
{
if (urlc != null)
urlc.disconnect();
}
}&lt;/p&gt;

&lt;p&gt;/**
* Pipes everything from the reader to the writer via a buffer
*/
private static void pipe(Reader reader, Writer writer) throws IOException
{
char[] buf = new char[1024];
int read = 0;
while ((read = reader.read(buf)) &amp;gt;= 0)
{
writer.write(buf, 0, read);
}
writer.flush();
}&lt;/p&gt;

&lt;p&gt;&lt;code&gt;}&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>用jersey和JSF开发应用，部署在weblogic上。</title>
      <link>http://www.daniex.tk/blog/2011/jersey-jsf-weblogic-development/</link>
      <pubDate>Wed, 29 Jun 2011 12:24:54 &#43;0000</pubDate>
      <author>Daniex</author>
      <guid>http://www.daniex.tk/blog/2011/jersey-jsf-weblogic-development/</guid>
      <description>&lt;p&gt;项目中尝试开发小工具，在构建RESTful服务的同时提供web页面。想可以用jersey和JSF在weblogic上部署工程。由于对两者都不是很熟。所以开发过程中磕磕绊绊比较不顺畅。&lt;/p&gt;

&lt;p&gt;单个功能的应用开发都挺顺利的，但当集成两者的时候发现，要么RESTful服务工作不正常要们web页面不正常。查了半天发现是web.xml中定义servlet有冲突。&lt;/p&gt;

&lt;p&gt;&amp;lt;servlet&amp;gt;
&amp;lt;servlet-name&amp;gt;Faces Servlet&amp;lt;/servlet-name&amp;gt;
&amp;lt;servlet-class&amp;gt;javax.faces.webapp.FacesServlet&amp;lt;/servlet-class&amp;gt;
&amp;lt;load-on-startup&amp;gt;1&amp;lt;/load-on-startup&amp;gt;
&amp;lt;/servlet&amp;gt;
&amp;lt;servlet-mapping&amp;gt;
&amp;lt;servlet-name&amp;gt;Faces Servlet&amp;lt;/servlet-name&amp;gt;
&amp;lt;url-pattern&amp;gt;/faces/&lt;em&gt;&amp;lt;/url-pattern&amp;gt;
&amp;lt;/servlet-mapping&amp;gt;
&amp;lt;servlet-mapping&amp;gt;
&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;JSF自己生成的部分
&amp;lt;servlet&amp;gt;
&amp;lt;servlet-name&amp;gt;My Jersey Appliaction&amp;lt;/servlet-name&amp;gt;
&amp;lt;servlet-class&amp;gt;com.sun.jersey.spi.container.servlet.ServletContainer&amp;lt;/servlet-class&amp;gt;
&amp;lt;/servlet&amp;gt;
&amp;lt;servlet-mapping&amp;gt;
&amp;lt;servlet-name&amp;gt;My Jersey Appliaction&amp;lt;/servlet-name&amp;gt;
&amp;lt;url-pattern&amp;gt;/&lt;/em&gt;&amp;lt;/url-pattern&amp;gt;
&amp;lt;/servlet-mapping&amp;gt;
&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-jersey的一种部署方式&lt;/p&gt;

&lt;p&gt;&lt;span style=&#34;color: #3366ff;&#34;&gt;要注意的是,他们的url-pattern是冲突的&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;1 三种写法&lt;/p&gt;

&lt;p&gt;①　完全匹配&lt;/p&gt;

&lt;p&gt;&amp;lt;url-pattern&amp;gt;/test/list.do&amp;lt;/url-pattern&amp;gt;&lt;/p&gt;

&lt;p&gt;② 目录匹配&lt;/p&gt;

&lt;p&gt;&amp;lt;url-pattern&amp;gt;/test/*&amp;lt;/url-pattern&amp;gt;&lt;/p&gt;

&lt;p&gt;③ 扩展名匹配&lt;/p&gt;

&lt;p&gt;&amp;lt;url-pattern&amp;gt;*.do&amp;lt;/url-pattern&amp;gt;
2 注意事项&lt;/p&gt;

&lt;p&gt;☆ 容器会首先查找完全匹配，如果找不到，再查找目录匹配，如果也找不到，就查找扩展名匹配。&lt;/p&gt;

&lt;p&gt;☆ 如果一个请求匹配多个“目录匹配”，容器会选择最长的匹配。&lt;/p&gt;

&lt;p&gt;☆ 定义”/*.action”这样一个看起来很正常的匹配会报错？因为这个匹配即属于路径映射，也属于扩展映射，导致容器无法判断。
☆ “/” 是用来定义default servlet映射的。&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;servlet+jsr311就能实现简单的RESTful服务端。项目需要的时候再用jersey或者RESTlet，EasyREST之类的包吧。
&lt;h3&gt;————————————————————————————————————&lt;/h3&gt;
&lt;h3&gt;RESTful Web 服务简介&lt;/h3&gt;
REST 在 2000 年由 Roy Fielding 在博士论文中提出，他是 HTTP 规范 1.0 和 1.1 版的首席作者之一。&lt;/p&gt;

&lt;p&gt;REST 中最重要的概念是资源（resources），使用全球 ID（通常使用 URI）标识。客户端应用程序使用 HTTP 方法（GET/ POST/ PUT/ DELETE）操作资源或资源集。RESTful Web 服务是使用 HTTP 和 REST 原理实现的 Web 服务。通常，RESTful Web 服务应该定义以下方面：&lt;/p&gt;

&lt;p&gt;Web 服务的基/根 URI，比如 &lt;a href=&#34;http://host//resources。&#34;&gt;http://host//resources。&lt;/a&gt;
支持 MIME 类型的响应数据，包括 JSON/XML/ATOM 等等。
服务支持的操作集合（例如 POST、GET、PUT 或 DELETE）。
&lt;h3&gt;&lt;strong&gt;JSR 311 (JAX-RS) 和 Jersey&lt;/strong&gt;&lt;/h3&gt;
JSR 311 或 JAX-RS（用于 RESTful Web Services 的 Java API）的提议开始于 2007 年，1.0 版本到 2008 年 10 月定稿。目前，JSR 311 版本 1.1 还处于草案阶段。该 JSR 的目的是提供一组 API 以简化 REST 样式的 Web 服务的开发。&lt;/p&gt;

&lt;p&gt;在 JAX-RS 规范之前，已经有 Restlet 和 RestEasy 之类的框架，可以帮助您实现 RESTful Web 服务，但是它们不够直观。Jersey 是 JAX-RS 的参考实现，它包含三个主要部分。&lt;/p&gt;

&lt;p&gt;核心服务器（Core Server）：通过提供 JSR 311 中标准化的注释和 API 标准化，您可以用直观的方式开发 RESTful Web 服务。
核心客户端（Core Client）：Jersey 客户端 API 帮助您与 REST 服务轻松通信。
集成（Integration）：Jersey 还提供可以轻松集成 Spring、Guice、Apache Abdera 的库。&lt;/p&gt;

&lt;p&gt;以上取自：&lt;a title=&#34;使用 Jersey 和 Apache Tomcat 构建 RESTful Web 服务&#34; href=&#34;http://www.ibm.com/developerworks/cn/web/wa-aj-tomcat/&#34; target=&#34;_blank&#34;&gt;IBM&amp;ndash;使用 Jersey 和 Apache Tomcat 构建 RESTful Web 服务&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&amp;nbsp;
&lt;h3&gt;Java Server Faces (JSF)&lt;/h3&gt;
JSF是一种用于构建Java Web 应用程序的标准框架(是Java Community Process  规定的JSR-127标准)。它提供了一种以组件为中心的用户界面(UI)构建方法，从而简化了Java服务器端应用程序的开发。由于由Java  Community Process (JCP) 推动，属于Java EE 5中的技术规范，而受到了厂商的广泛支持。&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>RESTful WebService 搭建</title>
      <link>http://www.daniex.tk/blog/2011/restful-webservice-build/</link>
      <pubDate>Mon, 30 May 2011 02:36:51 &#43;0000</pubDate>
      <author>Daniex</author>
      <guid>http://www.daniex.tk/blog/2011/restful-webservice-build/</guid>
      <description>&lt;p&gt;最近了解了些关于WebService搭建方面的知识，这里稍稍做下整理。看的内容不少，但不够深入，如有不对的请指证。&lt;/p&gt;

&lt;p&gt;WSDL+SOAP搭建web Service的文档不少，就不多做介绍了。尝试在Jdeveloper下用ADF框架搭建着类WebService确实是方便快捷，轻松上手。这里主要罗列下RESTful框架的webservice搭建。&lt;/p&gt;

&lt;p&gt;在C/C++下开发RESTful服务需要第三方的库。核心是建立HTTP服务器和HTTP客户端的问题，其实就是在socket连接时使用TCP，再在上边加一层HTTP协议。如果需要的话中间可以加入SSL协议，使支持HTTPS。推荐使用的库是和mongoose和BOOST下的pion库。使用boost库非常方便，了解原理参照例子程序能很快搭建出来。mongoose是个轻量级的http server。核心代码就一个.c和一个.h文件。代码5000行。使用它的话需要稍稍阅读下源代码。&lt;/p&gt;

&lt;p&gt;在java上构建RESTful服务方法也很多。比如RESTlet库jersey库等等。RESTlet的资料相对jersey容易找一些。使用方法各有不同。RESTlet需要另外的http连接器库，比如GRIZZLY或者SimpleHTTP来建立HTTP服务器和客户端，然后再用RESTlet做更好的支持。JAX-RS: Java API for RESTful Web Services, SSL, JAXB, JSON, WADL等等。jersey可以用web服务器，比如glassfish，weblogic等通过annotation进行较快速的RESTful开发。也可以通过Grizzly等建通服务器。构建http请求除了使用内嵌接口之外，也可以使用java.net中的接口来建立连接发送请求。&lt;/p&gt;

&lt;p&gt;mongoose： &lt;a title=&#34;mongoose&#34; href=&#34;http://code.google.com/p/mongoose/&#34; target=&#34;_blank&#34;&gt;&lt;a href=&#34;http://code.google.com/p/mongoose/&#34;&gt;http://code.google.com/p/mongoose/&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;boost pion: &lt;a title=&#34;pion&#34; href=&#34;http://www.pion.org/projects/pion-network-library&#34; target=&#34;_blank&#34;&gt;&lt;a href=&#34;http://www.pion.org/projects/pion-network-library&#34;&gt;http://www.pion.org/projects/pion-network-library&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;TESTlet： &lt;a title=&#34;restlet&#34; href=&#34;http://www.restlet.org/&#34; target=&#34;_blank&#34;&gt;&lt;a href=&#34;http://www.restlet.org/&#34;&gt;http://www.restlet.org/&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;jersey： &lt;a title=&#34;jersey&#34; href=&#34;http://jersey.java.net/&#34; target=&#34;_blank&#34;&gt;&lt;a href=&#34;http://jersey.java.net/&#34;&gt;http://jersey.java.net/&lt;/a&gt;&lt;/a&gt;
&lt;pre class=&#34;brush:java&#34;&gt;******&lt;strong&gt;&lt;em&gt;jersey web服务器上RESTful服务例程&lt;/em&gt;&lt;/strong&gt;****&lt;/p&gt;

&lt;p&gt;package com.sun.jersey.samples.helloworld.resources;&lt;/p&gt;

&lt;p&gt;import javax.ws.rs.GET;&lt;/p&gt;

&lt;p&gt;import javax.ws.rs.Produces;&lt;/p&gt;

&lt;p&gt;import javax.ws.rs.Path;&lt;/p&gt;

&lt;p&gt;// The Java class will be hosted at the URI path &amp;ldquo;/helloworld&amp;rdquo;&lt;/p&gt;

&lt;p&gt;@Path(&amp;ldquo;/helloworld&amp;rdquo;)&lt;/p&gt;

&lt;p&gt;public class HelloWorldResource {&lt;/p&gt;

&lt;p&gt;// The Java method will process HTTP GET requests&lt;/p&gt;

&lt;p&gt;@GET&lt;/p&gt;

&lt;p&gt;// The Java method will produce content identified by the MIME Media&lt;/p&gt;

&lt;p&gt;// type &amp;ldquo;text/plain&amp;rdquo;&lt;/p&gt;

&lt;p&gt;@Produces(&amp;ldquo;text/plain&amp;rdquo;)&lt;/p&gt;

&lt;p&gt;public String getClichedMessage() {&lt;/p&gt;

&lt;p&gt;// Return some cliched textual content&lt;/p&gt;

&lt;p&gt;return &amp;ldquo;Hello World&amp;rdquo;;&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;}
&lt;/pre&gt;
&lt;pre class=&#34;brush:xml&#34;&gt;
****&lt;strong&gt;&lt;em&gt;web.xml文件&lt;/em&gt;&lt;/strong&gt;*****&lt;/p&gt;

&lt;p&gt;&amp;lt;?xml version=&amp;ldquo;1.0&amp;rdquo; encoding=&amp;ldquo;UTF-8&amp;rdquo;?&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;web-app version=&amp;ldquo;2.4&amp;rdquo; xmlns=&amp;ldquo;&lt;a href=&#34;http://java.sun.com/xml/ns/j2ee&amp;quot;&#34;&gt;http://java.sun.com/xml/ns/j2ee&amp;quot;&lt;/a&gt; xmlns:xsi=&amp;ldquo;&lt;a href=&#34;http://www.w3.org/2001/XMLSchema-instance&amp;quot;&#34;&gt;http://www.w3.org/2001/XMLSchema-instance&amp;quot;&lt;/a&gt; xsi:schemaLocation=&amp;ldquo;&lt;a href=&#34;http://java.sun.com/xml/ns/j2ee&#34;&gt;http://java.sun.com/xml/ns/j2ee&lt;/a&gt; &lt;a href=&#34;http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd&amp;quot;&amp;gt;&#34;&gt;http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd&amp;quot;&amp;gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;servlet&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;servlet-name&amp;gt;Jersey Web Application&amp;lt;/servlet-name&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;servlet-class&amp;gt;com.sun.jersey.spi.container.servlet.ServletContainer&amp;lt;/servlet-class&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;init-param&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;param-name&amp;gt;com.sun.jersey.config.property.packages&amp;lt;/param-name&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;param-value&amp;gt;com.sun.jersey.samples.helloworld.resources&amp;lt;/param-value&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;/init-param&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;load-on-startup&amp;gt;1&amp;lt;/load-on-startup&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;/servlet&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;servlet-mapping&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;servlet-name&amp;gt;Jersey Web Application&amp;lt;/servlet-name&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;/servlet-mapping&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;/web-app&amp;gt;&lt;/p&gt;

&lt;p&gt;&lt;/pre&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>