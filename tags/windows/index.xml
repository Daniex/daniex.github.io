<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Windows on Daniex </title>
      <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>http://www.daniex.tk/tags/windows/index.xml/</link>
    <language>zh-cn</language>
    <author>Daniex</author>
    
    <updated>Thu, 23 Feb 2012 03:11:47 &#43;0000</updated>
    
    <item>
      <title>windows xp 右键菜单、打开文件、ctrl&#43;c 奇慢问题</title>
      <link>http://www.daniex.tk/blog/2012/windows-xp-right-click-menu-open-the-file-ctrl-c-unresponsive-problems/</link>
      <pubDate>Thu, 23 Feb 2012 03:11:47 &#43;0000</pubDate>
      <author>Daniex</author>
      <guid>http://www.daniex.tk/blog/2012/windows-xp-right-click-menu-open-the-file-ctrl-c-unresponsive-problems/</guid>
      <description>&lt;p&gt;办公电脑出现这样的问题有半个月，一直没去折腾他。今儿网上找了下，发现方法很多，不知那个好。症状最符合的就是如下一篇，照做，立马搞定。&lt;/p&gt;

&lt;p&gt;————————————————————————————————————————&lt;/p&gt;

&lt;p&gt;直接症状：&lt;/p&gt;

&lt;p&gt;直接双击打开一个文件，比如一个 txt/Word 文档，要等超过15秒的时间，如果先打开 Word，然后再把文档拖到 Word 中则正常。
在某文件上点击右键，弹出右键菜单需要超过15秒的时间。
对某个文件进行键盘上的 Ctrl+C, Ctrl+V 操作，超过15秒才有反应。。。&lt;/p&gt;

&lt;p&gt;间接症状：&lt;/p&gt;

&lt;p&gt;断掉网络，如拔掉网线后，双击打开文件的速度和右键菜单的速度就都正常了。&lt;/p&gt;

&lt;p&gt;解决方法：&lt;/p&gt;

&lt;p&gt;点击“开始”-&amp;gt;“运行”。&lt;/p&gt;

&lt;p&gt;在“打开”后输入“regedit”，打开注册表。&lt;/p&gt;

&lt;p&gt;先备份注册表，以防万一。方法是，在注册表编辑器中，选择“文件”-&amp;gt;“导出”，将当前注册表导出到一个安全的位置。&lt;/p&gt;

&lt;p&gt;回到注册表顶端，打开“我的电脑”-&amp;gt;“HKEY_CLASSES_ROOT”-&amp;gt;“*”-&amp;gt;“shellex”&lt;/p&gt;

&lt;p&gt;将下面的两个子项改个名字，如改成“ContextMenuHandlers-”和“PropertySheetHandlers-”&lt;/p&gt;

&lt;p&gt;然后关闭注册表编辑器。&lt;/p&gt;

&lt;p&gt;天下太平。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>MIME详细介绍</title>
      <link>http://www.daniex.tk/blog/2012/mime-details/</link>
      <pubDate>Thu, 19 Jan 2012 01:11:28 &#43;0000</pubDate>
      <author>Daniex</author>
      <guid>http://www.daniex.tk/blog/2012/mime-details/</guid>
      <description>&lt;div id=&#34;cnblogs_post_body&#34;&gt;
（注：本文转自CSDN，因本人学习，只是做一笔记，以防遗忘。）

&lt;strong&gt;Q&lt;/strong&gt; 什么是MIME？什么是MIME邮件？

&lt;strong&gt;A&lt;/strong&gt; MIME, 全称为“Multipurpose Internet Mail Extensions”, 比较确切的中文名称为“多用途互联网邮件扩展”。它是当前广泛应用的一种电子邮件技术规范，基本内容定义于RFC 2045-2049。

自然，MIME邮件就是符合MIME规范的电子邮件，或者说根据MIME规范编码而成的电子邮件。

在MIME出台之前，使用RFC 822只能发送基本的ASCII码文本信息，邮件内容如果要包括二进制文件、声音和动画等，实现起来非常困难。MIME提供了一种可以在邮件中附加多种不 同编码文件的方法，弥补了原来的信息格式的不足。实际上不仅仅是邮件编码，现在MIME经成为HTTP协议标准的一个部分。

下面举几个MIME邮件的例子，让我们先对MIME编码的格式有个直观的印象。例1是最简单的，只带纯文本正 文，基本上就是RFC 822格式；例2复杂一些，包含纯文本和超文本正文；例3是最复杂的，包含纯文本正文、超文本正文、内嵌资源和文件附件。其中，行号和行号后的空格是为了 分析方便而另外加的，“... ... ... ...”表示此处省略了大段编码。

例1
&lt;blockquote&gt;1 Date: Thu, 18 Apr 2002 09:32:45 +0800
2 From: &amp;lt;bhw98@sina.com&amp;gt;
3 To: &amp;lt;bhwang@jlonline.com&amp;gt;
4 Subject: Test
5 Mime-Version: 1.0
6 Content-Type: text/plain; charset=&#34;iso-8859-1&#34;
7
8 This is a simple mail.
9&lt;/blockquote&gt;
例2
&lt;blockquote&gt;1 From: &#34;bhw98&#34; &amp;lt;bhw98@sina.com&amp;gt;
2 Reply-To: bhw98@sina.com
3 To: &amp;lt;bluesky7810@163.com&amp;gt;
4 Subject: Re: help
5 X-Mailer: Foxmail 4.2 [cn]
6 Mime-Version: 1.0
7 Content-Type: multipart/alternative;
8 boundary=&#34;=====002_Dragon307572345230_=====&#34;
9
10
11 This is a multi-part message in MIME format.
12
13 --=====002_Dragon307572345230_=====
14 Content-Type: text/plain; charset=&#34;GB2312&#34;
15 Content-Transfer-Encoding: quoted-printable
16
17 bluesky7810=A3=AC=C4=FA=BA=C3=A3=A1
18
19 =A1=A1=A1=A1=D4=DA=CF=C2=C6=AA=D7=EE=BA=F3=BF=C9=D2=D4=CF=C2=D4=D8=B0=A1=A3=AC=C4=E3
... ... ... ...
30 =A1=A1=A1=A1=A1=A1=A1=A1=A1=A1=A1=A1=A1=A1=A1=A1=A1=A1=A1=A1=A1=A1=A1=A1=A12003-04-07
31
32 --=====002_Dragon307572345230_=====
33 Content-Type: text/html; charset=&#34;GB2312&#34;
34 Content-Transfer-Encoding: quoted-printable
35
36 &amp;lt;!DOCTYPE HTML PUBLIC &#34;-//W3C//DTD HTML 4.0 Transitional//EN&#34;&amp;gt;
37 &amp;lt;HTML&amp;gt;&amp;lt;HEAD&amp;gt;
38 &amp;lt;META content=3D&#34;text/html; charset=3Dgb2312&#34;=
39 http-equiv=3DContent-Type&amp;gt;
40 &amp;lt;META content=3D&#34;MSHTML 5.00.2920.0&#34; name=3DGENERATOR&amp;gt;
... ... ... ...
79 &amp;lt;/HTML&amp;gt;
80
81 --=====002_Dragon307572345230_=====--
82&lt;/blockquote&gt;
例3
&lt;blockquote&gt;1 Return-Path: &amp;lt;bluesky7810@163.com&amp;gt;
2 Delivered-To: bhw98@sina.com
3 Received: (qmail 75513 invoked by alias); 20 May 2002 02:19:53 -0000
4 Received: from unknown (HELO bluesky) (61.155.118.135)
5 by 202.106.187.143 with SMTP; 20 May 2002 02:19:53 -0000
6 Message-ID: &amp;lt;007f01c3111c$742fec00$0100007f@bluesky&amp;gt;
7 From: &#34;=?gb2312?B?wLbAtrXEzOwNCg==?=&#34; &amp;lt;bluesky7810@163.com&amp;gt;
8 To: &#34;bhw98&#34; &amp;lt;bhw98@sina.com&amp;gt;
9 Cc: &amp;lt;bhwang@jlonline.com&amp;gt;
10 Subject: =?gb2312?B?ztK1xLbgtK6/2rPM0PI=?=
11 Date: Sat, 20 May 2002 10:03:36 +0800
12 MIME-Version: 1.0
13 Content-Type: multipart/mixed;
14 boundary=&#34;----=_NextPart_000_007A_01C3115F.80DFC5E0&#34;
15 X-Priority: 3
16 X-MSMail-Priority: Normal
17 X-Mailer: Microsoft Outlook Express 5.00.2919.6700
18 X-MimeOLE: Produced By Microsoft MimeOLE V5.00.2919.6700
19
20 This is a multi-part message in MIME format.
21
22 ------=_NextPart_000_007A_01C3115F.80DFC5E0
23 Content-Type: multipart/related; type=&#34;multipart/alternative&#34;;
24 boundary=&#34;----=_NextPart_001_007B_01C3115F.80DFC5E0&#34;
25
26
27 ------=_NextPart_001_007B_01C3115F.80DFC5E0
28 Content-Type: multipart/alternative;
29 boundary=&#34;----=_NextPart_002_007C_01C3115F.80DFC5E0&#34;
30
31 ------=_NextPart_002_007C_01C3115F.80DFC5E0
32 Content-Type: text/plain; charset=&#34;gb2312&#34;
33 Content-Transfer-Encoding: quoted-printable
34
35 bhw98, =C4=E3=BA=C3!
36 =D5=E2=CA=C7=CE=D2=D0=B4=B5=C4=B6=E0=B4=AE=BF=DA=CD=A8=D0=C5=B5=C4=B3=CC=D0=
37 =F2, =C7=EB=D6=B8=BD=CC!
38
39
40 ------=_NextPart_002_007C_01C3115F.80DFC5E0
41 Content-Type: text/html; charset=&#34;gb2312&#34;
42 Content-Transfer-Encoding: quoted-printable
43
44 &amp;lt;!DOCTYPE HTML PUBLIC &#34;-//W3C//DTD HTML 4.0 Transitional//EN&#34;&amp;gt;
45 &amp;lt;HTML&amp;gt;&amp;lt;HEAD&amp;gt;&amp;lt;TITLE&amp;gt;=C7=E7=C0=CA&amp;lt;/TITLE&amp;gt;
46 &amp;lt;META content=3D&#34;text/html; charset=3Dgb2312&#34; http-equiv=3DContent-Type&amp;gt;
47 &amp;lt;STYLE&amp;gt;BODY {
48 COLOR: #0033cc; FONT-FAMILY: =CB=CE=CC=E5, Arial, Helvetica; FONT-SIZE: =
49 9pt; MARGIN-LEFT: 10px; MARGIN-TOP: 25px
50 }
51 &amp;lt;/STYLE&amp;gt;
52 &amp;lt;META content=3D&#34;MSHTML 5.00.2920.0&#34; name=3DGENERATOR&amp;gt;&amp;lt;/HEAD&amp;gt;
53 &amp;lt;BODY background=3Dcid:007901c3111c$72b978a0$0100007f@bluesky =
54 bgColor=3D#ffffff&amp;gt;
55 &amp;lt;DIV&amp;gt;
56 &amp;lt;DIV&amp;gt;bhw98, =C4=E3=BA=C3!&amp;lt;/DIV&amp;gt;
57 &amp;lt;P&amp;gt;=D5=E2=CA=C7=CE=D2=D0=B4=B5=C4=B6=E0=B4=AE=BF=DA=CD=A8=D0=C5=B5=C4=B3=CC=
58 =D0=F2, =C7=EB=D6=B8=BD=CC!&amp;lt;/P&amp;gt;&amp;lt;/DIV&amp;gt;
59 &amp;lt;P&amp;gt; &amp;lt;/P&amp;gt;&amp;lt;/BODY&amp;gt;&amp;lt;/HTML&amp;gt;
60
61 ------=_NextPart_002_007C_01C3115F.80DFC5E0--
62
63 ------=_NextPart_001_007B_01C3115F.80DFC5E0
64 Content-Type: image/jpeg; name=&#34;=?gb2312?B?x+fAyrGzvrAuSlBH?=&#34;
65 Content-Transfer-Encoding: base64 66 Content-ID: &amp;lt;007901c3111c$72b978a0$0100007f@bluesky&amp;gt;
67
68 /9j/4AAQSkZJRgABAgEASABIAAD/7QVoUGhvdG9zaG9wIDMuMAA4QklNA+0AAAAAABAASAAAAAEA
69 AQBIAAAAAQABOEJJTQPzAAAAAAAIAAAAAAAAAAA4QklNBAoAAAAAAAEAADhCSU0nEAAAAAAACgAB
70 AAAAAAAAAAI4QklNA/UAAAAAAEgAL2ZmAAEAbGZmAAYAAAAAAAEAL2ZmAAEAoZmaAAYAAAAAAAEA
... ... ... ...
169 RxVw98Vawq12xQ44q0cKtHFDWKGsKt4EtiuKt4q//9k=
170
171 ------=_NextPart_001_007B_01C3115F.80DFC5E0--
172
173 ------=_NextPart_000_007A_01C3115F.80DFC5E0
174 Content-Type: application/msword; name=&#34;readme.doc&#34;
175 Content-Transfer-Encoding: base64
176 Content-Disposition: attachment; filename=&#34;readme.doc&#34;
177
178 0M8R4KGxGuEAAAAAAAAAAAAAAAAAAAAAPgADAP7/CQAGAAAAAAAAAAAAAAABAAAAJgAAAAAAAAAA
179 EAAAKAAAAAEAAAD+////AAAAACUAAAD/////////////////////////////////////////////
180 ////////////////////////////////////////////////////////////////////////////
... ... ... ...
1688 AAAAAAAAAAAAAAAAAAA=
1689
1690 ------=_NextPart_000_007A_01C3115F.80DFC5E0
1691 Content-Type: application/x-zip-compressed;
1692 name=&#34;=?gb2312?B?tuC0rr/azajQxbXE1LTC6y56aXA=?=&#34;
1693 Content-Transfer-Encoding: base64
1694 Content-Disposition: attachment;
1695 filename=&#34;=?gb2312?B?tuC0rr/azajQxbXE1LTC6y56aXA=?=&#34;
1696
1697 UEsDBBQAAAAIAFKAoi7qOMOvLw0AAABWAAAUAAAAtuC0rr/azajQxbXE1LTC6y5kb2PtXHtwVNUZ
1698 /+4+kk3IQoAkBkRYQkSgbrKb7IYNEMwmm6ckG0jCI0boZneTbJJ9sNlAEsdOtFqd8Z846tQ6PhB1
1699 hrZTJoK0Vhgf1aGt4rMy6D8tdugfTjuOpcBIR9j+vvsIy4YkRNTRen87v/ud53cee+6557vn7L73
... ... ... ...
3125 zajQxbXE1LTC6y5kb2NQSwUGAAAAAAEAAQBCAAAAYQ0AAA==
3126
3127 ------=_NextPart_000_007A_01C3115F.80DFC5E0--
3128&lt;/blockquote&gt;
&lt;strong&gt;Q&lt;/strong&gt; 在开始研究MIME邮件的时候，如何得到这样的源码？

&lt;strong&gt;A&lt;/strong&gt; 一些功能比较完善的邮件客户端软件，如微软的Outlook Express，国产的Foxmail等，都提供了查看和保存邮件源码(原始信息)的功能。在Foxmail中，选择邮件列表右键菜单的“原始信息”进行 查看，主菜单的“文件-导出”进行保存。在Outlook Express中，对应的操作分别是“属性”和“另存为”。所保存的.eml文件，可以调用这些程序打开。

&lt;strong&gt;Q&lt;/strong&gt; 请介绍一下MIME邮件的组成？

&lt;strong&gt;A&lt;/strong&gt; 总体来说，MIME消息由消息头和消息体两大部分组成。现在我们关注的是MIME邮件，因此在以下的讨论中姑且称“消息”为“邮件”。在上面的例子中，例 1的1-6行，例2的1—8行，例3的1-18行，是邮件头；例1的8—9行，例2的10—82行，例3的20—3128行，是邮件体。邮件头与邮件体之 间以空行进行分隔，如例1的第7行，例2的第9行，例3的第19行。邮件头中不允许出现空行。有一些邮件不能被邮件客户端软件识别，显示的是原始码，就是 因为首行是空行。

邮件头包含了发件人、收件人、主题、时间、MIME版本、邮件内容的类型等重要信息。每条信息称为一个域，由 域名后加“: ”和信息内容构成，可以是一行，较长的也可以占用多行。域的首行必须“顶头”写，即左边不能有空白字符（空格和制表符）；续行则必须以空白字符打头，且第 一个空白字符不是信息本身固有的，解码时要过滤掉。如例2的7-8行，例3的4-5行，13-14行，分别属于一个域。

邮件体包含邮件的内容，它的类型由邮件头的“Content-Type”域指出。常见的简单类型有text/plain(纯文本)和text/html(超文本)。

例2和例3中出现的multipart类型，是MIME邮件的精髓。邮件体被分为多个段，每个段又包含段头和 段体两部分，这两部分之间也以空行分隔。常见的multipart类型有三种：multipart/mixed, multipart/related和multipart/alternative。从它们的名称，不难推知这些类型各自的含义和用处。它们之间的层次关 系可归纳为下图所示：
&lt;pre&gt;+------------------------- multipart/mixed ----------------------------+
|                                                                      |
|  +----------------- multipart/related ------------------+            |
|  |                                                      |            |
|  |  +----- multipart/alternative ------+  +----------+  |  +------+  |
|  |  |                                  |  | 内嵌资源 |  |  | 附件 |  |
|  |  |  +------------+  +------------+  |  +----------+  |  +------+  |
|  |  |  | 纯文本正文 |  | 超文本正文 |  |                |            |
|  |  |  +------------+  +------------+  |  +----------+  |  +------+  |
|  |  |                                  |  | 内嵌资源 |  |  | 附件 |  |
|  |  +----------------------------------+  +----------+  |  +------+  |
|  |                                                      |            |
|  +------------------------------------------------------+            |
|                                                                      |
+----------------------------------------------------------------------+&lt;/pre&gt;
可以看出，如果在邮件中要添加附件，必须定义multipart/mixed段；如果存在内嵌资源，至少要定义 multipart/related段；如果纯文本与超文本共存，至少要定义multipart/alternative段。什么是“至少”？举个例子 说，如果只有纯文本与超文本正文，那么在邮件头中将类型扩大化，定义为multipart/related，甚至multipart/mixed，都是允 许的。

multipart诸类型的共同特征是，在段头指定“boundary”参数字符串，段体内的每个子段以此串 定界。所有的子段都以“--”+boundary行开始，父段则以“--”+boundary+“--”行结束。段与段之间也以空行分隔。在邮件体是 multipart类型的情况下，邮件体的开始部分(第一个“--”+boundary行之前)可以有一些附加的文本行，相当于注释，解码时应忽略。段间 也可以有一些附加的文本行，不会显示出来，如果有兴趣，不妨验证一下。

结合boundary定界和multipart层次关系图，我们分析一下例2和例3的邮件体层次与段嵌套关系。

在例2中，10-12行是附加文本行，13-82行是multipart/alternative型的段，包含两个子段：13-30行是纯文本正文，32-79行是超文本正文。

在例3中，20-21行是附加文本行，22-3127行是multipart/mixed型的段，包含3个子 段：22-171行是multipart/related段，173-1688行与1690-3125行是两个附件。multipart/related 段又包含两个子段：27-61行是multipart/alternative段，63-169行是一个内嵌资源(图片)。multipart /alternative段又包含两个子段：31-48行是纯文本正文，40-59行是超文本正文。

例1只有纯文本正文，实际上属于multipart层次关系图中的一个特殊情况。如果非要避简就繁，写成下面的形式，也是完全符合MIME精神的。
&lt;blockquote&gt;Date: Thu, 18 Apr 2002 09:32:45 +0800
From: &amp;lt;bhw98@sina.com&amp;gt;
To: &amp;lt;bhwang@jlonline.com&amp;gt;
Subject: Test
Mime-Version: 1.0
Content-Type: multipart/alternative; boundary=&#34;{[(^_^)]}&#34; --{[(^_^)]}
Content-Type: text/plain; charset=&#34;iso-8859-1&#34;
Content-Transfer-Encoding: 7bit This is a simple mail. --{[(^_^)]}--&lt;/blockquote&gt;
&lt;strong&gt;Q&lt;/strong&gt; 在邮件头和段头中，有哪一些常见的域？

&lt;strong&gt;A&lt;/strong&gt; 在邮件头中，有很多从RFC 822沿用的域名，MIME也增加了一些。常见的标准域名和含义如下
&lt;table align=&#34;center&#34;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;域名&lt;/td&gt;
&lt;td&gt;含义&lt;/td&gt;
&lt;td&gt;添加者&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Received&lt;/td&gt;
&lt;td&gt;传输路径&lt;/td&gt;
&lt;td&gt;各级邮件服务器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Return-Path&lt;/td&gt;
&lt;td&gt;回复地址&lt;/td&gt;
&lt;td&gt;目标邮件服务器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Delivered-To&lt;/td&gt;
&lt;td&gt;发送地址&lt;/td&gt;
&lt;td&gt;目标邮件服务器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Reply-To&lt;/td&gt;
&lt;td&gt;回复地址&lt;/td&gt;
&lt;td&gt;邮件的创建者&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;From&lt;/td&gt;
&lt;td&gt;发件人地址&lt;/td&gt;
&lt;td&gt;邮件的创建者&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;To&lt;/td&gt;
&lt;td&gt;收件人地址&lt;/td&gt;
&lt;td&gt;邮件的创建者&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Cc&lt;/td&gt;
&lt;td&gt;抄送地址&lt;/td&gt;
&lt;td&gt;邮件的创建者&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Bcc&lt;/td&gt;
&lt;td&gt;暗送地址&lt;/td&gt;
&lt;td&gt;邮件的创建者&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Date&lt;/td&gt;
&lt;td&gt;日期和时间&lt;/td&gt;
&lt;td&gt;邮件的创建者&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Subject&lt;/td&gt;
&lt;td&gt;主题&lt;/td&gt;
&lt;td&gt;邮件的创建者&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Message-ID&lt;/td&gt;
&lt;td&gt;消息ID&lt;/td&gt;
&lt;td&gt;邮件的创建者&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MIME-Version&lt;/td&gt;
&lt;td&gt;MIME版本&lt;/td&gt;
&lt;td&gt;邮件的创建者&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Content-Type&lt;/td&gt;
&lt;td&gt;内容的类型&lt;/td&gt;
&lt;td&gt;邮件的创建者&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Content-Transfer-Encoding&lt;/td&gt;
&lt;td&gt;内容的传输编码方式&lt;/td&gt;
&lt;td&gt;邮件的创建者&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
非标准的、自定义域名都以X-开头，例如X-Mailer, X-MSMail-Priority等，通常在接收和发送邮件的是同一程序时才能理解它们的意义。

在段头中，大致有如下一些域
&lt;table align=&#34;center&#34;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;域名&lt;/td&gt;
&lt;td&gt;含义&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Content-Type&lt;/td&gt;
&lt;td&gt;段体的类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Content-Transfer-Encoding&lt;/td&gt;
&lt;td&gt;段体的传输编码方式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Content-Disposition&lt;/td&gt;
&lt;td&gt;段体的安排方式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Content-ID&lt;/td&gt;
&lt;td&gt;段体的ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Content-Location&lt;/td&gt;
&lt;td&gt;段体的位置(路径)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Content-Base&lt;/td&gt;
&lt;td&gt;段体的基位置&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
有 的域除了值之外，还带有参数。值与参数、参数与参数之间以“;”分隔。参数名与参数值之间以“=”分隔。如例3的28-29行，Content-Type 域的值为“multipart/alternative”，此外有一个参数boundary，值 为&#34;----=_NextPart_002_007C_01C3115F.80DFC5E0&#34;。又如例3的第176行，Content- Disposition域的值为“attachment”，此外有一个参数filename，值为“readme.doc”。

&lt;strong&gt;Q&lt;/strong&gt; Content-Type以及它们的参数有哪些形式？

&lt;strong&gt;A&lt;/strong&gt; Content-Type都是“主类型/子类型”的形式。主类型有text, image, audio, video, application, multipart, message等，分别表示文本、图片、音频、视频、应用、分段、消息等。每个主类型都可能有多个子类型，如text类型就包含plain, html, xml, css等子类型。以X-开头的主类型和子类型，同样表示自定义的类型，未向IANA正式注册，但大多已经约定成俗了。如application/x- zip-compressed是ZIP文件类型。在Windows中，注册表的“HKEY_CLASSES_ROOT\MIME\Database \Content Type”内列举了除multipart之外大部分已知的Content-Type。

关于参数的形式，RFC里有很多补充规定，有的允许带几个参数，较为常见的有
&lt;table align=&#34;center&#34;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;主类型&lt;/td&gt;
&lt;td&gt;参数名&lt;/td&gt;
&lt;td&gt;含义&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;text&lt;/td&gt;
&lt;td&gt;charset&lt;/td&gt;
&lt;td&gt;字符集&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;image&lt;/td&gt;
&lt;td&gt;name&lt;/td&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;application&lt;/td&gt;
&lt;td&gt;name&lt;/td&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;multipart&lt;/td&gt;
&lt;td&gt;boundary&lt;/td&gt;
&lt;td&gt;边界&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
其中字符集也能在Windows注册表的“HKEY_CLASSES_ROOT\MIME\Database\Charset”内见到。

&lt;strong&gt;Q&lt;/strong&gt; Content-Transfer-Encoding有哪些？有什么特点？

&lt;strong&gt;A&lt;/strong&gt; Content-Transfer-Encoding共有Base64, Quoted-printable, 7bit, 8bit, Binary等几种。其中7bit是缺省的编码方式。电子邮件源码最初设计为全部是可打印的ASCII码的形式。非ASCII码的文本或数据要编码成要求 的格式，如上面的三个例子。Base64, Quoted-Printable是在非英语国家使用最广使的编码方式。Binary方式只具有象征意义，而没有任何实用价值。

Base64将输入的字符串或一段数据编码成只含有 {&#39;A&#39;-&#39;Z&#39;, &#39;a&#39;-&#39;z&#39;, &#39;0&#39;-&#39;9&#39;, &#39;+&#39;, &#39;/&#39;}这64个字符的串，&#39;=&#39;用于填充。其编码的方法是，将输入数据流每次取6 bit，用此6 bit的值(0-63)作为索引去查表，输出相应字符。这样，每3个字节将编码为4个字符(3×8 → 4×6)；不满4个字符的以&#39;=&#39;填充。有的场合，以“=?charset?B?xxxxxxxx?=”表示xxxxxxxx是Base64编码，且原文 的字符集是charset。如例3第7行&#34;=?gb2312?B?wLbAtrXEzOwNCg==?=&#34;是由简体中文“蓝蓝的天”编码而成的。在段体内 则直接编码，适当时机换行，MIME建议每行最多76个字符。如例3的1697-3125行，是一个ZIP文件的Base64编码。

Quoted-printable根据输入的字符串或字节 范围进行编码，若是不需编码的字符，直接输出；若需要编码，则先输出&#39;=&#39;，后面跟着以2个字符表示的十六进制字节值。有的场合，以 “=?charset?Q?xxxxxxxx?=”表示xxxxxxxx是Quoted-printable编码，且原文的字符集是charset。在段 体内则直接编码，适当时机换行，换行前额外输出一个&#39;=&#39;。如例3的44-59行，是HTML文本的Quoted-printable编码。其中第45行 “=C7=E7=C0=CA”原文是“晴朗”，因为“晴”的GB2312码是C7E7，“朗”的GB2312码是C0CA。第48、53、57行末尾只有 孤零零的&#39;=&#39;，表示这是由编码造成的软回车，而非原文固有的。

近年来，国内多数邮件服务器已经支持8bit方式，因此只在国内传输的邮件，特别是在邮件头中，可直接使用8bit编码，对汉字不做处理。如果邮件要出国，还是老老实实地按Base64或Quoted-printable编码才行。

&lt;strong&gt;Q&lt;/strong&gt; 什么是内嵌资源？它有哪些形式？

&lt;strong&gt;A&lt;/strong&gt; 内嵌资源也是MIME的一个发光点，它能使邮件内容变得生动活泼、丰富多彩。可在邮件的multipart/related框架内定义一些与正文关联的图 片、动画、声音甚至CSS样式和脚本的段。通常在HTML正文内，使用超级链接与内嵌资源相联系。如在例3中，HTML正文53-54行，解码后为
&lt;blockquote&gt;&amp;lt;BODY background=cid:007901c3111c$72b978a0$0100007f@bluesky bgColor=#ffffff&amp;gt;&lt;/blockquote&gt;
它指出用一个Content-ID为007901c3111c$72b978a0$0100007f@bluesky的图片作为背景(cid:xxxxxxxx也是一种超级链接)。而64-169行恰好就是这样一个内嵌资源。

除了用Content-ID进行联系外，还有另外一种常用形式：用普通超级连接和Content-Location。例如：

在HTML正文中，
&lt;blockquote&gt;... ... ... ... &amp;lt;
IMG SRC=&#34;http://www.dangdang.com/images/all/anti_joyo_dm_book.gif&#34;&amp;gt;
... ... ... ... &amp;lt;
IMG SRC=&#34;http://www.dangdang.com/dd2001/getimage_small.asp?id=486341&#34;&amp;gt;
... ... ... ...&lt;/blockquote&gt;
对应的内嵌资源为
&lt;blockquote&gt;Content-Type: image/gif; name=&#34;anti_joyo_dm_book.gif&#34;
Content-Transfer-Encoding: base64
Content-Location: http://www.dangdang.com/images/all/anti_joyo_dm_book.gif
... ... ... ...
Content-Type: application/octet-stream; name=&#34;getimage_small.asp?id=486341&#34;
Content-Transfer-Encoding: base64
Content-Location: http://www.dangdang.com/dd2001/getimage_small.asp?id=486341
... ... ... ...&lt;/blockquote&gt;
另外，
&lt;blockquote&gt;Content-Location: http://www.dangdang.com/images/all/anti_joyo_dm_book.gif&lt;/blockquote&gt;
与
&lt;blockquote&gt;Content-Location: anti_joyo_dm_book.gif Content-Base: http://www.dangdang.com/images/all/&lt;/blockquote&gt;
是等效的。

&lt;strong&gt;Q&lt;/strong&gt; 邮件病毒如何利用附件和内嵌资源传播？

&lt;strong&gt;A&lt;/strong&gt; 有的邮件附件可能带有病毒，容易理解。附件毕竟是文件，也好预防，不轻易打开就是了。但内嵌资源是在浏览邮件内容时就要访问的，若其中藏有病毒或恶意代码，你在不知不觉中就中招了。如前两年曾经在全球范围内流行的Nimda病毒，功能性源码如下：
&lt;blockquote&gt;MIME-Version: 1.0
Content-Type: multipart/related; type=&#34;multipart/alternative&#34;; boundary=&#34;====_ABC1234567890DEF_====&#34;

--====_ABC1234567890DEF_====
Content-Type: multipart/alternative; boundary=&#34;====_ABC0987654321DEF_====&#34;

--====_ABC0987654321DEF_====
Content-Type: text/html; charset=&#34;iso-8859-1&#34;
Content-Transfer-Encoding: 7bit &amp;lt;HTML&amp;gt;&amp;lt;HEAD&amp;gt;&amp;lt;/HEAD&amp;gt;&amp;lt;BODY bgColor=#ffffff&amp;gt; &amp;lt;iframe src=cid:EA4DMGBP9p height=0 width=0&amp;gt; &amp;lt;/iframe&amp;gt;&amp;lt;/BODY&amp;gt;&amp;lt;/HTML&amp;gt;

--====_ABC0987654321DEF_====--

--====_ABC1234567890DEF_====
Content-Type: audio/x-wav; name=&#34;readme.exe&#34;
Content-Transfer-Encoding: base64 Content-ID: &amp;lt;EA4DMGBP9p&amp;gt; TVqQAAMAAAAEAAAA//8AALgAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA AAAA2AAAAA4fug4AtAnNIbgBTM0hVGhpcyBwcm9ncmFtIGNhbm5vdCBiZSBydW4gaW4gRE9TIG1v ZGUuDQ0KJAAAAAAAAAA11CFvcbVPPHG1TzxxtU88E6pcPHW1TzyZqkU8dbVPPJmqSzxytU88cbVO
... ... ... ... ... ... ... ...
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=

--====_ABC1234567890DEF_====&lt;/blockquote&gt;
它 将一个可执行文件作为资源嵌入了框架型页面，却声明这段可执行代码是波形声音类型。由于当时微软的IE(版本5.0及以下)存在重大安全漏洞，没有检查 Content-Type与name的扩展名是否匹配，于是就被轻易骗过了，致使点选或打开邮件时自动运行了这个“readme.exe”，机器就感染上 病毒。带毒的机器利用地址簿向别人发送带毒的邮件，一传十，十传百，Nimda蠕虫大行其道。

纵观历史，病毒刚出来时是厉害，但没有任何一种能够持续肆虐下去。Nimda如此，SARS亦当如此。曰：“多难兴邦，众志成城”，又曰：“非典终将倒下，城市精神永存”，相信我们定能很快战胜“非典”!

病毒库升级是跟在新病毒屁股后进行的，不要过分依赖杀毒软件。一个良好的习惯是关闭邮件预览功能，或者设定预览纯文本部分，先查看邮件源码，确信排除病毒嫌疑后再打开。对陌生人发来的带超文本正文的邮件，尤其要当心。永远不要在邮件客户端软件内直接打开附件。

&lt;strong&gt;Q&lt;/strong&gt; 一些垃圾邮件采取隐藏发件人的方式，如何追查它们来自哪里？

&lt;strong&gt;A&lt;/strong&gt; 从上面的邮件头域名表中可以看出，邮件的创建者可以掌握大部分的域的内容，但Received等域由各级服务器自动添加，发件人是鞭长莫及。垃圾邮件一般 采用了群发软件发送，邮件头的From域(发件人地址)可以任意伪造，甚至写成收件人地址(收到了自己并没有发过的垃圾邮件，气愤吧？)。查看 Received域(传输路径)链可以找到真正的出处。每个服务器添加的Received语句都在邮件首，故最下面一个Received就包含了发件人所 用的SMTP或HTTP服务器，及最初的网关外部IP地址。

Receive语句的基本格式是：from A by B。A为发送方，B为接收方。例如：
&lt;blockquote&gt;Received: (qmail 45304 invoked from network); 4 May 2003 17:05:47 -0000 Received: from unknown (HELO bjapp9.163.net) (202.108.255.197) by 202.106.182.244 with SMTP; 4 May 2003 17:05:47 -0000 Received: from localhost (localhost [127.0.0.1]) by bjapp9.163.net (Postfix) with SMTP id E1C761D84C631 for &amp;lt;bhw98@sina.com&amp;gt;; Mon, 5 May 2003 01:07:26 +0800 (CST) Received: from fanyingxxxx@tom.com (unknown [211.99.162.194]) by bjapp9.163.net (Coremail) with SMTP id OgEAAM1ItT7MNaLC.1 for &amp;lt;bhw98@sina.com&amp;gt;; Mon, 05 May 2003 01:07:26 +0800 (CST)&lt;/blockquote&gt;
从 上面的例子中不难看出，该邮件的传输路径是：211.99.162.194 → bjapp9.163.net (Coremail 202.108.255.197?) → bjapp9.163.net (Postfix, 202.108.255.197?) → 202.106.182.244。恰好出现了发件人邮箱fanyingxxxx@tom.com，但多数情况不一定能列出来。

此例的localhost [127.0.0.1]，意味着bjapp9.163.net上安装了邮件服务代理性质的软件。

&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>SYBASE数据库日志详解(转)</title>
      <link>http://www.daniex.tk/blog/2011/sybase-database-log-r/</link>
      <pubDate>Sun, 09 Oct 2011 02:18:46 &#43;0000</pubDate>
      <author>Daniex</author>
      <guid>http://www.daniex.tk/blog/2011/sybase-database-log-r/</guid>
      <description>&lt;p&gt;写了点sybase相关的代码，发现数据库配置的时候少做了点配置，导致日志很快就满，无法进行下一步操作。查了下资料，转载过来。&lt;/p&gt;

&lt;p&gt;弄sybase遇到一个比较诡异的事情，就是ABC三人弄了三个sybase数据库，A连AB没问题连C有问题，B连B没问题连C有问题，C连A没问题，连BC有问题。数据库连接的代码都是一样的，闹腾啊。&lt;/p&gt;

&lt;p&gt;&amp;nbsp;
&lt;h1&gt;SYBASE数据库日志详解&lt;/h1&gt;
&lt;div&gt;&lt;/p&gt;

&lt;p&gt;每个数据库都有自己的事务日志（Transaction　Log），即系统表（Syslogs），日志对于数据库的数据安全性、完整性至关重要，本文详解SYBASE数据库日志。&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;&lt;/div&gt;
我们知道，SYBASE　SQL Server用事务（Transaction）来跟踪所有数据库的变化。事务是SQL　Server的工作单元。一个事务包含一条或多条作为整体执行的 T-SQL语句。每个数据库都有自己的事务日志（Transaction　Log），即系统表（Syslogs）。事务日志自动记录每个用户发出的每个事 务。日志对于数据库的数据安全性、完整性至关重要，我们进行数据库开发和维护必须熟知日志的相关知识。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一、SYBASE　SQL Server 如何记录和读取日志信息&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;SYBASE　SQL Server是先记Log的机制。每当用户执行将修改数据库的语句时，SQL　Server就会自动地把变化写入日志。一条语句所产生的所有变化都被记录 到日志后，它们就被写到数据页在缓冲区的拷贝里。该数据页保存在缓冲区中，直到别的数据页需要该内存时，该数据页才被写到磁盘上。若事务中的某条语句没能 完成，SQL　Server将回滚事务产生的所有变化。这样就保证了整个数据库系统的一致性和完整性。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、日志设备&lt;/strong&gt;
Log和数据库的Data一样，需要存放在数据库设备上，可以将Log和Data存放在同一设备上，也可以分开 存放。一般来说，应该将一个数据库的Data和Log存放在不同的数据库设备上。这样做有如下好处：一是可以单独地备份Backup　事务日志；二是防 止数据库溢满；三是可以看到Log的空间使用情况。
所建Log设备的大小，没有十分精确的方法来确定。一般来说，对于新建的数据库，Log的大小 应为数据库大小的30%左右。Log的大小还取决于数据库修改的频繁程度。如果数据库修改频繁，则Log的增长十分迅速。所以说Log空间大小依赖于用户 是如何使用数据库的。此外，还有其它因素影响Log大小，我们应该根据实际操作情况估计Log大小，并间隔一段时间就对Log进行备份和清除。
&lt;strong&gt;三、日志的清除&lt;/strong&gt;
随着数据库的使用，数据库的Log是不断增长的，必须在它占满空间之前将它们清除掉。清除Log有两种方法：
&lt;strong&gt;1.自动清除法
&lt;/strong&gt;
开放数据库选项 Trunc Log on Chkpt，使数据库系统每隔一段时间自动清除Log。此方法的优点是无须人工干预，由SQL　Server自动执行，并且一般不会出现Log溢满的情况；缺点是只清除Log而不做备份。
&lt;strong&gt;2.手动清除法&lt;/strong&gt;
执行命令“dump transaction”来清除Log。以下两条命令都可以清除日志：
&lt;table width=&#34;400&#34; border=&#34;1&#34; cellspacing=&#34;0&#34; cellpadding=&#34;2&#34; align=&#34;center&#34;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td bgcolor=&#34;#e6e6e6&#34;&gt;
dump transaction with truncate_only
dump transaction with no_log
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
通常删除事务日志中不活跃的部分可使用“dump transaction with trancate_only”命令，这条命令写进事务日志时，还要做必要的并发性检查。SYBASE提供“dump transaction with no_log”来处理某些非常紧迫的情况，使用这条命令有很大的危险性，SQL　Server会弹出一条警告信息。为了尽量确保数据库的一致性，你应将它 作为“最后一招”。
以上两种方法只是清除日志，而不做日志备份，若想备份日志，应执行“dump transaction database_name to dumpdevice”命令。
&lt;strong&gt;四、管理庞大的事务&lt;/strong&gt;
有些操作会大批量地修改数据，如大量数据的修改（Update）、删除一个表的所有数据（Delete）、大量数据的插入（Insert），这样会使Log增长速度很快，有溢满的危险。下面笔者给大家介绍一下如何拆分大事务，以避免日志的溢满。
例 如执行“update tab_a set col_a=0”命令时，若表tab_a很大，则此Update动作在未完成之前就可能使Log溢满，引起1105错误（Log Full），而且执行这种大的事务所产生的独占锁（Exclusive Table Lock），会阻止其他用户在执行Update操作期间修改这个表，这就有可能引起死锁。为避免这些情况发生，我们可以把这个大的事务分成几个小的事务， 并执行“dump transaction”动作。
上例中的情况就可以分成两个或多个小的事务：
&lt;table width=&#34;400&#34; border=&#34;1&#34; cellspacing=&#34;0&#34; cellpadding=&#34;2&#34; align=&#34;center&#34;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td bgcolor=&#34;#e6e6e6&#34;&gt;
update tab_a set col_a=0 where col_b&amp;gt;x
go
dump transaction database_name with truncate_only
go
update tab_a set col_a=0 where col_b &amp;lt;=x
go
dump transaction database_name with truncate_only
go
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
这样，一个大的事务就被分成两个较小的事务。
按照上述方法可以根据需要任意拆分大的事务。若这个事务需要备份到介质上，则不用“with truncate_only”选项。若执行“dump transaction with truncate_only”命令，应该先执行“dump database”。以此类推，我们可以对表删除、表插入等大事务做相应的拆分。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>win7使用virtualbox安装xp虚拟机窗口化玩游戏英雄无敌3</title>
      <link>http://www.daniex.tk/blog/2011/win7-install-xp-virtualbox-heroes3/</link>
      <pubDate>Sat, 24 Sep 2011 11:38:57 &#43;0000</pubDate>
      <author>Daniex</author>
      <guid>http://www.daniex.tk/blog/2011/win7-install-xp-virtualbox-heroes3/</guid>
      <description>&lt;p&gt;想到好久没玩游戏了，最近拿《英雄无敌3》出来耍耍。╮(╯▽╰)╭ 好吧，我比较老土，还玩这么老的游戏。想当初还特意装了个DOS box去玩初中时候玩的《三国英杰传》，整个游戏就2M。《英雄无敌3》好歹200M+，算高级货了。&lt;img class=&#34;alignnone&#34; src=&#34;http://daniex.info/wp-includes/images/smilies/icon_idea.gif&#34; alt=&#34;&#34; width=&#34;20&#34; height=&#34;20&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;win7玩heroes3会突然报错，而且不能窗口化。某人是想边玩游戏边看看美剧顺便干点其他的，所以。。。折腾下吧，弄个虚拟机，之前弄过阵子virtualbox，反正也不麻烦。&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;简述步骤：&lt;/p&gt;

&lt;p&gt;1、下载virtualbox。安装。&lt;/p&gt;

&lt;p&gt;2、下载windows xp iso镜像。不要别人做好的一键安装盘，virtualbox不认的，下个xp的原始安装镜像一步一步装过去。玩游戏的，装系统是小菜啦~&lt;/p&gt;

&lt;p&gt;3、virtualbox装虚拟机的步骤就不多说了，选机器类型，选择内存/显存，建个新磁盘文件，加载iso镜像，安装。&lt;/p&gt;

&lt;p&gt;4、某人是用virtual box的共享文件夹将xp上的文件夹共享到虚拟机里面的。网上有说可以用系统的文件共享，没试过不知道。这里说下用virtual box的共享将win 7 机器上的文件夹共享到xp虚拟机里面。&lt;/p&gt;

&lt;p&gt;1）启动虚拟机，在virtual box 的设备（device）菜单下有个Install Guest Additions的选项，呃，我用的英文的，不晓得中文是什么了。点击安装，重启虚拟机。&lt;/p&gt;

&lt;p&gt;2）Device-&amp;gt;share folders-&amp;gt;add share folders(右边带加号的图标)。 选择要共享的win 7 文件夹，命名改文件夹在virtualbox中的名字，选择auto mount。重启下。&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-medium wp-image-770&#34; title=&#34;virtualbox共享文件设置&#34; src=&#34;http://daniex.info/wp-content/uploads/2011/09/20110924191850343-300x287.png&#34; alt=&#34;&#34; width=&#34;300&#34; height=&#34;287&#34; /&gt;&lt;/p&gt;

&lt;p&gt;3）打开XP的我的电脑，里面就有你共享的文件夹。&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;终于，我可以在win7下边看美剧边游戏，哇哈哈哈哈哈哈的爽~&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-large wp-image-771&#34; title=&#34;窗口化游戏heroes3&#34; src=&#34;http://daniex.info/wp-content/uploads/2011/09/20110924192147450-1024x640.png&#34; alt=&#34;&#34; width=&#34;640&#34; height=&#34;400&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>http协议头部与keep-alive</title>
      <link>http://www.daniex.tk/blog/2011/http-keep-alive/</link>
      <pubDate>Thu, 28 Jul 2011 10:40:11 &#43;0000</pubDate>
      <author>Daniex</author>
      <guid>http://www.daniex.tk/blog/2011/http-keep-alive/</guid>
      <description>

&lt;p&gt;上一篇讲&lt;a href=&#34;../java-send-http-request-example.html&#34;&gt;java发送http请求例子&lt;/a&gt;遇到的问题并不是java发送请求的代码问题。经检查是http server代码不完善导致，连接状态即http头中Connection参数设置有问题。&lt;/p&gt;

&lt;p&gt;在网上看到一篇挺好的文章，找了半天才找到原文出处，这就是在网上码字的悲哀。我也转个：&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;-——————————————————————————————————&lt;/p&gt;

&lt;p&gt;这样被判了死刑&amp;ndash;吴秦 &lt;a title=&#34;HTTP协议头部与Keep-Alive模式详解 &#34; href=&#34;http://www.cnblogs.com/skynet/archive/2010/12/11/1903347.html&#34; target=&#34;_blank&#34;&gt;&lt;a href=&#34;http://www.cnblogs.com/skynet/archive/2010/12/11/1903347.html&#34;&gt;http://www.cnblogs.com/skynet/archive/2010/12/11/1903347.html&lt;/a&gt;&lt;/a&gt;
&lt;div id=&#34;cnblogs_post_body&#34;&gt;&lt;/p&gt;

&lt;p&gt;——献给那些向我这样对HTTP的“伪”熟悉者。&lt;/p&gt;

&lt;p&gt;故事发生在10月份的一次面试经历中，本来我不想说出来丢人显眼，但是为了警醒自己和告诫后人，我决定写成博文发出来。因为在面试过程中，我讲在2009年写过QQ农场助手，在这期间深入学习了HTTP协议，而且在2010-05-18写了博文：&lt;a href=&#34;http://www.cnblogs.com/skynet/archive/2010/05/18/1738301.html&#34;&gt;HTTP协议及其POST与GET操作差异 &amp;amp; C#中如何使用POST、GET等&lt;/a&gt;。面试官说既然我熟悉HTTP协议，就问“当HTTP采用keepalive模式，当客户端向服务器发生请求之后，客户端如何判断服务器的数据已经发生完成？”&lt;/p&gt;

&lt;p&gt;说实话，当时我懵了，一直没有关注过keepalive模式。我只知道：&lt;strong&gt;HTTP协议中客户端发送一个小请求，服务器响应以所期望的信息（例如一个html文件或一副gif图像）。服务器通常在发送回所请求的数据之后就关闭连接。这样客户端读数据时会返回EOF（-1），就知道数据已经接收完全了。&lt;/strong&gt;我就这样被面试官判了死刑！！！说我完全停留在表面，没有深入（当时真的很受打击，一直自认为技术还不错！）。我当时真的很想找各种借口：
&lt;ul&gt;
    &lt;li&gt;
&lt;div&gt;之前没有用到HTTP的keepalive模式，所以没有深入&lt;/div&gt;&lt;/li&gt;
    &lt;li&gt;
&lt;div&gt;好久没有用HTTP协议，细节忘了&lt;/div&gt;&lt;/li&gt;
    &lt;li&gt;
&lt;div&gt;实习的东西跟HTTP协议没有关系，用得少了就忘了&lt;/div&gt;&lt;/li&gt;
    &lt;li&gt;
&lt;div&gt;。。。。。。&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
觉得各种解释都是那么苍白无力！我再次感叹书到用时方恨少，也感叹一个人的时间是多么的有限（曾一度想成为一个IT专业全才），根本没有精力面面俱 到，而且当没有真正使用一个东西的时候，往往会忽略掉很多细节。朋友如果你也答不上来，请认真细看下文，不要怀着浮躁了的心，说不定下次就有人问你这个问 题。
&lt;h1&gt;1、什么是Keep-Alive模式？&lt;/h1&gt;
我们知道HTTP协议采用“请求-应答”模式，当使用普通模式，即非KeepAlive模式时，每个请求/应答客户和服务器都要新建一个连接，完成 之后立即断开连接（HTTP协议为无连接的协议）；当使用Keep-Alive模式（又称持久连接、连接重用）时，Keep-Alive功能使客户端到服 务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接。&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter&#34; title=&#34;Connection&#34; src=&#34;http://upload.wikimedia.org/wikipedia/commons/thumb/d/d5/HTTP_persistent_connection.svg/450px-HTTP_persistent_connection.svg.png&#34; alt=&#34;&#34; width=&#34;450&#34; height=&#34;280&#34; /&gt;&lt;/p&gt;

&lt;p&gt;http 1.0中默认是关闭的，需要在http头加入&amp;rdquo;Connection: Keep-Alive&amp;rdquo;，才能启用Keep-Alive；http 1.1中默认启用Keep-Alive，如果加入&amp;rdquo;Connection: close &amp;ldquo;，才关闭。目前大部分浏览器都是用http1.1协议，也就是说默认都会发起Keep-Alive的连接请求了，所以是否能完成一个完整的Keep- Alive连接就看服务器设置情况。
&lt;h1&gt;2、启用Keep-Alive的优点&lt;/h1&gt;
从上面的分析来看，启用Keep-Alive模式肯定更高效，性能更高。因为避免了建立/释放连接的开销。下面是&lt;a href=&#34;http://tools.ietf.org/html/rfc2616&#34;&gt;RFC 2616&lt;/a&gt;上的总结：
&lt;ol&gt;
    &lt;li&gt;
&lt;ol&gt;
    &lt;li&gt;
&lt;div&gt;By opening and closing fewer TCP connections, CPU time is saved in routers and hosts (clients, servers, proxies, gateways, tunnels, or caches), and memory used for TCP protocol control blocks can be saved in hosts.&lt;/div&gt;&lt;/li&gt;
    &lt;li&gt;
&lt;div&gt;HTTP requests and responses can be pipelined on a connection. Pipelining allows a client to make multiple requests without waiting for each response, allowing a single TCP connection to be used much more efficiently, with much lower elapsed time.&lt;/div&gt;&lt;/li&gt;
    &lt;li&gt;
&lt;div&gt;Network congestion is reduced by reducing the number of packets caused by TCP opens, and by allowing TCP sufficient time to determine the congestion state of the network.&lt;/div&gt;&lt;/li&gt;
    &lt;li&gt;
&lt;div&gt;Latency on subsequent requests is reduced since there is no time spent in TCP&amp;rsquo;s connection opening handshake.&lt;/div&gt;&lt;/li&gt;
    &lt;li&gt;
&lt;div&gt;HTTP can evolve more gracefully, since errors can be reported without the penalty of closing the TCP connection. Clients using     future versions of HTTP might optimistically try a new feature, but if communicating with an older server, retry with old   semantics after an error is reported.&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;a href=&#34;http://tools.ietf.org/html/rfc2616&#34;&gt;RFC 2616&lt;/a&gt;（P47）还指出：单用户客户端与任何服务器或代理之间的连接数不应该超过2个。一个代理与其它服务器或代码之间应该使用超过2 * N的活跃并发连接。这是为了提高HTTP响应时间，避免拥塞（冗余的连接并不能代码执行性能的提升）。
&lt;h1&gt;3、回到我们的问题（即如何判断消息内容/长度的大小？）&lt;/h1&gt;
Keep-Alive模式，客户端如何判断请求所得到的响应数据已经接收完成（或者说如何知道服务器已经发生完了数据）？我们已经知道 了，Keep-Alive模式发送玩数据HTTP服务器不会自动断开连接，所有不能再使用返回EOF（-1）来判断（当然你一定要这样使用也没有办法，可 以想象那效率是何等的低）！下面我介绍两种来判断方法。
&lt;h2&gt;3.1、使用消息首部字段Conent-Length&lt;/h2&gt;
故名思意，Conent-Length表示实体内容长度，客户端（服务器）可以根据这个值来判断数据是否接收完成。但是如果消息中没有Conent-Length，那该如何来判断呢？又在什么情况下会没有Conent-Length呢？请继续往下看……
&lt;h2&gt;3.2、使用消息首部字段Transfer-Encoding&lt;/h2&gt;
当客户端向服务器请求一个静态页面或者一张图片时，服务器可以很清楚的知道内容大小，然后通过Content-length消息首部字段告诉客户端 需要接收多少数据。但是如果是动态页面等时，服务器是不可能预先知道内容大小，这时就可以使用Transfer-Encoding：chunk模式来传输 数据了。即如果要一边产生数据，一边发给客户端，服务器就需要使用&amp;rdquo;Transfer-Encoding: chunked&amp;rdquo;这样的方式来代替Content-Length。&lt;/p&gt;

&lt;p&gt;chunk编码将数据分成一块一块的发生。Chunked编码将使用若干个Chunk串连而成，由一个标明&lt;strong&gt;长度为0&lt;/strong&gt;的chunk标示结束。每个Chunk分为头部和正文两部分，头部内容指定正文的字符总数（&lt;strong&gt;十六进制的数字&lt;/strong&gt;）和数量单位（一般不写），正文部分就是指定长度的实际内容，两部分之间用&lt;strong&gt;回车换行(CRLF)&lt;/strong&gt;隔开。在最后一个长度为0的Chunk中的内容是称为footer的内容，是一些附加的Header信息（通常可以直接忽略）。
&lt;blockquote&gt;Chunk编码的格式如下：&lt;/p&gt;

&lt;p&gt;Chunked-Body = *&lt;strong&gt;chunk&lt;/strong&gt;
&amp;ldquo;0&amp;rdquo; CRLF
footer
CRLF
chunk = chunk-size [ chunk-ext ] CRLF
chunk-data CRLF&lt;/p&gt;

&lt;p&gt;hex-no-zero = &amp;lt;HEX excluding &amp;ldquo;0&amp;rdquo;&amp;gt;&lt;/p&gt;

&lt;p&gt;chunk-size = hex-no-zero *HEX
chunk-ext = *( &amp;ldquo;;&amp;rdquo; chunk-ext-name [ &amp;ldquo;=&amp;rdquo; chunk-ext-value ] )
chunk-ext-name = token
chunk-ext-val = token | quoted-string
chunk-data = chunk-size(OCTET)&lt;/p&gt;

&lt;p&gt;footer = *entity-header&lt;/p&gt;

&lt;p&gt;即Chunk编码由四部分组成：1、&lt;strong&gt;0至多个chunk块&lt;/strong&gt;，2、&lt;strong&gt;&amp;ldquo;0&amp;rdquo; CRLF&lt;/strong&gt;，3、&lt;strong&gt;footer&lt;/strong&gt;，4、&lt;strong&gt;CRLF&lt;/strong&gt;&lt;strong&gt;.&lt;/strong&gt;而每个chunk块由：chunk-size、chunk-ext（可选）、CRLF、chunk-data、CRLF组成。&lt;/blockquote&gt;
&lt;h1&gt;4、消息长度的总结&lt;/h1&gt;
其实，上面2中方法都可以归纳为是如何判断http消息的大小、消息的数量。&lt;a href=&#34;http://tools.ietf.org/html/rfc2616&#34;&gt;RFC 2616&lt;/a&gt;对 消息的长度总结如下：一个消息的transfer-length（传输长度）是指消息中的message-body（消息体）的长度。当应用了 transfer-coding（传输编码），每个消息中的message-body（消息体）的长度（transfer-length）由以下几种情况 决定（优先级由高到低）：
&lt;ul&gt;
    &lt;li&gt;任何不含有消息体的消息（如1XXX、204、304等响应消息和任何头(HEAD，首部)请求的响应消息），总是由一个空行（CLRF）结束。&lt;/li&gt;
    &lt;li&gt;如果出现了Transfer-Encoding头字段 并且值为非“identity”，那么transfer-length由“chunked” 传输编码定义，除非消息由于关闭连接而终止。&lt;/li&gt;
    &lt;li&gt;如果出现了Content-Length头字段，它的值表示entity-length（实体长度）和transfer-length（传输长 度）。如果这两个长度的大小不一样（i.e.设置了Transfer-Encoding头字段），那么将不能发送Content-Length头字段。并 且如果同时收到了Transfer-Encoding字段和Content-Length头字段，那么必须忽略Content-Length字段。&lt;/li&gt;
    &lt;li&gt;如果消息使用媒体类型“multipart/byteranges”，并且transfer-length 没有另外指定，那么这种自定界（self-delimiting）媒体类型定义transfer-length 。除非发送者知道接收者能够解析该类型，否则不能使用该类型。&lt;/li&gt;
    &lt;li&gt;由服务器关闭连接确定消息长度。（注意：关闭连接不能用于确定请求消息的结束，因为服务器不能再发响应消息给客户端了。）&lt;/li&gt;
&lt;/ul&gt;
为了兼容HTTP/1.0应用程序，HTTP/1.1的请求消息体中必须包含一个合法的Content-Length头字段，除非知道服务器兼容 HTTP/1.1。一个请求包含消息体，并且Content-Length字段没有给定，如果不能判断消息的长度，服务器应该用用400 (bad request) 来响应；或者服务器坚持希望收到一个合法的Content-Length字段，用 411 (length required)来响应。&lt;/p&gt;

&lt;p&gt;所有HTTP/1.1的接收者应用程序必须接受“chunked” transfer-coding (传输编码)，因此当不能事先知道消息的长度，允许使用这种机制来传输消息。消息不应该够同时包含 Content-Length头字段和non-identity transfer-coding。如果一个消息同时包含non-identity transfer-coding和Content-Length ，必须忽略Content-Length 。
&lt;h1&gt;5、HTTP头字段总结&lt;/h1&gt;
最后我总结下HTTP协议的头部字段。
&lt;ul&gt;
    &lt;li&gt;1、 Accept：告诉WEB服务器自己接受什么介质类型，&lt;em&gt;/&lt;/em&gt; 表示任何类型，type/* 表示该类型下的所有子类型，type/sub-type。&lt;/li&gt;
    &lt;li&gt;2、 Accept-Charset： 浏览器申明自己接收的字符集
Accept-Encoding： 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate）
Accept-Language：浏览器申明自己接收的语言
语言跟字符集的区别：中文是语言，中文有多种字符集，比如big5，gb2312，gbk等等。&lt;/li&gt;
    &lt;li&gt;3、 Accept-Ranges：WEB服务器表明自己是否接受获取其某个实体的一部分（比如文件的一部分）的请求。bytes：表示接受，none：表示不接受。&lt;/li&gt;
    &lt;li&gt;4、 Age：当代理服务器用自己缓存的实体去响应请求时，用该头部表明该实体从产生到现在经过多长时间了。&lt;/li&gt;
    &lt;li&gt;5、 Authorization：当客户端接收到来自WEB服务器的 WWW-Authenticate 响应时，用该头部来回应自己的身份验证信息给WEB服务器。&lt;/li&gt;
    &lt;li&gt;6、 Cache-Control：请求：no-cache（不要缓存的实体，要求现在从WEB服务器去取）
max-age：（只接受 Age 值小于 max-age 值，并且没有过期的对象）
max-stale：（可以接受过去的对象，但是过期时间必须小于 max-stale 值）
min-fresh：（接受其新鲜生命期大于其当前 Age 跟 min-fresh 值之和的缓存对象）
响应：public(可以用 Cached 内容回应任何用户)
private（只能用缓存内容回应先前请求该内容的那个用户）
no-cache（可以缓存，但是只有在跟WEB服务器验证了其有效后，才能返回给客户端）
max-age：（本响应包含的对象的过期时间）
ALL: no-store（不允许缓存）&lt;/li&gt;
    &lt;li&gt;7、 Connection：请求：close（告诉WEB服务器或者代理服务器，在完成本次请求的响应后，断开连接，不要等待本次连接的后续请求了）。
keepalive（告诉WEB服务器或者代理服务器，在完成本次请求的响应后，保持连接，等待本次连接的后续请求）。
响应：close（连接已经关闭）。
keepalive（连接保持着，在等待本次连接的后续请求）。
Keep-Alive：如果浏览器请求保持连接，则该头部表明希望 WEB 服务器保持连接多长时间（秒）。例如：Keep-Alive：300&lt;/li&gt;
    &lt;li&gt;8、 Content-Encoding：WEB服务器表明自己使用了什么压缩方法（gzip，deflate）压缩响应中的对象。例如：Content-Encoding：gzip&lt;/li&gt;
    &lt;li&gt;9、Content-Language：WEB 服务器告诉浏览器自己响应的对象的语言。&lt;/li&gt;
    &lt;li&gt;10、Content-Length： WEB 服务器告诉浏览器自己响应的对象的长度。例如：Content-Length: 26012&lt;/li&gt;
    &lt;li&gt;11、Content-Range： WEB 服务器表明该响应包含的部分对象为整个对象的哪个部分。例如：Content-Range: bytes 21010-&lt;sup&gt;47021&lt;/sup&gt;&amp;frasl;&lt;sub&gt;47022&lt;/sub&gt;&lt;/li&gt;
    &lt;li&gt;12、Content-Type： WEB 服务器告诉浏览器自己响应的对象的类型。例如：Content-Type：application/xml&lt;/li&gt;
    &lt;li&gt;13、ETag：就是一个对象（比如URL）的标志值，就一个对象而言，比如一个 html 文件，如果被修改了，其 Etag 也会别修改，所以ETag 的作用跟 Last-Modified 的作用差不多，主要供 WEB 服务器判断一个对象是否改变了。比如前一次请求某个 html 文件时，获得了其 ETag，当这次又请求这个文件时，浏览器就会把先前获得的 ETag 值发送给WEB 服务器，然后 WEB 服务器会把这个 ETag 跟该文件的当前 ETag 进行对比，然后就知道这个文件有没有改变了。&lt;/li&gt;
    &lt;li&gt;14、 Expired：WEB服务器表明该实体将在什么时候过期，对于过期了的对象，只有在跟WEB服务器验证了其有效性后，才能用来响应客户请求。是 HTTP/1.0 的头部。例如：Expires：Sat, 23 May 2009 10:02:12 GMT&lt;/li&gt;
    &lt;li&gt;15、 Host：客户端指定自己想访问的WEB服务器的域名/IP 地址和端口号。例如：Host：rss.sina.com.cn&lt;/li&gt;
    &lt;li&gt;16、 If-Match：如果对象的 ETag 没有改变，其实也就意味著对象没有改变，才执行请求的动作。&lt;/li&gt;
    &lt;li&gt;17、 If-None-Match：如果对象的 ETag 改变了，其实也就意味著对象也改变了，才执行请求的动作。&lt;/li&gt;
    &lt;li&gt;18、 If-Modified-Since：如果请求的对象在该头部指定的时间之后修改了，才执行请求的动作（比如返回对象），否则返回代码304，告诉浏览器 该对象没有修改。例如：If-Modified-Since：Thu, 10 Apr 2008 09:14:42 GMT&lt;/li&gt;
    &lt;li&gt;19、 If-Unmodified-Since：如果请求的对象在该头部指定的时间之后没修改过，才执行请求的动作（比如返回对象）。&lt;/li&gt;
    &lt;li&gt;20、 If-Range：浏览器告诉 WEB 服务器，如果我请求的对象没有改变，就把我缺少的部分给我，如果对象改变了，就把整个对象给我。浏览器通过发送请求对象的 ETag 或者 自己所知道的最后修改时间给 WEB 服务器，让其判断对象是否改变了。总是跟 Range 头部一起使用。&lt;/li&gt;
    &lt;li&gt;21、 Last-Modified：WEB 服务器认为对象的最后修改时间，比如文件的最后修改时间，动态页面的最后产生时间等等。例如：Last-Modified：Tue, 06 May 2008 02:42:43 GMT&lt;/li&gt;
    &lt;li&gt;22、 Location：WEB 服务器告诉浏览器，试图访问的对象已经被移到别的位置了，到该头部指定的位置去取。例如：Location：&lt;a href=&#34;http://i0.sinaimg.cn/dy/deco/2008/0528/sinahome_0803_ws_005_text_0.gif&#34;&gt;http://i0.sinaimg.cn/dy/deco/2008/0528/sinahome_0803_ws_005_text_0.gif&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;23、 Pramga：主要使用 Pramga: no-cache，相当于 Cache-Control： no-cache。例如：Pragma：no-cache&lt;/li&gt;
    &lt;li&gt;24、 Proxy-Authenticate： 代理服务器响应浏览器，要求其提供代理身份验证信息。Proxy-Authorization：浏览器响应代理服务器的身份验证请求，提供自己的身份信息。&lt;/li&gt;
    &lt;li&gt;25、 Range：浏览器（比如 Flashget 多线程下载时）告诉 WEB 服务器自己想取对象的哪部分。例如：Range: bytes=1173546-&lt;/li&gt;
    &lt;li&gt;26、 Referer：浏览器向 WEB 服务器表明自己是从哪个 网页/URL 获得/点击 当前请求中的网址/URL。例如：Referer：&lt;a href=&#34;http://www.sina.com/&#34;&gt;http://www.sina.com/&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;27、 Server: WEB 服务器表明自己是什么软件及版本等信息。例如：Server：Apache/2.0.61 (Unix)&lt;/li&gt;
    &lt;li&gt;28、 User-Agent: 浏览器表明自己的身份（是哪种浏览器）。例如：User-Agent：Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.8.1.14) Gecko/20080404 Firefox/2、0、0、14&lt;/li&gt;
    &lt;li&gt;29、 Transfer-Encoding: WEB 服务器表明自己对本响应消息体（不是消息体里面的对象）作了怎样的编码，比如是否分块（chunked）。例如：Transfer-Encoding: chunked&lt;/li&gt;
    &lt;li&gt;30、 Vary: WEB服务器用该头部的内容告诉 Cache 服务器，在什么条件下才能用本响应所返回的对象响应后续的请求。假如源WEB服务器在接到第一个请求消息时，其响应消息的头部为：Content- Encoding: gzip; Vary: Content-Encoding那么 Cache 服务器会分析后续请求消息的头部，检查其 Accept-Encoding，是否跟先前响应的 Vary 头部值一致，即是否使用相同的内容编码方法，这样就可以防止 Cache 服务器用自己 Cache 里面压缩后的实体响应给不具备解压能力的浏览器。例如：Vary：Accept-Encoding&lt;/li&gt;
    &lt;li&gt;31、 Via： 列出从客户端到 OCS 或者相反方向的响应经过了哪些代理服务器，他们用什么协议（和版本）发送的请求。当客户端请求到达第一个代理服务器时，该服务器会在自己发出的请求里面添 加 Via 头部，并填上自己的相关信息，当下一个代理服务器收到第一个代理服务器的请求时，会在自己发出的请求里面复制前一个代理服务器的请求的Via 头部，并把自己的相关信息加到后面，以此类推，当 OCS 收到最后一个代理服务器的请求时，检查 Via 头部，就知道该请求所经过的路由。例如：Via：1.0 236.D0707195.sina.com.cn:80 (squid/2.6.STABLE13)&lt;/li&gt;&lt;/p&gt;

&lt;h1 id=&#34;toc_0&#34;&gt;&lt;/ul&gt;&lt;/h1&gt;

&lt;p&gt;HTTP 请求消息头部实例：
Host：rss.sina.com.cn
User-Agent：Mozilla/5、0 (Windows; U; Windows NT 5、1; zh-CN; rv:1、8、1、14) Gecko/20080404 Firefox/2、0、0、14
Accept：text/xml,application/xml,application/xhtml+xml,text/html;q=0、9,text/plain;q=0、8,image/png,&lt;em&gt;/&lt;/em&gt;;q=0、5
Accept-Language：zh-cn,zh;q=0、5
Accept-Encoding：gzip,deflate
Accept-Charset：gb2312,utf-8;q=0、7,*;q=0、7
Keep-Alive：300
Connection：keep-alive
Cookie：userId=C5bYpXrimdmsiQmsBPnE1Vn8ZQmdWSm3WRlEB3vRwTnRtW &amp;amp;lt;&amp;ndash; Cookie
If-Modified-Since：Sun, 01 Jun 2008 12:05:30 GMT
Cache-Control：max-age=0
HTTP 响应消息头部实例：
Status：OK - 200 &amp;amp;lt;&amp;ndash; 响应状态码，表示 web 服务器处理的结果。
Date：Sun, 01 Jun 2008 12:35:47 GMT
Server：Apache/2、0、61 (Unix)
Last-Modified：Sun, 01 Jun 2008 12:35:30 GMT
Accept-Ranges：bytes
Content-Length：18616
Cache-Control：max-age=120
Expires：Sun, 01 Jun 2008 12:37:47 GMT
Content-Type：application/xml
Age：2
X-Cache：HIT from 236-41、D07071951、sina、com、cn &amp;amp;lt;&amp;ndash; 反向代理服务器使用的 HTTP 头部
Via：1.0 236-41.D07071951.sina.com.cn:80 (squid/2.6.STABLE13)
Connection：close&lt;/p&gt;

&lt;p&gt;本节摘自：&lt;a href=&#34;http://ynhu33.blog.51cto.com/412835/408801&#34;&gt;http://ynhu33.blog.51cto.com/412835/408801&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;——最后我想说：“怪自己学艺不精，浪费了一次机会（而且是我最想进的公司）”&lt;/p&gt;

&lt;p&gt;希望老天再给我一次机会。&lt;/p&gt;

&lt;p&gt;PS：还有一点加速了我的死亡，我学习过&lt;a href=&#34;http://www.cnblogs.com/skynet/category/241385.html&#34; target=&#34;_blank&#34;&gt;Android开发&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;但是用的是JAVA，经理说研究Android开发就得用NDK，那才是核心。&lt;/p&gt;

&lt;p&gt;&lt;/div&gt;
&lt;div id=&#34;MySignature&#34;&gt;&lt;/p&gt;

&lt;p&gt;作者：吴秦
出处：&lt;a href=&#34;http://www.cnblogs.com/skynet/&#34;&gt;http://www.cnblogs.com/skynet/&lt;/a&gt;
本文基于&lt;a href=&#34;http://creativecommons.org/licenses/by/2.5/cn/&#34; target=&#34;_blank&#34;&gt;署名 2.5 中国大陆&lt;/a&gt;许可协议发布，欢迎转载，演绎或用于商业目的，但是必须保留本文的署名&lt;a href=&#34;http://www.cnblogs.com/skynet/&#34; target=&#34;_blank&#34;&gt;吴秦&lt;/a&gt;（包含链接）.&lt;/p&gt;

&lt;p&gt;—————————————————————————————————————————————————————————————————&lt;/p&gt;

&lt;p&gt;全文到此为止。。。&lt;/p&gt;

&lt;p&gt;&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>C#调用C&#43;&#43;写的DLL</title>
      <link>http://www.daniex.tk/blog/2011/c-call-dll-written-in-c/</link>
      <pubDate>Thu, 12 May 2011 06:48:53 &#43;0000</pubDate>
      <author>Daniex</author>
      <guid>http://www.daniex.tk/blog/2011/c-call-dll-written-in-c/</guid>
      <description>&lt;p&gt;方法有不少，这里记录其中的一个方法。编译、调用通过了的。期间遇到的问题是C#调用时传递string类型的参数和返回值会报错。TargetInvocationException异常，值不在范围内，内存不可访问等等。&lt;/p&gt;

&lt;p&gt;解决方法是；在c++的DLL中将string类型的参数返回值改为LPTSTR类型。在C#程序中使用StringBuilder类型来传入参数和接受返回值。&lt;/p&gt;

&lt;p&gt;下面是代码：
&lt;pre class=&#34;brush: csharp&#34;&gt;using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;&lt;/p&gt;

&lt;p&gt;//1.       打开项目“Tzb”，打开类视图，右击“Tzb”，选择“添加”&amp;ndash;&amp;gt;“类”，类名设置为“dld”，
//即dynamic loading dll 的每个单词的开头字母。
//2.       添加所需的命名空间及声明参数传递方式枚举：
using System.Runtime.InteropServices; // 用 DllImport 需用此 命名空间
using System.Reflection; // 使用 Assembly 类需用此 命名空间
using System.Reflection.Emit; // 使用 ILGenerator 需用此 命名空间&lt;/p&gt;

&lt;p&gt;namespace WpfApplication1
{
    //在“public class dld”上面添加如下代码声明参数传递方式枚举：
    ///
    /// 参数传递方式枚举 ,ByValue 表示值传递 ,ByRef 表示址传递
    ///&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public enum ModePass
{
    ByValue = 0x0001,
    ByRef = 0x0002
}
public class DLD
{      

    //3.       声明LoadLibrary、GetProcAddress、FreeLibrary及私有变量hModule和farProc：        
    /// 
    /// 原型是 :HMODULE LoadLibrary(LPCTSTR lpFileName);
    /// 
    /// &amp;lt; param name=&amp;quot;lpFileName&amp;quot; / &amp;gt;DLL 文件名 
    ///  函数库模块的句柄 
    [DllImport(&amp;quot;kernel32.dll&amp;quot;)]
    static extern IntPtr LoadLibrary(string lpFileName);

    /// 
    /// 原型是 : FARPROC GetProcAddress(HMODULE hModule, LPCWSTR lpProcName);
    /// 
    /// &amp;lt; param name=&amp;quot;hModule&amp;quot; / &amp;gt; 包含需调用函数的函数库模块的句柄 
    /// &amp;lt; param name=&amp;quot;lpProcName&amp;quot; / &amp;gt; 调用函数的名称 
    ///  函数指针 

    [DllImport(&amp;quot;kernel32.dll&amp;quot;)]
    static extern IntPtr GetProcAddress(IntPtr hModule, string lpProcName);

    /// 
    /// 原型是 : BOOL FreeLibrary(HMODULE hModule);
    /// 
    /// &amp;lt; param name=&amp;quot;hModule&amp;quot; / &amp;gt; 需释放的函数库模块的句柄 
    ///  是否已释放指定的 Dll

    [DllImport(&amp;quot;kernel32&amp;quot;, EntryPoint = &amp;quot;FreeLibrary&amp;quot;, SetLastError = true)]
    static extern bool FreeLibrary(IntPtr hModule);

    /// 
    /// Loadlibrary 返回的函数库模块的句柄
    /// 

    private IntPtr hModule = IntPtr.Zero;

    /// 
    /// GetProcAddress 返回的函数指针
    /// 

    public IntPtr farProc = IntPtr.Zero;


    //4.       添加LoadDll方法，并为了调用时方便，重载了这个方法：
    /// 
    /// 装载 Dll
    /// 
    /// &amp;lt; param name=&amp;quot;lpFileName&amp;quot; / &amp;gt;DLL 文件名 

    public void LoadDll(string lpFileName)
    {

        hModule = LoadLibrary(lpFileName);
        if (hModule == IntPtr.Zero)
            throw (new Exception(&amp;quot; 没有找到 :&amp;quot; + lpFileName + &amp;quot;.&amp;quot;));
    }


    //         若已有已装载Dll的句柄，可以使用LoadDll方法的第二个版本：
    public void LoadDll(IntPtr HMODULE)
    {
        if (HMODULE == IntPtr.Zero)
            throw (new Exception(&amp;quot; 所传入的函数库模块的句柄 HMODULE 为空 .&amp;quot;));
        hModule = HMODULE;
    }


    //5.       添加LoadFun方法，并为了调用时方便，也重载了这个方法，方法的具体代码及注释如下：
    /// 
    /// 获得函数指针
    /// 
    /// &amp;lt; param name=&amp;quot;lpProcName&amp;quot; / &amp;gt; 调用函数的名称 

    public void LoadFun(string lpProcName)
    { // 若函数库模块的句柄为空，则抛出异常

        if (hModule == IntPtr.Zero)
            throw (new Exception(&amp;quot; 函数库模块的句柄为空 , 请确保已进行 LoadDll 操作 !&amp;quot;));
        // 取得函数指针
        farProc = GetProcAddress(hModule, lpProcName);

        // 若函数指针，则抛出异常
        if (farProc == IntPtr.Zero)
            throw (new Exception(&amp;quot; 没有找到 : &amp;quot; + lpProcName + &amp;quot; 这个函数的入口点 &amp;quot;));

    }

    /// 
    /// 获得函数指针
    /// 
    /// &amp;lt; param name=&amp;quot;lpFileName&amp;quot; / &amp;gt; 包含需调用函数的 DLL 文件名 
    /// &amp;lt; param name=&amp;quot;lpProcName&amp;quot; / &amp;gt; 调用函数的名称 

    public void LoadFun(string lpFileName, string lpProcName)
    { // 取得函数库模块的句柄
        hModule = LoadLibrary(lpFileName);

        // 若函数库模块的句柄为空，则抛出异常
        if (hModule == IntPtr.Zero)
            throw (new Exception(&amp;quot; 没有找到 :&amp;quot; + lpFileName + &amp;quot;.&amp;quot;));

        // 取得函数指针
        farProc = GetProcAddress(hModule, lpProcName);

        // 若函数指针，则抛出异常
        if (farProc == IntPtr.Zero)
            throw (new Exception(&amp;quot; 没有找到 :&amp;quot; + lpProcName + &amp;quot; 这个函数的入口点 &amp;quot;));

    }


    //6.  添加UnLoadDll及Invoke方法，Invoke方法也进行了重载：
    /// 
    /// 卸载 Dll
    /// 

    public void UnLoadDll()
    {
        FreeLibrary(hModule);
        hModule = IntPtr.Zero;
        farProc = IntPtr.Zero;
    }

    /// 
    /// 调用所设定的函数
    /// 
    /// &amp;lt; param name=&amp;quot;ObjArray_Parameter&amp;quot; / &amp;gt; 实参 
    /// &amp;lt; param name=&amp;quot;TypeArray_ParameterType&amp;quot; / &amp;gt; 实参类型 
    /// &amp;lt; param name=&amp;quot;ModePassArray_Parameter&amp;quot; / &amp;gt; 实参传送方式 
    /// &amp;lt; param name=&amp;quot;Type_Return&amp;quot; / &amp;gt; 返回类型 
    ///  返回所调用函数的 object

    public object Invoke(object[] ObjArray_Parameter, Type[] TypeArray_ParameterType, 
                             ModePass[] ModePassArray_Parameter, Type Type_Return)
    {

        // 下面 3 个 if 是进行安全检查 , 若不能通过 , 则抛出异常
        if (hModule == IntPtr.Zero)
            throw (new Exception(&amp;quot; 函数库模块的句柄为空 , 请确保已进行 LoadDll 操作 !&amp;quot;));
        if (farProc == IntPtr.Zero)
            throw (new Exception(&amp;quot; 函数指针为空 , 请确保已进行 LoadFun 操作 !&amp;quot;));
        if (ObjArray_Parameter.Length != ModePassArray_Parameter.Length)
            throw (new Exception(&amp;quot; 参数个数及其传递方式的个数不匹配 .&amp;quot;));

        // 下面是创建 MyAssemblyName 对象并设置其 Name 属性
        AssemblyName MyAssemblyName = new AssemblyName();
        MyAssemblyName.Name = &amp;quot;InvokeFun&amp;quot;;

        // 生成单模块配件
        AssemblyBuilder MyAssemblyBuilder = AppDomain.CurrentDomain.DefineDynamicAssembly(
                                                   MyAssemblyName, AssemblyBuilderAccess.Run);
        ModuleBuilder MyModuleBuilder = MyAssemblyBuilder.DefineDynamicModule(&amp;quot;InvokeDll&amp;quot;);

        // 定义要调用的方法 , 方法名为“ MyFun ”，返回类型是“ Type_Return ”
        //参数类型是“ TypeArray_ParameterType ”
        MethodBuilder MyMethodBuilder = MyModuleBuilder.DefineGlobalMethod(
                                      &amp;quot;Init&amp;quot;, MethodAttributes.Public | MethodAttributes.Static, 
                                      Type_Return, TypeArray_ParameterType);

        // 获取一个 ILGenerator ，用于发送所需的 IL
        ILGenerator IL = MyMethodBuilder.GetILGenerator();

        int i;
        for (i = 0; i &amp;amp;lt; ObjArray_Parameter.Length; i++)
        {// 用循环将参数依次压入堆栈
            switch (ModePassArray_Parameter[i])
            {
                case ModePass.ByValue:
                    IL.Emit(OpCodes.Ldarg, i);
                    break;
                case ModePass.ByRef:
                    IL.Emit(OpCodes.Ldarga, i);
                    break;
                default:
                    throw (new Exception(&amp;quot; 第 &amp;quot; + (i + 1).ToString() + &amp;quot; 个参数没有给定正确的传递方式 .&amp;quot;));
            }
        }

        if (IntPtr.Size == 4)
        {// 判断处理器类型
            IL.Emit(OpCodes.Ldc_I4, farProc.ToInt32());
        }
        else if (IntPtr.Size == 8 )
        {
            IL.Emit(OpCodes.Ldc_I8, farProc.ToInt64());
        }
        else
        {
            throw new PlatformNotSupportedException();
        }

        IL.EmitCalli(OpCodes.Calli, CallingConvention.StdCall, Type_Return, TypeArray_ParameterType);
        IL.Emit(OpCodes.Ret); // 返回值
        MyModuleBuilder.CreateGlobalFunctions();

        // 取得方法信息
        MethodInfo MyMethodInfo = MyModuleBuilder.GetMethod(&amp;quot;Init&amp;quot;);
        return MyMethodInfo.Invoke(null, ObjArray_Parameter);// 调用方法，并返回其值
    }



    //Invoke方法的第二个版本，它是调用了第一个版本的：
    /// 
    /// 调用所设定的函数
    /// 
    /// &amp;lt; param name=&amp;quot;IntPtr_Function&amp;quot; / &amp;gt; 函数指针 
    /// &amp;lt; param name=&amp;quot;ObjArray_Parameter&amp;quot; / &amp;gt; 实参 
    /// &amp;lt; param name=&amp;quot;TypeArray_ParameterType&amp;quot; / &amp;gt; 实参类型 
    /// &amp;lt; param name=&amp;quot;ModePassArray_Parameter&amp;quot; / &amp;gt; 实参传送方式 
    /// &amp;lt; param name=&amp;quot;Type_Return&amp;quot; / &amp;gt; 返回类型 
    ///  返回所调用函数的 object

    public object Invoke(IntPtr IntPtr_Function, object[] ObjArray_Parameter, 
                           Type[] TypeArray_ParameterType, ModePass[] ModePassArray_Parameter, 
                           Type Type_Return)
    {

        // 下面 2 个 if 是进行安全检查 , 若不能通过 , 则抛出异常
        if (hModule == IntPtr.Zero)
            throw (new Exception(&amp;quot; 函数库模块的句柄为空 , 请确保已进行 LoadDll 操作 !&amp;quot;));
        if (IntPtr_Function == IntPtr.Zero)
            throw (new Exception(&amp;quot; 函数指针 IntPtr_Function 为空 !&amp;quot;));
        farProc = IntPtr_Function;
        return Invoke(ObjArray_Parameter, TypeArray_ParameterType, ModePassArray_Parameter, Type_Return);
    }            

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
&lt;/pre&gt;
&lt;pre class=&#34;brush: csharp&#34;&gt;/****&lt;strong&gt;&lt;em&gt;调用方法&lt;/em&gt;&lt;/strong&gt;***/
        private void button1_Click(object sender, RoutedEventArgs e)
        {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        DLD newDLL = new DLD();
        newDLL.LoadFun(&amp;quot;E:\\workspaces\\WpfApplication1\\Debug\\DLL.dll&amp;quot;, &amp;quot;Init&amp;quot;);
        StringBuilder MyStringBuilder = new StringBuilder(&amp;quot;Hello World!&amp;quot;);
        object[] obj = new object[] { MyStringBuilder };
        Type[] ty = new Type[] { typeof(StringBuilder) };
        ModePass[] mode = new ModePass[] { ModePass.ByValue };
        Type Type_Return = typeof(StringBuilder);
        StringBuilder j = (StringBuilder)newDLL.Invoke(obj, ty, mode, Type_Return);

    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;/*****&lt;strong&gt;&lt;em&gt;c++DLL中的函数&lt;/em&gt;&lt;/strong&gt;****/&lt;/p&gt;

&lt;p&gt;extern &amp;ldquo;C&amp;rdquo; __declspec(dllexport) LPTSTR Init(LPTSTR a);&lt;/p&gt;

&lt;p&gt;LPTSTR Init(LPTSTR a)
{
    strcat((char *)a, &amp;ldquo;added&amp;rdquo;);
    return a;
}
&lt;/pre&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>openssl建立SSL连接例子程序</title>
      <link>http://www.daniex.tk/blog/2011/examples-of-procedures-to-establish-ssl-connection-openssl/</link>
      <pubDate>Tue, 19 Apr 2011 11:15:46 &#43;0000</pubDate>
      <author>Daniex</author>
      <guid>http://www.daniex.tk/blog/2011/examples-of-procedures-to-establish-ssl-connection-openssl/</guid>
      <description>&lt;p&gt;下面是server 和client 的代码。用没跑过，但是用类似的代码跑了。流程是这样的。要注意的是openssl中ssl连接建立前用阻塞的socket，建立后可以设置非阻塞。openssl每个操作后最好检查下是否成功。
&lt;pre class=&#34;brush:php&#34;&gt;
/*********&lt;strong&gt;&lt;em&gt;server&lt;/em&gt;&lt;/strong&gt;*******************&lt;strong&gt;&lt;em&gt;/
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;winsock2.h&amp;gt;
#include &amp;lt;openssl/ssl.h&amp;gt;
#include &amp;lt;openssl/x509.h&amp;gt;
#include &amp;lt;openssl/rand.h&amp;gt;
#include &amp;lt;openssl/err.h&amp;gt;
&amp;nbsp;
#pragma comment (lib,&amp;ldquo;WS2_32.lib&amp;rdquo;)
#pragma comment( lib, &amp;ldquo;libeay32.lib&amp;rdquo; )
#pragma comment( lib, &amp;ldquo;ssleay32.lib&amp;rdquo; )
&amp;nbsp;
char buffer[10001] = {0};
&amp;nbsp;
int main()
{
SSL_library_init(); //初始化SSL库
OpenSSL_add_all_algorithms(); //支持所有算法
SSL_load_error_strings();  //提供将错误号解析为字符串的功能
SSL *ssl = NULL;
SSL_CTX *ssl_ctx = NULL;
SSL_METHOD *ssl_method = NULL;
X509 *client_cert = NULL;
//设置客户端使用的SSL版本
//ssl_method = SSLv3_server_method();
ssl_method = SSLv23_server_method();
//创建SSL上下文环境 每个进程只需维护一个SSL_CTX结构体
ssl_ctx = SSL_CTX_new(ssl_method);
&amp;nbsp;
//验证对方
SSL_CTX_set_verify(ssl_ctx,SSL_VERIFY_PEER,NULL);
&amp;nbsp;
//若验证,则放置CA证书
SSL_CTX_load_verify_locations(ssl_ctx, &amp;ldquo;cacert.pem&amp;rdquo;, NULL);
&amp;nbsp;
//设置pass phrase
SSL_CTX_set_default_passwd_cb_userdata(ssl_ctx, &amp;ldquo;pass phrase&amp;rdquo;);
//读取证书文件
SSL_CTX_use_certificate_file(ssl_ctx,&amp;rdquo;&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;Cert.pem&amp;rdquo;,SSL_FILETYPE_PEM);
&amp;nbsp;
//读取密钥文件
SSL_CTX_use_PrivateKey_file(ssl_ctx,&amp;rdquo;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;Key.pem&amp;rdquo;,SSL_FILETYPE_PEM);
&amp;nbsp;
//验证密钥是否与证书一致
SSL_CTX_check_private_key(ssl_ctx);
&amp;nbsp;
/*构建随机数生成机制,WIN32平台必需&lt;/em&gt;/
srand( (unsigned)time( NULL ) );
for( int i = 0;    i &amp;lt; 100;i++ )
seed_int[i] = rand();
RAND_seed(seed_int, sizeof(seed_int));
//设置加密方式
//SSL_CTX_set_cipher_list(ssl_ctx,&amp;ldquo;RC4-MD5&amp;rdquo;);
//建立TCP服务器端、开始监听并接受客户端连接请求
&amp;nbsp;
// 初始化 Winsock.
WSADATA wsaData;
int iResult = WSAStartup( MAKEWORD(2,2), &amp;amp;wsaData );
if ( iResult != NO_ERROR )
{
//失败
return -1;
}
// 建立socket
server = socket( AF_INET, SOCK_STREAM, IPPROTO_TCP );
if ( server == INVALID_SOCKET )
{
//失败
WSACleanup();
return -2;
}
&amp;nbsp;
// 绑定socket
sockaddr_in service;
service.sin_family = AF_INET;
//service.sin_addr.s_addr = inet_addr(&amp;ldquo;127.0.0.1&amp;rdquo;);
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons( 8899 );
&amp;nbsp;
if ( bind( server, (SOCKADDR*) &amp;amp;service, sizeof(service) ) == SOCKET_ERROR )
{
//失败
closesocket(server);
return -3;
}
&amp;nbsp;
// 监听 socket
if ( listen( server, 10 ) == SOCKET_ERROR )
{
//失败
return -4;
}
&amp;nbsp;
do
{
sClient = accept(server,NULL,NULL);
Sleep(100);
}while(sClient == INVALID_SOCKET);
&amp;nbsp;
//创建当前连接的SSL结构体
ssl = SSL_new(ssl_ctx);
//将SSL绑定到套接字上
SSL_set_fd(ssl, sClient);
&amp;nbsp;
//接受SSL链接
SSL_accept(ssl);
&amp;nbsp;
//获取和释放客户端证书
client_cert = SSL_get_peer_certificate(ssl);
//打印所有加密算法的信息(可选)
std::cout&amp;lt;&amp;lt;&amp;ldquo;SSL connection using&amp;rdquo;&amp;lt;&amp;lt;SSL_get_cipher(ssl)&amp;lt;&amp;lt;std::endl;
&amp;nbsp;
X509_free(client_cert);
&amp;nbsp;
//unsigned long cmd;
//if (SOCKET_ERROR == ioctlsocket(sClient, FIONBIO, &amp;amp;cmd))
//{
//创建套接字时发生错误，非阻塞设置失败
//ErrorProcess();
//closesocket(sClient);
//}
&amp;nbsp;
while(true)
{
SSL_read(ssl, buffer, 10000);
memset(buffer,0,10000);
SSL_write(ssl, &amp;ldquo;hello, world!&amp;rdquo;, sizeof(&amp;ldquo;hello, world!&amp;rdquo;));
Sleep(1000);
&amp;nbsp;
}
&amp;nbsp;
//断开SSL链接
SSL_shutdown(ssl);
//释放当前SSL链接结构体
SSL_free(ssl);
//断开TCP链接
closesocket(sClient);
//释放SSL上下文
SSL_CTX_free(ssl_ctx);
&amp;nbsp;
return 0;
}
&lt;/pre&gt;
&lt;pre class=&#34;brush:php&#34;&gt;
/&lt;/strong&gt;*********&lt;strong&gt;&lt;em&gt;client&lt;/em&gt;&lt;/strong&gt;***************&lt;strong&gt;&lt;em&gt;/
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;winsock2.h&amp;gt;
#include &amp;lt;openssl/ssl.h&amp;gt;
#include &amp;lt;openssl/x509.h&amp;gt;
#include &amp;lt;openssl/rand.h&amp;gt;
#include &amp;lt;openssl/err.h&amp;gt;
#pragma comment (lib,&amp;ldquo;WS2_32.lib&amp;rdquo;)
#pragma comment( lib, &amp;ldquo;libeay32.lib&amp;rdquo; )
#pragma comment( lib, &amp;ldquo;ssleay32.lib&amp;rdquo; )
&amp;nbsp;
int main(int argc, _TCHAR&lt;/em&gt; argv[])
{
&amp;nbsp;
SOCKET client;
char buffer[256] = {0};
int  seed_int[100]; /&lt;em&gt;存放随机序列&lt;/em&gt;/
&amp;nbsp;
SSL &lt;em&gt;ssl = NULL;
SSL_CTX *ssl_ctx = NULL;
SSL_METHOD *ssl_method = NULL;
X509 *server_cert = NULL;
&amp;nbsp;
SSL_library_init();        //init libraries
OpenSSL_add_all_algorithms(); //支持所有算法
SSL_load_error_strings();  //提供将错误号解析为字符串的功能
&amp;nbsp;
&amp;nbsp;
//设置客户端使用的SSL版本
ssl_method = SSLv3_client_method();
//创建SSL上下文环境 每个进程只需维护一个SSL_CTX结构体
ssl_ctx = SSL_CTX_new(ssl_method);
/*构建随机数生成机制,WIN32平台必需&lt;/em&gt;/
srand( (unsigned)time( NULL ) );
for( int i = 0;    i &amp;lt; 100;i++ )
seed_int[i] = rand();
RAND_seed(seed_int, sizeof(seed_int));
&amp;nbsp;
&amp;nbsp;
/* Load the RSA CA certificate into the SSL_CTX structure &lt;em&gt;/
/&lt;/em&gt; This will allow this client to verify the server&amp;rsquo;s   &lt;em&gt;/
/&lt;/em&gt; certificate.                             &lt;em&gt;/
SSL_CTX_load_verify_locations(ssl_ctx, &amp;ldquo;cacert.pem&amp;rdquo;, NULL);
&amp;nbsp;
/&lt;/em&gt; Set flag in context to require peer (server) certificate verification */
SSL_CTX_set_verify(ssl_ctx,SSL_VERIFY_PEER,NULL);
SSL_CTX_set_verify_depth(ssl_ctx,1);
SSL_CTX_set_default_passwd_cb_userdata(ssl_ctx, &amp;ldquo;pass phrase&amp;rdquo;);
//读取证书文件
SSL_CTX_use_certificate_file(ssl_ctx,&amp;rdquo;&lt;/strong&gt;*&lt;strong&gt;&lt;em&gt;Cert.pem&amp;rdquo;,SSL_FILETYPE_PEM);
//读取密钥文件
SSL_CTX_use_PrivateKey_file(ssl_ctx,&amp;rdquo;&lt;/em&gt;&lt;/strong&gt;**&lt;em&gt;Key.pem&amp;rdquo;,SSL_FILETYPE_PEM);
//验证密钥是否与证书一致
SSL_CTX_check_private_key(ssl_ctx);
&amp;nbsp;
&amp;nbsp;
//建立TCP链接
// 初始化 Winsock.
WSADATA wsaData;
int iResult = WSAStartup( MAKEWORD(2,2), &amp;amp;wsaData );
if ( iResult != NO_ERROR )
{
//AfxMessageBox(&amp;ldquo;Error at WSAStartup()!&amp;rdquo;);
return;
}
&amp;nbsp;
// 建立socket socket.
client = socket( AF_INET, SOCK_STREAM, IPPROTO_TCP );
if ( client == INVALID_SOCKET )
{
//AfxMessageBox(&amp;ldquo;Error at socket!&amp;rdquo;);
WSACleanup();
return;
}
&amp;nbsp;
// 连接到服务器.
sockaddr_in clientService;
clientService.sin_family = AF_INET;
clientService.sin_addr.s_addr = inet_addr( &amp;ldquo;127.0.0.1&amp;rdquo; );
clientService.sin_port = htons( 8899 );
if ( connect( client, (SOCKADDR&lt;/em&gt;) &amp;amp;clientService, sizeof(clientService) ) == SOCKET_ERROR)
{
//AfxMessageBox( &amp;ldquo;Failed to connect!&amp;rdquo; );
WSACleanup();
return;
}
&amp;nbsp;
//unsigned long cmd;
//if (SOCKET_ERROR == ioctlsocket(client, FIONBIO, &amp;amp;cmd))
//{
//  //AfxMessageBox( &amp;ldquo;创建套接字时发生错误，非阻塞设置失败：&amp;rdquo;);
//  closesocket(client);
//}
//创建维护当前连接信息的SSL结构体
ssl = SSL_new(ssl_ctx);
//将SSL绑定到套接字上
SSL_set_fd(ssl, client);
//建立SSL链接
SSL_connect(ssl);
&amp;nbsp;
//获取服务器端证书
server_cert = SSL_get_peer_certificate(ssl);
&amp;nbsp;
//释放服务器端证书
X509_free(server_cert);
&amp;nbsp;
unsigned long cmd;
if (SOCKET_ERROR == ioctlsocket(client, FIONBIO, &amp;amp;cmd))
{
//AfxMessageBox( &amp;ldquo;创建套接字时发生错误，非阻塞设置失败：&amp;rdquo;);
closesocket(client);
}
while(true)
{
SSL_write(ssl, &amp;ldquo;hello, world!&amp;rdquo;, sizeof(&amp;ldquo;hello, world!&amp;rdquo;)；
SSL_read(ssl, buffer, 255);
printf(&amp;ldquo;received: %s\n&amp;rdquo;,buffer);
memset(buffer,0,255);
&amp;nbsp;
Sleep(1000);
}
//断开SSL链接
SSL_shutdown(ssl);
//释放当前SSL链接结构体
SSL_free(ssl);
closesocket(client);
//释放上下文
SSL_CTX_free(ssl_ctx);
&amp;nbsp;
return 0;
}
&amp;nbsp;
&lt;/pre&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>用openssl命令制作生成证书和自签名</title>
      <link>http://www.daniex.tk/blog/2011/generated-with-the-openssl-command-to-create-self-signed-certificates-and/</link>
      <pubDate>Sat, 16 Apr 2011 10:04:41 &#43;0000</pubDate>
      <author>Daniex</author>
      <guid>http://www.daniex.tk/blog/2011/generated-with-the-openssl-command-to-create-self-signed-certificates-and/</guid>
      <description>&lt;p&gt;前文描述了如何在window下按安装openssl后，这里说下如何利用openssl生成证书。&lt;/p&gt;

&lt;p&gt;1、  新建工作目录，将openssl安装路径下的apps/CA.pl 和 apps/openssl.cnf（在window中该文件会显示成名为openssl的快速拨号程序）文件复制到该路径。可以修改openssl.cnf文件中的一些参数。启动控制台，执行命令
CA.pl -newca
生成CA工作所需的文件和文件夹。即该目录下新生成的demoCA文件夹。将openssl安装路径下的apps\demoCA\serial文件复制到生成的demoCA文件夹下。&lt;/p&gt;

&lt;p&gt;可以略去该步骤，在安装路径\apps下执行后续步骤。&lt;/p&gt;

&lt;p&gt;2、  生成根证书和对应的私钥
openssl req -new -x509 -keyout cakey.pem -out cacert.pem -config openssl.cnf
记住输入的pass phrase、国家、省、组织等参数，不能全为空。将生成的cakey.pem放到demoCA/private目录下，将cacert.pem放到demoCA目录下。
注意：在window下需要openssl命令都需要增加-config openssl.cnf参数，防止因找不到配置文件而报错。Linux下不需要该参数。
&lt;img alt=&#34;&#34; src=&#34;http://farm6.static.flickr.com/5189/5620697845_30c20ca29e.jpg&#34; title=&#34;生成证书&#34; class=&#34;aligncenter&#34; width=&#34;500&#34; height=&#34;483&#34; /&gt;&lt;/p&gt;

&lt;p&gt;3、  生成服务证书私钥和证书请求文件
openssl req -newkey rsa:2048 -out newCSR.pem -keyout newKey.pem -config openssl.cnf
如果要生成多个证书私钥对，注意输入Common Name值要不同。如果不是自签名，可将生成的证书请求文件newCSR.pem交由相关组织签发证书。&lt;/p&gt;

&lt;p&gt;4、  用根证书签发该服务证书
openssl ca -in newCSR.pem -out newCert.pem -config openssl.cnf
&lt;img alt=&#34;&#34; src=&#34;http://farm6.static.flickr.com/5189/5620697845_30c20ca29e.jpg&#34; title=&#34;签名&#34; class=&#34;aligncenter&#34; width=&#34;500&#34; height=&#34;483&#34; /&gt;&lt;/p&gt;

&lt;p&gt;至此，我们生成了根证书和私钥cakey.pem、cacert.pem。用于服务由根证书签发了的证书newCert.pem和对应私钥newKey.pem。openssl编程过程中，需要验证newCert.pem和newKey.pem是否匹配。用根证书cacert.pem验证newCert.pem是否可信。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>excel中删除回车和换行符</title>
      <link>http://www.daniex.tk/blog/2011/excel-remove-carriage-return-and-line-feed/</link>
      <pubDate>Sun, 10 Apr 2011 10:05:00 &#43;0000</pubDate>
      <author>Daniex</author>
      <guid>http://www.daniex.tk/blog/2011/excel-remove-carriage-return-and-line-feed/</guid>
      <description>&lt;p&gt;遇到个问题：在excel保存的csv文件里面有换行符，但是读取文件的时候是按行读取的，所以要把换行符去掉。在网上找了几个方法，都没成功，不过最后还是被我解决了。&lt;/p&gt;

&lt;p&gt;网上有好几种方法，要们只是去除的文件中的换行符，而没有去除回车符。要不然就是繁琐。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;13; (ASCII码回车)
10; (ASCII码换行)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;方法一
可以使用Excel的宏来将excel的换行符替换掉，方法如下：
在工作表标签处单击鼠标右键，点“查看代码”，在代码窗口中输入如下内容：&lt;/p&gt;

&lt;p&gt;Sub 去掉所有换行符()
    Cells.Replace What:=Chr(10), _
                  Replacement:=&amp;ldquo;&amp;rdquo;, _
                  LookAt:=xlPart, _
                  SearchOrder:=xlByRows, _
                  MatchCase:=False, _
                  SearchFormat:=False, _
                  ReplaceFormat:=False
End Sub&lt;/p&gt;

&lt;p&gt;然后按F5执行，或者点击菜单上的运行。这个代码是指去掉了换行符，将第二行的10换成13，再执行一次就大功告成。&lt;/p&gt;

&lt;p&gt;方法二
另存为txt文件的话，换行符会变为回车符，这样在记事本替换的话会比较麻烦。你可以将EXCEL的内容复制到word中，然后使用word的替换功能，将^l替换为空白就行了。(^l)就是换行符。&lt;/p&gt;

&lt;p&gt;1、把所需修改的整个表格复制到Word中；
2、再从Word中把所有内容复制到记事本中；
3、最后把记事本中的所有内容复制到excel中。DONE!&lt;/p&gt;

&lt;p&gt;方法三
网上流最广的方法是这样的：
1、CTRL+F调出查找替换对话框，选择替换
2、查找中输入：按住ALT，小键盘输入10 ,松开ALT
3、按替换
我尝试着按住ALT+13，查找替换，没有成功。只能放弃这种方法。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Windows下安装OpenSSL</title>
      <link>http://www.daniex.tk/blog/2011/windows-install-openssl/</link>
      <pubDate>Mon, 28 Mar 2011 03:25:40 &#43;0000</pubDate>
      <author>Daniex</author>
      <guid>http://www.daniex.tk/blog/2011/windows-install-openssl/</guid>
      <description>&lt;p&gt;环境：window xp； OpenSSL：0.9.8k；IDE：MS Visual Studio 2008&lt;/p&gt;

&lt;p&gt;解压OpenSSL， 在其目录下可以有个INSTALL.W32文件，这个文件就是在windows下的安装说明。用UltraEdit等工具打开它查看安装编译方法。&lt;/p&gt;

&lt;p&gt;安装前需要准备的是VS环境和perl环境。vs安装就不说了。perl可以到&lt;a href=&#34;http://www.activestate.com/ActivePerl&#34;&gt;http://www.activestate.com/ActivePerl&lt;/a&gt; 去下载安装。注意加入环境变量。&lt;/p&gt;

&lt;p&gt;再之后就可以安装了，使用vs提供的控制台安装。否则安装过程中会报出&amp;rdquo;ml&amp;rdquo;不是内部或外部命令之类的提示。&lt;/p&gt;

&lt;p&gt;&lt;a title=&#34;Flickr 上 Daniex Jiang 的 cl&#34; href=&#34;http://www.flickr.com/photos/daniex/5566069829/&#34;&gt;&lt;img src=&#34;http://farm6.static.flickr.com/5189/5566069829_862458b6e8_z.jpg&#34; alt=&#34;cl&#34; width=&#34;640&#34; height=&#34;105&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;打开控制台口依次：&lt;/p&gt;

&lt;p&gt;1.输入：perl Configure VC-WIN32&lt;/p&gt;

&lt;p&gt;2.使用MASM，输入：ms\do_masm&lt;/p&gt;

&lt;p&gt;3.接着输入：nmake -f ms\ntdll.mak 安装&lt;/p&gt;

&lt;p&gt;4.输入：nmake -f ms\ntdll.mak test 测试安装是否成功。&lt;/p&gt;

&lt;p&gt;最后会显示 all tests passed提示。编译就通过了，在out32dll目录下面就可以看到生成的dll文件和可执行文件。&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Ubuntu与windows间的远程桌面、共享文件访问</title>
      <link>http://www.daniex.tk/blog/2011/between-ubuntu-and-windows-remote-desktop-shared-file-access/</link>
      <pubDate>Mon, 07 Mar 2011 12:10:16 &#43;0000</pubDate>
      <author>Daniex</author>
      <guid>http://www.daniex.tk/blog/2011/between-ubuntu-and-windows-remote-desktop-shared-file-access/</guid>
      <description>&lt;p&gt;1、 Ubuntu访问windows&lt;/p&gt;

&lt;p&gt;这方面基本上Ubuntu系统上做的已经很全了，现有的应用用起来就行。远程桌面可以用Remote Desktop Viewer和Terminal Server Client两个应用。都在Applications-&amp;gt;Internet目录下。有俩截图如下：&lt;img class=&#34;aligncenter&#34; title=&#34;RDV&amp;amp;TSC&#34; src=&#34;http://farm6.static.flickr.com/5178/5505991350_930ecf16d2.jpg&#34; alt=&#34;应用位置&#34; width=&#34;473&#34; height=&#34;345&#34; /&gt;&lt;/p&gt;

&lt;p&gt;两个应用的界面分别为：&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter&#34; title=&#34;Remote Desktop Viewer&#34; src=&#34;http://farm6.static.flickr.com/5219/5505991512_3b0b3e514f.jpg&#34; alt=&#34;&#34; width=&#34;500&#34; height=&#34;409&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter&#34; title=&#34;Terminal Server Client&#34; src=&#34;http://farm6.static.flickr.com/5171/5505394227_3a37ef989a.jpg&#34; alt=&#34;&#34; width=&#34;373&#34; height=&#34;500&#34; /&gt;
&lt;p id=&#34;best-answer-content&#34;&gt;PS:&lt;/p&gt;
VNC (Virtual Network Computing)是虚拟网络计算机的缩写。VNC是一款优秀的远程控制工具软件，由著名的AT&amp;amp;T的欧洲研究实验室开发的。
&lt;p id=&#34;best-answer-content&#34;&gt;RDP:远程桌面协议，主要用于windows 2000及更早的windows版本。 RDPv5支持xp等。&lt;/p&gt;
&lt;p id=&#34;best-answer-content&#34;&gt;SSH: Secure Shell Protocol，是一种在不安全网络上提供安全远程登录及其它安全网络服务的协议。&lt;/p&gt;
共享文件的访问有另外一个应用，这个应用能进行FTP，http的访问。位于Places-&amp;gt;connect to server。&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter&#34; title=&#34;connect to server&#34; src=&#34;http://farm6.static.flickr.com/5172/5505991388_9e08508c3b.jpg&#34; alt=&#34;&#34; width=&#34;344&#34; height=&#34;423&#34; /&gt;&lt;/p&gt;

&lt;p&gt;界面如下；&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter&#34; title=&#34;connect to server&#34; src=&#34;http://farm6.static.flickr.com/5135/5505394145_dbbf6594d4.jpg&#34; alt=&#34;&#34; width=&#34;369&#34; height=&#34;358&#34; /&gt;&lt;/p&gt;

&lt;p&gt;2、windows访问ubuntu。Ubuntu互访。&lt;/p&gt;

&lt;p&gt;公司不准私自架设ftp等服务器。所以通常通过文件共享。Linux也可以类似window那样共享文件，只是Ubuntu需要先安装应用。&lt;/p&gt;

&lt;p&gt;Windows和Linux间共享可以用samba。Linux和Linux之间共享文件有更好的网络文件系统NFS。网上使用教程方法很多，这里就不多说了。&lt;/p&gt;

&lt;p&gt;再废话一句，linux里很多可以用mount。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>